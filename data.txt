Welcome Rapidly build stunning React Web Apps based on MUI with Vuexy template We present you with a Developer friendly, Highly customizable & Carefully crafted React Admin Dashboard Template based on Next.js. Thanks for purchasing our template üôÇ. Let's get you up and running.  Getting Started Must read guide before getting started. It will answer all of your questions to get started with our template. Get started   Installation Let's install your project first. Please visit the installation page for a detailed guide on how to install and run the template. Start now   Template Customization If you want to quickly update the UI of our template just like using the customizer, use our themeConfig.js file for it. Configure it   Folder Structure Get started and understand how files and folders are organized in our template to understand how it works. Read more   Layout Structure Easily create any pages of your app with the knowledge of layouts and layout components. Read more   FAQs Stuck on a particular problem? Check some of these common gotchas first in the FAQs. Read more   Articles You can find all the helpful articles to implement or remove certain features from the template. Read more   Repository Access Get the private repository access to track the premium version development easily. Fork the repository to get the seamless updates. Get access   Premium Support Experience premium customer support from the people who have crafted this theme. Premium support is limited to pro version only. Get support 
# Folder Structure Heads Up Do not make any changes in the src/@core folder unless suggested by our support team. It is the core functionality of the template which is responsible to run the template and will be updated with every new update. Use src/layouts folder to override core layouts and components. Understand folder structure of the template and what every folder contains. # Overview Before checking folder structure it is better you know some stuff related to folder structure. src/@core folder contains core files of template which shall not get modified unless our support team guide you to do it. Outside of src/@core folder are files you can move and modify as per your wish. Basically that is your playground where you can modify anything. src/@fake-db folder just contains dummy data which we get in response of API call. This enables us to take step forward in providing API ready template. src/layouts folder outside of src/@core are your layouts which you can modify however you like. Template will always render these layouts. # Main Package Following is the folder structure of the full-version under both typescript / javascript version. Not explaining the folder structure for starter kit as everything is covered in the full version. ‚îú‚îÄ‚îÄ public
‚îÇ   ‚îú‚îÄ‚îÄ images                   -> Static assets
‚îÇ   ‚îú‚îÄ‚îÄ locales                  -> Translations
‚îÇ   ‚îî‚îÄ‚îÄ other files
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ @core                    -> Template's core files
‚îÇ   ‚îú‚îÄ‚îÄ @fake-db                 -> Fake Database for mocking axios requests (Fake API Calls)
‚îÇ   ‚îú‚îÄ‚îÄ configs                  -> Configuration files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ acl.ts               -> Your Access Control file/configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts              -> Your authentication file/configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ i18n.ts              -> i18n configurations and initialization
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ themeConfig.ts       -> Template configurations
‚îÇ   ‚îú‚îÄ‚îÄ context                  -> Your context files go here
‚îÇ   ‚îú‚îÄ‚îÄ hooks                    -> Your hooks go here
‚îÇ   ‚îú‚îÄ‚îÄ layouts                  -> Your layouts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components           -> Your components, layout components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserLayout.tsx       -> File responsible to render layout & template
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserThemeOptions.ts  -> Your theming file to override core theming
‚îÇ   ‚îú‚îÄ‚îÄ navigation               -> Vertical & Horizontal static navigation menu files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ horizontal
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vertical
‚îÇ   ‚îú‚îÄ‚îÄ pages                    -> View files that render all the pages
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _app.tsx             -> Main file responsible to render layout
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _document.tsx        -> HTML document & emotions configurations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx            -> Application entry file
‚îÇ   ‚îú‚îÄ‚îÄ store                    -> Redux store
‚îÇ   ‚îú‚îÄ‚îÄ types                    -> All types (only in the typescript version)
‚îÇ   ‚îî‚îÄ‚îÄ views                    -> View files that are included in pages folder
‚îú‚îÄ‚îÄ styles                       -> Global styling
‚îú‚îÄ‚îÄ .env                         -> Environment file
‚îú‚îÄ‚îÄ .eslintrc.json               -> ESLint configurations (Linting code)
‚îú‚îÄ‚îÄ .gitignore                   -> gitignore (ignore files and folder to sync with repo)
‚îú‚îÄ‚îÄ .npmrc                       -> Node configuration file
‚îú‚îÄ‚îÄ .nvmrc                       -> nvm configuration file
‚îú‚îÄ‚îÄ .prettierrc.js               -> Prettier configurations (editor code formatting)
‚îú‚îÄ‚îÄ next.config.js               -> Next js configurations
‚îú‚îÄ‚îÄ next.d.ts                    -> Next js global types configurations
‚îú‚îÄ‚îÄ package.json                 -> All the dependencies require to run the template
‚îú‚îÄ‚îÄ tsconfig.json               -> TypeScript configurations
# @core folder src/@core folder is the core of our template which contains core layouts, components and theming where you should not make any change but override them with the help of our layout docs in case of any changes required in core files. src/@core folder isn't meant to get modified. When you will update our template replacing this src/@core folder will hopefully update the template with minimum changes. It's a good idea to have a look at it and know what it contains to use stuff we already invented so you don't have to reinvent the wheel. # Understanding Core folder Understanding the src/@core folder will save your development time and you will know how to get most out of our template. Folder Description components It contains core components of the template. Make sure to check them all in our custom components section context Settings context which is responsible for live template customization hooks useSettings is used to access settings context values, useBgColor is used to get different colors and useClipboard is used to copy some texts layouts All the layouts and layout components like menu, appBar and footer reside in this folder for any user to override from the @core folder styles MUI's stepper styled component and all the third party styled components reside in this folder theme All the MUI theming like palette, breakpoints, typography, component's styling etc. are done in this folder utils All the helpful functions used in whole template. Users can also import and use these useful functions.
# Getting Support In this page you will find how to get support and how to raise perfect support ticket to resolve your issues quickly with minimum conversation. We value your time üïù # Raising Support Ticket Raising support ticket in support portal is as simple as commenting on post. However, If you want to get your issues resolved quickly please follow below guide: # Finding existing solution There might be a case that your issue is already resolved and you are the one who is facing due to some issue. So before creating new support ticket please search your question / issue in our FAQ page where we have listed most common questions / issues asked in our support portal. # Ticket Type Add ticket type to your ticket title to let community understand what your ticket is about. This also helps to find related tickets using ticket type. So, your ticket till will be like [question] how to change theme? Some common ticket types are listed below: question - If you are asking question installation - If you have anything related to installation auth - If you have anything related to JWT or Auth acl - If you have anything related to Access Control feat-req - If you have any feature request for our template bug - If you find any bug in template other - if your ticket isn't related to above mentioned ticket types Good examples can be: üíØ [question] How to change theme? [question] How to change i18n locale? [installation] Getting errors in npm run dev [auth] Unexpected behavior after login [other] Collapse component is not working as expected [auth] I get redirected to login page even after login on refresh # New Issue - New ticket Always consider creating a new support ticket for the question or issue you might have that is not related to your currently open ticket. Let's say you opened ticket for installation issue and want to ask about some component usage then it will be better to close installation ticket and open another ticket for that component to make support portal more accurate and easy find place. # Template Version Mentioning which version of our template you are using will help us to answer more accurately and will mitigate one question from our side. Mentioning template version includes if you are using TypeScript or JavaScript, Full-Version or Starter-Kit. Also, if you are using some other technology with our template then mentioning it will also help us in resolving issue quickly. Good examples can be: üíØ TypeScript + Full Version Javascript + Starter Kit # Sharing Code or Snippet If you want to show us some code it will be better if you can format it properly and use code block so your pasted code get highlighted. # Reproducing Issue/Bug - Starter-kit If you have ticket where we need to have a look at your code like some component's certain feature is working in our live demo but not in your downloaded package then it will better you give us actual issue or reproduction steps. Best solution for this is using our Starter-kit where we can test it without any dependency. This will also help you to clear your issue before sending it to us. You can create zip and share with us using private link. WARNING Never upload our package or modified version of our package on public sites where others can view or download it. # Support Portal Once you have purchased our template, You can get support at our support portal  (opens new window) by raising support ticket. Please make sure to follow standards defined in Raising Support Ticket section. Don't want to waste time? Creating perfect support ticket (Following our Guide) will increase the chances of getting issue resolved with minimum conversation and time. # Framework Support To get support for framework related question, raise issue at their Github  (opens new window) repo. Good candidates for framework support are: How to use x component (x means any MUI Component) x component not working as expected # Third Party Package Support Same as framework support, if you have any query regarding how to use any provided package other than their UI you can ask it in their respective Github repo issue section.
# Layout Types TIP We recommend you to go through the Layout Docs of NextJS  (opens new window) to understand how the layout works in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview We provide four types of layouts: Vertical Layout, Horizontal Layout, Blank Layout and Blank Layout with AppBar. Each of them is explained in detail. # Vertical Layout This is the default layout. With this layout, you will get the following layout components: Navigation Menu (left sidebar) Navbar (at top of the page) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Vertical Layout looks like this:  # Horizontal Layout You can make this your default layout. With this layout, you will get the following layout components: Navbar (at top of the page) Navigation Menu (on top of the page below the Navbar) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Horizontal Layout looks like this:  # Blank Layout This is useful if you want to create pages without any other content and where you don't need a navbar, navigation menu and footer. For example, an Authentication page. This is a blank page where you can create everything from scratch. Blank Layout in Login page looks like this:  # Blank Layout with AppBar This is useful if you want to create pages where you don't need a navigation menu and footer. For example, an Authentication page. With this layout, you will get a navbar (or AppBar) on top of the page. AppBar is explained here. Blank Layout with AppBar in Login page looks like this: 
# Access Control (ACL) # Overview Vuexy uses the CASL  (opens new window) package to provide access control. CASL is future-oriented and is more detailed on Access Control. We suggest you read the CASL  (opens new window) documentation to learn how it works. CASL may look complex at first so please make sure you first read their docs carefully and understand the base logic of Access Control to proceed further. # Config You can find CASL configuration in src/configs/acl.ts. We have defined two roles admin & client and their actions in the configuration file. You'll have to update these roles & actions according to your application requirement. const defineRulesFor = (role, subject) => {
  const { can, rules } = new AbilityBuilder(AppAbility)

  if (role === 'admin') {
    can('manage', 'all')
  } else if (role === 'client') {
    can(['read'], 'acl-page')
  } else {
    can(['read', 'create', 'update', 'delete'], subject)
  }

  return rules
}
# Component To define an accessible component use acl method with action & subject properties like shown below. You can also refer full-version/src/pages/acl/index.tsx file for implementation. ¬†¬†¬†¬†const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
# Navigation Define the action & subject properties in navigation file to show/hide the navigation links/groups based on user role. Refer to the example below: ¬†¬†{
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
# Home URL Please update home URL based on yser role in src/pages/index.tsx file. Currently, we have set default URL for client and admin like following:  # How to remove ACL It is quite easy to remove access control from the template. Remove the src/configs/acl.ts file Remove the import type { ACLObj } from 'src/configs/acl' import statement & acl?: ACLObj from next.d.ts file if next.d.ts file is present in your project. Remove the src/@core/components/auth/AclGuard.tsx file Remove the AclGuard wrapper & ACL related imports from src/pages/_app.tsx file. Change following code from: // Code before removing ACL Guard
import { defaultACLObj } from 'src/configs/acl'
import AclGuard from 'src/@core/components/auth/AclGuard'

const aclAbilities = Component.acl ?? defaultACLObj

<AclGuard aclAbilities={aclAbilities} guestGuard={guestGuard}>
  {getLayout(<Component {...pageProps} />)}
</AclGuard>
to // Code after removing ACL Guard
{getLayout(<Component {...pageProps} />)}
 Remove the acl method from all the components. Component from: const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
to const Component = () => <h1>Component</h1>

export default Component
 Remove action & subject properties if defined in your navigation files. Navigation object from: {
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
to {
  path: '/acl',
  icon: 'tabler:shield',
  title: 'Access Control'
}
 In the src/pages/index.tsx file, update Home URL like the following: // Set Home URL based on User Roles
export const getHomeRoute = () => {
  return '/dashboards/analytics'
}

// And call this function like this:
const homeRoute = getHomeRoute()
OR Empty src/pages/index.tsx file and render your Home component like following: const Component = () => <h1>Component</h1>

export default Component
 Remove the ability & ability.can function in all the CanView files in src/layouts/components/acl folder. Replace the following codes in respective files in order to remove ACL functionality.   
# GitHub Access GitHub access will give you a direct access to our template's repository on GitHub. You have to have a GitHub account in order to use this feature. Please fill form in the below link to get GitHub Access: Form Link  (opens new window)
# Demo Configs We provide a demo-configs folder with demo files of the configurations we use in our demos. You can use these files to get the configurations like our demos. All you have to do is copy the demo file content you like from the demo-configs folder and paste it into the src/configs/themeConfig.ts file. Please Note: Some of the configurations are stored in localStorage hence, you'll have to clear the application data in your browser like shown in the below image and refresh the page. 
# Loaders # Pace Loader (Page Loader) We're using nprogress  (opens new window) as the paceloader (or page loader). If you want to disable it, change the routingLoader property to false in the src/configs/themeConfig.ts file. But if you want to remove the package, follow these steps: Remove nprogress & @types/nprogress packages from the package.json file Remove the following snippet in the src/pages/_app.ts file import NProgress from 'nprogress'

// ** Pace Loader
if (themeConfig.routingLoader) {
  Router.events.on('routeChangeStart', () => {
    NProgress.start()
  })
  Router.events.on('routeChangeError', () => {
    NProgress.done()
  })
  Router.events.on('routeChangeComplete', () => {
    NProgress.done()
  })
}
# Splash Screen (Loader with Logo) If you want to keep the splash screen as it is with your logo, then follow these steps: Make a new file in the src/layouts/components folder Copy the code from the src/@core/components/spinner/index.tsx file and paste it in the file you just made Remove our SVG logo and add your logo (you can add the logo of any format viz. JPEG, PNG, SVG, etc.) Pass your component in the fallback prop with the AuthGuard and GuestGuard components in the src/pages/_app.tsx file. // src/pages/_app.tsx

import UserSpinner from 'src/layouts/components/UserSpinner.tsx'

<GuestGuard fallback={<UserSpinner />}>{children}</GuestGuard>
<AuthGuard fallback={<UserSpinner />}>{children}</AuthGuard>
If you want to change the whole splash screen, then follow these steps: Make your own loader component in the src/layouts/components folder Pass your component in the fallback prop with the AuthGuard and GuestGuard components in the src/pages/_app.tsx file. // src/pages/_app.tsx

import UserSpinner from 'src/layouts/components/UserSpinner.tsx'

<GuestGuard fallback={<UserSpinner />}>{children}</GuestGuard>
<AuthGuard fallback={<UserSpinner />}>{children}</AuthGuard>
You can also pass null instead of a loader if you don't want to show a loader in the splash screen.
# Internationalization (i18n) # Overview We're using react-i18next  (opens new window) for Internationalization. You can find its configurations in src/configs/i18n.ts file and the locales in public/locales folder in the full version. # Usage Refer to this article to implement the internationalization. # Add i18n WARNING Only for those who are using the starter-kit If you are using the full version, then you don't need to add i18n as it is already available in that version. But if you are using the starter-kit (which is recommended) and want to add i18n, then follow these steps: You need to add these npm packages:
i18next react-i18next i18next-http-backend i18next-browser-languagedetector  Copy src/configs/i18n.ts file from the full version and paste it under the same directory in your project Add import 'src/configs/i18n' import statement in src/pages/_app.tsx file Add your locale files in public/locales folder If you want to translate the navigation menu, then copy the whole code from src/layouts/components/Translations.tsx file from the full version and paste it under the same directory in your project If you want a language dropdown in the appBar to change the current language in the app, then import src/@core/layouts/components/shared-components/LanguageDropdown.tsx file and render LanguageDropdown component in src/layouts/components/vertical/AppBarContent.tsx or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
# Remove i18n WARNING Only for those who are using the full version If you do not want to use i18n, we recommend you start your project with the starter-kit. But if you are using the full version and does not want to use i18n, then follow these steps: You may remove all the packages related to i18n from package.json file if you want to
i18next react-i18next i18next-http-backend i18next-browser-languagedetector Remove src/configs/i18n.ts file Remove import 'src/configs/i18n' import statement from src/pages/_app.tsx file Replace the following code in src/layouts/components/Translations.tsx file  Remove LanguageDropdown file import statement and rendered component from src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
Remove your locale files from public/locales folder # Add / Remove a language Suppose you want to add de (German) language and remove ar (Arabic) language. For this, you need to follow these steps: Remove public/locales/ar.json file and add public/locales/de.json file. You need to keep the format of the file as it is in other locale files Make a new file in src/layouts/components folder and place the following code in this file  Import the src/layouts/components/UserLanguageDropdown.tsx file and render it in the src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file. 
# Settings Context # Overview Settings Context has been created so that the template is independent of the redux store for storing the variables used in the template. # Properties Following are the properties and their values that are stored in the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed navHidden true, false If true, the navigation menu is hidden layout vertical, horizontal Set Vertical or Horizontal layout for the template lastLayout vertical, horizontal For internal usage (used when window is resized in Horizontal layout) verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity footer fixed, static, hidden Change footer position themeColor primary, secondary, success, error, warning, info Change primary color in the template toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Default toast position of react-hot-toast # LocalStorage Following are the properties and their values that are stored in localStorage from the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBarBlur true, false If true, background of appBar will have opacity themeColor primary, secondary, success, error, warning, info Change primary color in the template # Provider and Consumer Settings context relies on the context feature of React  (opens new window) to pass the settings down to the components. Settings context exports SettingsProvider and SettingsConsumer and they must be parents of ThemeComponent in src/pages/_app.tsx file. See the following code: <SettingsProvider>
  <SettingsConsumer>
    {({ settings }) => (
      <ThemeComponent settings={settings}>{getLayout(<Component {...pageProps} />)}</ThemeComponent>
    )}
  </SettingsConsumer>
</SettingsProvider>

# Starter-kit vs Full Package # Starter-kit Starter-kit is a minimal template from where you can start your project quickly instead of removing stuff that isn't needed. Below are quick notes on the starter-kit: No i18n Simple Navbar Four pages (Two sample pages + 404 + Login) Customizer (disabled) No Axios Use it if you don't want to clutter your project with extra libs which aren't required. You still need to streamline all the dependencies from package.json file. We have taken care of cleaning up unnecessary code . You can just copy components from full version into the starter kit and it should work üòç. TIP Use starter-kit to provide reproduction steps if you raise any technical issue on GitHub. # Full Package This setup has all the things which you can see in the live demo except for that red Buy Now button üòÖ. With this, you have to remove things that you don't use or replace them with your content. # Conclusion According to us, starter-kit is easy to get started with minimal setup and our folder and code structure will help you add libs support in starter-kit more easily than ever. Still, if your project becomes easy with the full package, go for it. WARNING Please make sure to copy required images from the full version if you copy content from the full version to the starter-kit.
# Styled Components # Overview These are the styles available in the src/@core/styles folder: MUI Stepper Fullcalendar Keen Slider React Apexcharts CleaveJs React Credit Cards React Datepicker React Draft Wysiwyg React Dropzone React Hot Toast Recharts TIP If you do not want to use these styles, then render your component directly. This will apply the default styles provided by MUI and/or third-party plugins. # Usage You need to import styles as a component and wrap them around your components. Let us take an example of React Datepicker: import DatePicker from 'react-datepicker'
import DatePickerWrapper from 'src/@core/styles/libs/react-datepicker'

<DatePickerWrapper>
  <DatePicker
    {...} // all of your props
  />
</DatePickerWrapper>
If you do not want to use these styles: import DatePicker from 'react-datepicker'

<DatePicker
  {...} // all of your props
/>
TIP If you have to use any styles with multiple components like multiple CleaveJS components used in a single page, then you need to import the styles once and then wrap the index file of that page with the styled component, so that the styles are not called multiple times. # Override Styled Components Overriding these styles components is very easy. Follow these steps to override any styles: Make a new file in the src/layouts/styles folder Copy the code of that component that you want to override from the src/@core/styles folder and paste it into the new file that you just made Override the styles as per your project requirements Let us say that you want to override the styles of React Credit Cards: // src/layouts/styles/react-credit-cards/index.ts

import { styled } from '@mui/material/styles'

const CardWrapper = styled('div')(({ theme }) => ({
  display: 'flex',
  '& .rccs, & .rccs__card': {
    margin: theme.spacing(4)
  }
}))

export default CardWrapper
# React Hot Toast The styles of React Hot Toast are globally included in the src/pages/_app.tsx file, so you do not need to add a wrapper in any of your toast components. # Usage // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import ReactHotToast from 'src/@core/styles/libs/react-hot-toast'

<ReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</ReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>
# Override To override the styles, you need to follow the same steps that are explained above. Now, suppose you want to open the toasts at their default position, then: Make a new file in the src/layouts/styles folder (say src/layouts/styles/react-hot-toast/index.ts) Copy the code from the src/@core/styles/react-hot-toast/index.ts file and paste it into the src/layouts/styles/react-hot-toast/index.ts file Remove the following code: '& > div': {
  top: '75px !important',
  right: `${theme.spacing(6)} !important`
}
Import and render src/layouts/styles/react-hot-toast/index.ts file in src/pages/_app.tsx file // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import UserReactHotToast from 'src/layouts/styles/react-hot-toast'

<UserReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</UserReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>

# Environment Variables Vuexy comes with support for environment variables, which allows you to use .env to load the environment variables. Tip We recommend you to read the official guide  (opens new window) given by Next.js for using environment variables. # Loading Environment Variables Next.js has built-in support for loading environment variables from .env file into process.env. An example .env.local: DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods  (opens new window) and API routes  (opens new window). For example, using getStaticProps  (opens new window): // pages/index.js
export async function getStaticProps() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS
  })
  // ...
}
# Exposing Environment Variables to the Browser By default environment variables are only available in the Node.js environment, meaning they won't be exposed to the browser. In order to use an environment variable inside a component and to expose a variable to the browser, you have to prefix the variable with NEXT_PUBLIC_. For example: NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk
WARNING Do not store any secrets (such as private API keys or passwords) in the public variables! These environment variables are embedded into the build, meaning anyone can view them by inspecting your app's files. # Private Variables Having access to the NODE_ENV is also useful for performing actions conditionally: if (process.env.NODE_ENV !== 'production') {
  analytics.disable()
}
Read more nextjs official documentation for more info on environment variables from here  (opens new window). # Environment variables used in the template We have use the fake-db and fake-db API calls are not supported to access the environment variables. Hence, we have used NEXT_PUBLIC prefix with our environment variables. You can find the environment variables' file .env.development in the root of the project. The environment variables that we have used in the .env.development file are as follows: NEXT_PUBLIC_JWT_EXPIRATION
NEXT_PUBLIC_JWT_SECRET
NEXT_PUBLIC_JWT_REFRESH_TOKEN_SECRET
Make sure to replace JWT secrets and token with your actual values and it's advisable to remove the NEXT_PUBLIC prefix if you are using the Next.js data fetching method or API routes.
# Routing Vuexy uses Next.js's file-system based router built on the concept of pages. When a file is added to the src/pages directory, it's automatically available as a route. # Index routes The router will automatically route files named index to the root of the directory. pages/index.tsx ‚Üí / pages/dashboards/index.tsx ‚Üí /blog # Nested routes The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way. pages/dashboards/ecommerce/index.tsx ‚Üí /dashboards/ecommerce # Dynamic route segments Defining routes by using predefined paths is not always enough for complex applications. In Next.js you can add brackets to a page param to create a dynamic route (a.k.a. URL slugs, pretty URLs, and others). To match a dynamic segment you can use the bracket syntax. This allows you to match named parameters. pages/apps/email/[folder].tsx ‚Üí /apps/email/spam pages/apps/email/label/[label].tsx ‚Üí /apps/email/label/company pages/apps/email/[...all].tsx ‚Üí /apps/email/* (/apps/email/view/id/1)
# FAQs TIP If you can't find your problem. Try searching related term on stackoverflow  (opens new window) as well. I can't find my issue/problem/question listed here, What to do now? If you can't find your issue/problem/question listed here then you can raise support at our support portal. For getting your solution quickly with minimum conversation, please check out our Getting Support page which provides some tips on how to raise a perfect support ticket to get the solution quickly so our development team don't have to ask for things that take time and waste your precious development time.
# RTL # Change to RTL We provide Left to Right (LTR) by default but you can easily change it to Right to Left (RTL). To change the whole template to RTL, you need to go to the src/configs/themeConfig.ts file and change the direction property from ltr to rtl. # RTL Toggler You can also make a direction toggler which toggle between LTR and RTL directions. Look at the following code to make one:  # Get current direction You might need to render some code conditionally based on the current direction of the template. You can write the following code to do so: ¬†¬†¬†import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  if (settings.direction === 'rtl') {
    return (
      {/* Some code */}
    )
  } else {
    return (
      {/* Some other code */}
    )
  }
}

export default SomeComponent
If you need to style something conditionally based on the current direction of the template, do the following: ¬†¬†¬†import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return (
    <Box sx={{ backgroundColor: settings.direction === 'rtl' ? 'red' : 'blue' }}>
      ...
    </Box>
  )
}

export default SomeComponent
# Remove RTL from the template To remove the RTL from the whole template, follow these steps: Remove all the plugins related to RTL. View all the dependencies of RTL in this section Replace the following code in the src/layouts/components/Direction.tsx file: 
# getLayout TIP We recommend you to go through the Per page Layout Docs of NextJS  (opens new window) to understand how the layout works on any single page in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview If you want to change the default layout for a particular page, you can use the getLayout method with your component. # Blank Layout Here is an example of how to change the layout from default layout to blank layout for any page:  # Blank Layout with AppBar Here is an example of how to change the layout from default layout to blank layout with appBar for any page:  # Custom Layout Refer to the code below to create a blog layout:  Result:  # Change the default page layout Suppose, you want to change the default page layout for all the pages in your project, then follow the below steps: Make a layout as per your requirements in the src/layouts folder (let us assume that you named the file as UserDefaultLayout.tsx) Import the newly created file in the src/pages/_app.tsx file as: import UserDefaultLayout from 'src/layouts/UserDefaultLayout'
Change the getLayout variable from const getLayout = Component.getLayout ?? (page => <UserLayout contentHeightFixed={contentHeightFixed}>{page}</UserLayout>)
to const getLayout = Component.getLayout ?? (page => <UserDefaultLayout>{page}</UserDefaultLayout>)

# Theme Configurations # Overview To configure your template, we will be using the src/configs/themeConfig.ts file, which has all the template configurations listed with their valid values. Just change the configurations as per your requirement and you are done. If you are looking to match up with one of our demos, then please read demo configs doc. Important Make sure you clear the browser's local storage in order to see the config changes in the template. Refer: How to clear local storage?  (opens new window) # Properties Following are the properties with their values that we have used in the theme:  # beforeVerticalNavMenuContentPosition If the value is set to static, then the content will get scrolled along with the vertical navigation. If the value is set to fixed, then the content will not get scrolled along with the vertical navigation. # beforeVerticalNavMenuContentPosition: 'static'   # beforeVerticalNavMenuContentPosition: 'fixed'   # afterVerticalNavMenuContentPosition If the value is set to static, then the content will get scrolled along with the vertical navigation. If the value is set to fixed, then the content will not get scrolled along with the vertical navigation. # afterVerticalNavMenuContentPosition: 'static'   # afterVerticalNavMenuContentPosition: 'fixed'   # Property Options Following is the table of all the properties and their possible values that are available in the theme configurations: Properties Values Description templateName string Name of the template, project or company layout vertical, horizontal Set Vertical or Horizontal layout for the template mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction skin default, bordered Change template skin contentWidth full, boxed Full or container width of AppBar, Content and Footer footer fixed, static, hidden Change footer position routingLoader true, false Loader on top of the app on route change navHidden true, false If true, the navigation menu is hidden menuTextTruncate true, false If true, text truncate in the navigation menu is enabled navSubItemIcon string Change icon for the sub menus in the navigation menu verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu navCollapsed true, false If true, the vertical navigation menu is collapsed navigationSize number Width of navigation menu when menu is not collapsed collapsedNavigationSize number Width of navigation menu when menu is collapsed afterVerticalNavMenuContentPosition fixed, static Position of the content which is added after the vertical navigation menu beforeVerticalNavMenuContentPosition fixed, static Position of the content which is added before the vertical navigation menu horizontalMenuToggle click, hover Set behavior of menu group in the horizontal navigation menu horizontalMenuAnimation true, false If true, animation is enabled for the horizontal navigation menu appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity responsiveFontSizes true, false If true, responsive font sizes are enabled disableRipple true, false If true, the Ripple effect is disabled disableCustomizer true, false If true, customizer is disabled as right sidebar to configure in live app toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Set default toast position in the template
# Layout Content with Fixed Height # Overview You can use this layout if you want a fixed height of the content area. For example, apps like Email and Chat need a fixed height and a scrollbar should be inside these apps. Heads Up! Do not remove any code related to contentHeightFixed from the src/layouts/UserLayout.tsx file. Otherwise, the whole template would break. # Usage You need to use the contentHeightFixed method on your component to fix the height of the content area. The type accepted by this method is: contentHeightFixed?: boolean
Here is the example code: const Component = () => {
  return (
    // your content
  )
}

Component.contentHeightFixed = true

export default Component

# Page Specific Settings If you want to override specific settings for specific page only, you can do that as well. # Usage To change a setting for a specific page, use setConfig method and return an object with your settings like below: const AnalyticsDashboard = () => <h1>Analytics Dashboard</h1>

AnalyticsDashboard.setConfig = () => {
  return {
    mode: 'dark'
    ...
  }
}

export default AnalyticsDashboard
Note You can override any config property at page level. Please refer Theme Configurations doc for each configurable property. Important It is not advisable to override layout or rtl  property for a specific page, they should be set only globally. Overriding them at page level will throw a memory leak error.
# Installation Vuexy is built using Create Next App  (opens new window). Create Next App sets up everything automatically for you. # Guide First of all make sure you have installed Node  (opens new window) and npm  (opens new window) / yarn  (opens new window) TIP Yarn package manager is recommended Requirements Please make sure you use the node‚Äôs LTS version which is recommended by the official node site and not the one with the latest features or previous versions. Our project is not tested to work with other Node versions. Important! Before installing the node_modules, make sure you have files starting with a dot(.eslintrc, .env etc..). It mostly happens when hidden files are not enabled on your machine and you try to copy our template at some other place on your system. After downloading zip, copy this zip to your desired location and then unzip it. Do not unzip first and then copy files to another location, it may not be able to run the template due to missing hidden files not copied over. In the uncompressed folder, you will find the typescript-version and javascript-version folders which contains the full-version & starter-kit folders. Open the one you want to get started with in your code editor. Run below command in console:  After installing the modules run your project with following command:  You will find following output after running above command in console:  Congratulations!! You have successfully run the project. Visit http://localhost:3000/  (opens new window) to check it in your browser. NOTE Your network URL might not have same URL as screenshot and that is completely fine. It depends on your network.
# Getting Started TIP Get Started with the Starter kit version and copy components from full version We only provide documentation for custom components and customizations made to MUI's components. For MUI components' documentation please visit MUI's official docs  (opens new window). Heads Up! When using Javascript version, please consider respective file paths, we only show ts & tsx file paths for reference code in documentation. e.g. Following is the file path in TypeScript version: src/layouts/UserLayout.tsx and consider looking at following path in JavaScript version: src/layouts/UserLayout.js There can be two possibilities, you are planning to start a new project with our template or trying to add our template into your existing project. # Starting a new project with our template It is always suggested to get started with the minimal setup and we exactly provide that with our starter kit version. Once you unzip the template you will find TypeScript / JavaScript version folder and under that full-version and starter-kit folders. First step should be to verify all the dependencies and clean up all the packages that are not required for your project. # What's the point including all the dependencies with starter kit? Your question is totally valid and legit. To make the experience smoother, we have listed all the dependencies and provided freedom to remove dependencies which are not required in your project. Searching for packages that are required and to install them can be difficult and confusing for new users. Hence, we have included all the packages in the starter-kit. New user can just copy components from full version without worring about packages. # Integrating our template into your existing project Since this is a template and a starter project, it‚Äôs built as the starting point of your project. It cannot be simply installed and used with an existing project like a third party library. Although using our template with any existing project is still possible, it would require extra work to connect everything together. We strongly recommend you to either start your project with Vuexy, or move your project on top of it to have the best experience. # Follow Installation Guide Next, Follow the installation guide once you streamline all the dependencies and make sure you meet all the system requirements mentioned in the installation page to run the project and read all the notices carefully given on the installation page. # Demo Configs You want your local template to look like one of the 6 demos you saw online then please follow demo configs documentation which will help you achieve your goal. # FAQs If you face any difficulties with installation, or has any question on usage of this template like changing colors, fonts, branding etc., then treat yourself by visiting FAQs section. You are most likely to find your answer there. # Search Docs Our template has large documentation and sometime it can be daunting to find what you are looking for in the docs. Fastest way to find anything is to search doc using search input in the Navigation bar. You can write keywords and it will filter out results and come up with the best possible match.
# Articles new How to remove Fake DB and use Real API How to add Calendar app in starter-kit How to add Search in starter-kit How to add MUI localization How to add i18n Routing How to use i18n in a page How to replace API endpoints Why have we not used getServerSideProps method How to create pages accessible to signed-in and signed-out users How to migrate from JWT Auth to NextAuth NextAuth with CredentialsProvider NextAuth with Google Provider and Prisma Adapter
Components Overview In this section, we have explained only the custom components, that are made by our team from scratch and MUI components that are extended to increase its usability. We have not explained all other MUI component that are not extended by our team. Users need to visit MUI components in order to understand how they work. This section contains the following: extended components of MUI custom components that we have made for you to make your code smaller, simpler and easier to use how to override these components styled components - we have styled some MUI components and third-party plugins to make them cohesive with the template. The usage and how to override the styled components are explained here.
# useSettings Hook # Overview useSettings hook is created to get the values from the Settings context and set the values to the Settings context. useSettings hook must be used inside a functional component. The values that are accessible in the useSettings hook is mentioned in the Settings Context. # Read values from Settings Context Below is the example of how to get template skin. You can get any other values by replacing skin with any other property that is available in the Settings Context. import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return <Box sx={{ boxShadow: theme => theme.shadows[settings.skin === 'bordered' ? 0 : 7] }}>...</Box>
}

export default SomeComponent
# Update single value in Settings Context Below is the example of how to change template mode, i.e. Light or Dark mode. You can change any other values by replacing mode with any other property that is available in the Settings Context.  # Update multiple values in Settings Context Below is the example of how to change content width (i.e. Full or Container width) and template layout (i.e. Vertical or Horizontal layout). You can change any other values that are available in the Settings Context. 
# VSCode Configurations If a user is using VSCode editor, then the user should not have any issues related to any extensions and plugins that we provide in the downloadable package. We provide .vscode folder in the root directory of the downloadable package. In this folder, we provide all the extensions and settings that are necessary for your project to run smoothly. The user need to install all the recommended extensions that are suggested by the VSCode editor. After all the installations are done, reload or close & reopen your VSCode editor.
# Deployment TIP Read official Next.js docs  (opens new window) to handle deployment smoothly. # Node.js Server Next.js can be deployed to any hosting provider that supports Node.js. Make sure your package.json has the build and start scripts: "scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start"
}
next build builds the production application in the .next folder. After building, next start starts a Node.js server that supports hybrid pages, serving both statically generated and server-side rendered pages. # Static HTML Export Command next export allows you to export your app to static HTML, which can be run standalone without the need of a Node.js server. The exported app supports almost every feature of Next.js, including dynamic routes, prefetching, preloading and dynamic imports. next export works by pre-rendering all pages to HTML. For dynamic routes, your page can export a getStaticPaths function to let the exporter know which HTML pages to generate for that route. By default, next export will generate an out directory, which can be served by any static hosting service or CDN. The choice of your server software isn‚Äôt important either. Since the output of the export command is completely platform-agnostic, there‚Äôs no need to explicitly use Node. WARNING We are using img element instead of nextjs/Image  (opens new window). If you're using nextjs/Image instead of img element then you'll get image optimization error with static HTML export. You'll need a loader to fix this. Read this doc  (opens new window) for more info. # Vercel Deployment Read the this documentation  (opens new window) to deploy your app to vercel. Heads Up! If you are going to deploy your project under a subfolder, please read this FAQ before generating build or exporting your project.
# Dependencies # Common Heads Up! The following dependencies are common and required to run the template. Do not try to remove any of these dependencies. You may add / update / remove any other dependencies according to your requirements. "@casl/ability"
"@casl/react"
"@emotion/cache"
"@emotion/react"
"@emotion/server"
"@emotion/styled"
"@iconify/react"
"@iconify/iconify"
"@iconify/json"
"@iconify/tools"
"@iconify/types"
"@iconify/utils"
"@mui/lab"
"@mui/material"
"@popperjs/core"
"react-popper"
"clsx"
"next"
"react"
"@types/react" // Typescript version only
"react-dom"
"react-perfect-scrollbar"
"@types/node" // Typescript version only
"prettier"
"typescript" // Typescript version only
# Authentication "jsonwebtoken"
"@types/jsonwebtoken" // Typescript version only
# Calendar "@fullcalendar/bootstrap5"
"@fullcalendar/common"
"@fullcalendar/core"
"@fullcalendar/daygrid"
"@fullcalendar/interaction"
"@fullcalendar/list"
"@fullcalendar/react"
"@fullcalendar/timegrid"
"bootstrap-icons"
# Form Validation "react-hook-form"
"@hookform/resolvers"
"yup"
# Internationalization (i18n) "i18next"
"i18next-browser-languagedetector"
"i18next-http-backend"
"react-i18next"
# Charts // Apexcharts
"apexcharts-clevision"
"react-apexcharts"

// Recharts
"recharts"

// ChartJs
"chart.js"
"react-chartjs-2"
# Redux "@reduxjs/toolkit"
"react-redux"
"@types/react-redux" // Typescript version only
# Editor "react-draft-wysiwyg"
"@types/react-draft-wysiwyg" // Typescript version only
"draft-js"
"@types/draft-js" // Typescript version only
# Right to Left (RTL) "stylis"
"stylis-plugin-rtl"
# Copy to Clipboard "clipboard-copy"
# Upload "react-dropzone"
# API Call "axios"
"axios-mock-adapter"
# Data Grid "@mui/x-data-grid"
# Input Formatter "cleave.js"
"@types/cleave.js" // Typescript version only
# Page loader "nprogress"
"@types/nprogress" // Typescript version only
# Markdown "prismjs"
"@types/prismjs" // Typescript version only
# Toast "react-hot-toast"
# PDF Generator "html2canvas"
"jsPDF"
# Date Time Picker "react-datepicker"
"@types/react-datepicker" // Typescript version only
"date-fns" // date formatter
# Payment "payment"
"@types/payment" // Typescript version only
"react-credit-cards"
"@types/react-credit-cards" // Typescript version only
# Swiper "keen-slider"
# Eslint "@typescript-eslint/eslint-plugin" // Typescript version only
"@typescript-eslint/parser" // Typescript version only
"eslint"
"eslint-config-next"
"eslint-config-prettier"
"eslint-import-resolver-alias"
"eslint-import-resolver-typescript" // Typescript version only
"eslint-plugin-import"

# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
Based on MUI & Next.js With MUI & Next.js you can build responsive, mobile-first, and ARIA accessible projects on the web. Hooks Support Hooks are functions that let you ‚Äúhook into‚Äù React state and lifecycle features from function components. JWT Auth & Auth Guards Vuexy Admin provides extendable JWT auth which can be configured easily and provides ready to use Auth Guards. üì£ Heads up You are viewing Next.js + Material UI documentation of Vuexy admin template. For Vite + Reactstrap documentation, please visit this  (opens new window) page. üì£ Please follow below steps if you have cloned/forked the repository We have renamed the branches in our vuexy repo. So please make sure to update your local clone/fork by following below steps: First of all, let‚Äôs rename main branch to cra by git branch -m main cra Now, Rename nextjs to main by git branch -m nextjs main Run git fetch origin Set main branch upstream via git branch -u origin/main main Set cra branch upstream via git branch -u origin/cra cra Finally, run git remote set-head origin -a && git fetch --prune
# Override Components You can override any components explained above in MUI and Custom sections. Let us assume that you want to override the Page Header component. You need to make a new file in the src/layouts/components folder. Copy the code from the src/@core/components/page-header/index.tsx file and paste it into the new file you just made. And then, you just need to write the component however you want.  // using `src/layouts/components/page-header` component in any of your pages

import UserPageHeader from 'src/layouts/components/page-header'

<UserPageHeader title='React ApexCharts' subtitle='React Component for ApexCharts' />

# FakeDB Vuexy is built using FakeDB to mock the real life application functionalities. # Overview Vuexy uses axios-mock-adapter  (opens new window) to simulate the server calls. All of the server calls are located in src/@fake-db. # Setup If you're using the starter-kit you'll have to manually setup the fake-db. First create a folder with name fake-db and create a mock.ts file inside it. Initialize the axios-mock-adapter in mock.ts file. import axios from 'axios'
import MockAdapter from 'axios-mock-adapter'

const mock = new MockAdapter(axios)

export default mock
 Create a index.ts file in fake-db folder & add the following: import mock from './mock'

mock.onAny().passThrough()
 To initialize your fake data create a ts file in fake-db folder. Import mock and use it like following: import mock from '../mock'

const data = [{...}]

mock.onGet('/url/get-data').reply(config => {
  return [200, data]
})
 Import the above created file in fake-db/index.ts: import mock from './mock'

import './FILE_WITH_DATA'

mock.onAny().passThrough()
 Import your fake-db/index.ts in src/pages/_app_.ts to be able to get your data in your app. Finally, use axios to fetch your data from fake-db import { useState, useEffect } from 'react'

import axios from 'axios'

const Component = () => {
  const [data, setData] = useState([])

  useEffect(() => {
    axios.get('/url/get-data').then(response => setData(response.data))
  }, [])

  return <h1>Component</h1>
}
WARNING We have used the fake-db for demo purposes only. fake-db will not work for the real life applications.
# Icons # Overview We have used Material Design Icons from the Iconify library in the whole template. You may visit the site here  (opens new window) and check all the icons here  (opens new window). Users are free to use any icon library of their choice. WARNING We are using the offline icons with the help of Iconify bundle and we suggest you do the same. If you want to use very few icons from other libraries, then you may use online icons directly from the public API of Iconify. Heads Up! The src/iconify-bundle/tsconfig.json file is different from the tsconfig.json file and thus do not delete the src/iconify-bundle/tsconfig.json file from your project; otherwise, you will not be able to generate icon bundle from the yarn build:icons command. Heads Up! While using the Tabler icons, fill and stroke related props (like fill, fillOpacity, stroke, strokeWidth, strokeOpacity, etc.) will not work with the Icon component as the <svg> tag doesn't have those attributes. If anyone wants to add such styling, then they may add them using the style prop or use MUI's Box component and use the sx props with it. # Iconify Bundle When Iconify icon component renders an icon, if icon data is not available, the component attempts to load data for an icon from Iconify API. Even though loading icon data from API is very fast, it is not instant and it requires internet access. By providing icon data for most used icons, you guarantee that icon data is ready when a component needs it, rendering icons instantly. This also allows rendering icons when internet access is not available and you are no longer relying on third-party service. The following files are necessary to generate Iconify bundle: src/iconify-bundle/bundle-icons-react.d.ts (typescript version only) src/iconify-bundle/bundle-icons-react.js src/iconify-bundle/bundle-icons-react.ts (typescript version only) src/iconify-bundle/icons-bundle-react.js src/iconify-bundle/tsconfig.json package.json # How to Generate Bundle? You can generate the bundle with a wide variety of emojis, flags, brand logos, SVGs & icons and use them even when internet access is not available. To generate such icons, you just need to add your desired icon library, any specific icon(s), a custom JSON file created by you, custom SVG(s) created by you or any emoji(s). # Generate all icons from an icon library To add all the icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from an icon library To add some icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from different libraries To add some icons from different libraries provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from a custom JSON file To add some icons from a custom JSON file, you need to follow the file format according to this  (opens new window) and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom SVG files To add some icons from some custom SVG files, you need to create some SVG files in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom Emojis To add some icons from some custom emojis, you need to create some emojis in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Target & Import Once you have added all the icons that are necessary for your project, you need to set the file path in which the whole icon bundle gets generated. Search for the term const target = in the src/iconify-bundle/bundle-icons-react.ts or src/iconify-bundle/bundle-icons-react.js file and set a file path which is suitable for your project. Once the file path is set, you need to update that file path in the src/pages/_app.tsx or src/pages/_app.js file as well. Once the import statement is updated in the src/pages/_app.tsx or src/pages/_app.js file, you can use Iconify React Component anywhere in the template. We have set the value of target as: const target = 'src/iconify-bundle/icons-bundle-react.js'
and the import statement as: import 'src/iconify-bundle/icons-bundle-react'
# Run the command Once you have set the target and updated the import statement, then you need to run the following command in the root (where your package.json file exists):  # How is the bundle generated? # TypeScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.ts file is compiled to the src/iconify-bundle/bundle-icons-react.js file. Once the compilation is completed, the compiled file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.tsx file. # JavaScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.js file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.js file. # Usage # Props You may visit this docs  (opens new window) provided by Iconify to refer to all the props of the Iconify React Component. # How to use Iconify React Component? Import the Iconify React Component as given below: import Icon from 'src/@core/components/icon'
If you want the default font-size of the Iconify React Component as 16px, you need to import the following component: import { Icon } from '@iconify/react'
Here is an example: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='tabler:home' />
}

export default Component
In the example given above, tabler is Tabler Icons (icon library provided by Iconify) and home is an icon which is in the tabler icon library. # Use some different icon library Suppose you want to use the Font Awesome Solid icon library. Please follow these instructions to add the icons from the Font Awesome Solid icon library. Here is an example to use an icon from the Font Awesome Solid icon library: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='fa6-solid:bicycle' />
}

export default Component
In the example given above, fa6-solid is Font Awesome Solid icon library and bicycle is an icon which is in the fa6-solid icon library. # Style an icon using MUI component Here is an example to change the color of an icon using an MUI component: import Box from '@mui/material/Box'
import Icon from 'src/@core/components/icon'

const Component = () => {
  return (
    <Box sx={{ display: 'flex', color: theme => theme.palette.primary.main }}>
      <Icon icon='tabler:home' />
    </Box>
  )
}

export default Component
# Use icon from Iconify public API By default, Iconify icon components use Iconify public API. Iconify icon components also cache loaded icons in the browser cache and/or browser storage, so icon data needs to be loaded only once. You need internet access to load the icons from the Iconify public API for the first time. Otherwise, the icon will not be rendered on your page and a console error will come. To render the icons from the Iconify public API, you must not include those icons in the Iconify bundle.
# Credits Name URL License @casl/ability https://github.com/stalniy/casl  (opens new window) MIT @casl/react https://github.com/stalniy/casl  (opens new window) MIT @emotion/cache https://github.com/emotion-js/emotion/tree/main/packages/cache  (opens new window) MIT @emotion/react https://github.com/emotion-js/emotion/tree/main/packages/react  (opens new window) MIT @emotion/server https://github.com/emotion-js/emotion/tree/main/packages/server  (opens new window) MIT @emotion/styled https://github.com/emotion-js/emotion/tree/main/packages/styled  (opens new window) MIT @fullcalendar/bootstrap5 https://github.com/fullcalendar/fullcalendar  (opens new window) MIT @fullcalendar/common https://github.com/fullcalendar/fullcalendar  (opens new window) MIT @fullcalendar/core https://github.com/fullcalendar/fullcalendar  (opens new window) MIT @fullcalendar/daygrid https://github.com/fullcalendar/fullcalendar  (opens new window) MIT @fullcalendar/interaction https://github.com/fullcalendar/fullcalendar  (opens new window) MIT @fullcalendar/list https://github.com/fullcalendar/fullcalendar  (opens new window) MIT @fullcalendar/react https://github.com/fullcalendar/fullcalendar  (opens new window) MIT @fullcalendar/timegrid https://github.com/fullcalendar/fullcalendar  (opens new window) MIT @hookform/resolvers https://github.com/react-hook-form/resolvers  (opens new window) MIT @iconify/react https://github.com/iconify/iconify  (opens new window) MIT @mui/lab https://github.com/mui-org/material-ui  (opens new window) MIT @mui/material https://github.com/mui-org/material-ui  (opens new window) MIT @mui/x-data-grid https://github.com/mui-org/material-ui-x  (opens new window) MIT @reduxjs/toolkit https://github.com/reduxjs/redux-toolkit  (opens new window) MIT apexcharts https://github.com/apexcharts/apexcharts.js  (opens new window) MIT axios https://github.com/axios/axios  (opens new window) MIT axios-mock-adapter https://github.com/ctimmerm/axios-mock-adapter  (opens new window) MIT bootstrap-icons https://github.com/twbs/icons  (opens new window) MIT chart.js https://github.com/chartjs/Chart.js  (opens new window) MIT cleave.js https://github.com/nosir/cleave.js  (opens new window) MIT clipboard-copy https://github.com/feross/clipboard-copy  (opens new window) MIT clsx https://github.com/lukeed/clsx  (opens new window) MIT date-fns https://github.com/date-fns/date-fns  (opens new window) MIT draft-js https://github.com/facebook/draft-js  (opens new window) MIT i18next https://github.com/i18next/i18next  (opens new window) MIT i18next-browser-languagedetector https://github.com/i18next/i18next-browser-languageDetector  (opens new window) MIT i18next-http-backend https://github.com/i18next/i18next-http-backend  (opens new window) MIT jsonwebtoken https://github.com/auth0/node-jsonwebtoken  (opens new window) MIT keen-slider https://github.com/rcbyr/keen-slider  (opens new window) MIT next https://github.com/vercel/next.js  (opens new window) MIT nprogress https://github.com/rstacruz/nprogress  (opens new window) MIT payment https://github.com/jessepollak/payment  (opens new window) MIT prismjs https://github.com/PrismJS/prism  (opens new window) MIT react https://github.com/facebook/react  (opens new window) MIT react-apexcharts https://github.com/apexcharts/react-apexcharts  (opens new window) MIT react-chartjs-2 https://github.com/reactchartjs/react-chartjs-2  (opens new window) MIT react-credit-cards https://github.com/amaroteam/react-credit-cards  (opens new window) MIT react-datepicker https://github.com/Hacker0x01/react-datepicker  (opens new window) MIT react-dom https://github.com/facebook/react  (opens new window) MIT react-draft-wysiwyg https://github.com/jpuri/react-draft-wysiwyg  (opens new window) MIT react-dropzone https://github.com/react-dropzone/react-dropzone  (opens new window) MIT react-hook-form https://github.com/react-hook-form/react-hook-form  (opens new window) MIT react-hot-toast https://github.com/timolins/react-hot-toast  (opens new window) MIT react-i18next https://github.com/i18next/react-i18next  (opens new window) MIT react-perfect-scrollbar https://github.com/goldenyz/react-perfect-scrollbar  (opens new window) MIT react-redux https://github.com/reduxjs/react-redux  (opens new window) MIT recharts https://github.com/recharts/recharts  (opens new window) MIT stylis https://github.com/thysultan/stylis.js  (opens new window) MIT stylis-plugin-rtl https://github.com/styled-components/stylis-plugin-rtl  (opens new window) MIT typescript https://github.com/microsoft/TypeScript  (opens new window) Apache-2.0 yup https://github.com/jquense/yup  (opens new window) MIT # Images & Illustrations Name URL Wannathis https://wannathis.one/products/humans-3d-characters  (opens new window) Freepik https://www.freepik.com/  (opens new window) Unsplash https://unsplash.com/  (opens new window)
# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Theming # Overview Theming is the most important aspect of any template. You can easily customize theme of our template. You can change the colors, the typography, the spacing and much more. MUI offers a utility function: createTheme() that creates a theme which can be passed to the theme provider; otherwise the theme provider uses the default theme. The theme provider makes the theme available in the component tree, and can be used via the sx prop, or inside styled components using the MUI styled engine (styled). Important Make your changes in src/layouts/UserThemeOptions.ts file in order to override colors, typography, spacing or any other component styling. Do not make any changes related to theme inside of @core folder unless suggested by our support team. Consider reading MUI theming docs  (opens new window) to understand how it works and how to access and override theme. How to override Color Palette How to customize MUI component appearance How to override Typography How to override Shadows How to override Breakpoints How to override components styling # How to override Color Palette # How to Change Colors In order to change primary color, open src/layouts/UserThemeOptions.ts file and uncomment the palette object returned from that file. palette:{
  primary: {
    light: '#8479F2',
    main: '#7367F0',
    dark: '#655BD3',
    contrastText: '#FFF'
  },
  secondary: {
    ...
  },
  success: {
    ...
  },
  error: {
    ...
  },
  warning: {
    ...
  },
  info: {
    ...
  }
}
Colors given in the above palette object are current primary colors used in our template, update those colors according to your project requirements. Above example shows how to change primary colors. You can change any colors of the palette in the same way shown above. Please refer how to customize MUI palette documentation  (opens new window). Also refer our core palette from the file src/@core/theme/palette/index.ts in order to check custom colors, dark / light colors etc.. for better idea. # Colors Tool Eva color tool https://colors.eva.design/  (opens new window) We recommend picking colors with these values: light : 400 main : 500 dark : 600 contrastText: '#FFF'  # How to customize MUI component appearance You can easily customize the appearance of any component, but it is important to understand how to customize it right way which will save the time, resources and provide optimum performance. Please read MUI doc on how to customize component appearance  (opens new window) to get clear idea. # How to override Typography # How to change font We have used Public Sans fonts  (opens new window) in the whole template. Now suppose you want to implement Montserrat fonts  (opens new window). First open src/pages/_document.tsx file and change font's URL like following: <Head>
  ...
  <link
    rel='stylesheet'
    href='https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap'
  />
  ...
</Head>
Now, open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: typography: {
  fontFamily:
    '"Montserrat", sans-serif'
}
# Use multiple fonts typography: {
  fontFamily:
    '"Public Sans", sans-serif',
  h1: {
    fontFamily:
    '"Montserrat", sans-serif',
    fontWeight: 700,
    fontSize: '3.5rem',
    lineHeight: 1.375
  },
}
Reference: https://demos.pixinvent.com/vuexy-nextjs-admin-template/demo-1/ui/typography  (opens new window) MUI: https://mui.com/material-ui/customization/typography/  (opens new window) # How to override Shadows If you want to customize shadows, uncomment following from the src/layouts/UserThemeOptions.ts file and change shadows  according to your project requirement. Make sure to enable mode from the settings which are already commented at the starting of this file if you are using dark / light both the versions. If you are using either of them, just override shadows without any conditions. // Uncomment this if using light & dark both
const { mode } = settings
// conditional shadows for both dark / light
shadows: mode === 'light' ? [...] : [...]

// Only shadows if using only one from light / dark
shadows: [...]
# How to override Breakpoints If you want to customize breakpoints, uncomment following from the src/layouts/UserThemeOptions.ts file and change breakpoints size according to your project requirement. breakpoints: {
  values: {
    xs: 0,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
}
Reference: https://mui.com/material-ui/customization/breakpoints/  (opens new window) # How to override components styling The theme's components key allows you to customize a component without wrapping it in another component. You can change the styles, the default props, and more. Open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: components: {
  MuiButton: {
    defaultProps: {
      disableElevation: true
    },
    ...
  },
  ...
}
Reference: https://mui.com/material-ui/customization/theme-components/  (opens new window)
# Folder Structure Heads Up Do not make any changes in the src/@core folder unless suggested by our support team. It is the core functionality of the template which is responsible to run the template and will be updated with every new update. Use src/layouts folder to override core layouts and components. Understand folder structure of the template and what every folder contains. # Overview Before checking folder structure it is better you know some stuff related to folder structure. src/@core folder contains core files of template which shall not get modified unless our support team guide you to do it. Outside of src/@core folder are files you can move and modify as per your wish. Basically that is your playground where you can modify anything. src/@fake-db folder just contains dummy data which we get in response of API call. This enables us to take step forward in providing API ready template. src/layouts folder outside of src/@core are your layouts which you can modify however you like. Template will always render these layouts. # Main Package Following is the folder structure of the full-version under both typescript / javascript version. Not explaining the folder structure for starter kit as everything is covered in the full version. ‚îú‚îÄ‚îÄ public
‚îÇ   ‚îú‚îÄ‚îÄ images                   -> Static assets
‚îÇ   ‚îú‚îÄ‚îÄ locales                  -> Translations
‚îÇ   ‚îî‚îÄ‚îÄ other files
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ @core                    -> Template's core files
‚îÇ   ‚îú‚îÄ‚îÄ @fake-db                 -> Fake Database for mocking axios requests (Fake API Calls)
‚îÇ   ‚îú‚îÄ‚îÄ configs                  -> Configuration files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ acl.ts               -> Your Access Control file/configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts              -> Your authentication file/configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ i18n.ts              -> i18n configurations and initialization
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ themeConfig.ts       -> Template configurations
‚îÇ   ‚îú‚îÄ‚îÄ context                  -> Your context files go here
‚îÇ   ‚îú‚îÄ‚îÄ hooks                    -> Your hooks go here
‚îÇ   ‚îú‚îÄ‚îÄ layouts                  -> Your layouts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components           -> Your components, layout components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserLayout.tsx       -> File responsible to render layout & template
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserThemeOptions.ts  -> Your theming file to override core theming
‚îÇ   ‚îú‚îÄ‚îÄ navigation               -> Vertical & Horizontal static navigation menu files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ horizontal
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vertical
‚îÇ   ‚îú‚îÄ‚îÄ pages                    -> View files that render all the pages
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _app.tsx             -> Main file responsible to render layout
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _document.tsx        -> HTML document & emotions configurations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx            -> Application entry file
‚îÇ   ‚îú‚îÄ‚îÄ store                    -> Redux store
‚îÇ   ‚îú‚îÄ‚îÄ types                    -> All types (only in the typescript version)
‚îÇ   ‚îî‚îÄ‚îÄ views                    -> View files that are included in pages folder
‚îú‚îÄ‚îÄ styles                       -> Global styling
‚îú‚îÄ‚îÄ .env                         -> Environment file
‚îú‚îÄ‚îÄ .eslintrc.json               -> ESLint configurations (Linting code)
‚îú‚îÄ‚îÄ .gitignore                   -> gitignore (ignore files and folder to sync with repo)
‚îú‚îÄ‚îÄ .npmrc                       -> Node configuration file
‚îú‚îÄ‚îÄ .nvmrc                       -> nvm configuration file
‚îú‚îÄ‚îÄ .prettierrc.js               -> Prettier configurations (editor code formatting)
‚îú‚îÄ‚îÄ next.config.js               -> Next js configurations
‚îú‚îÄ‚îÄ next.d.ts                    -> Next js global types configurations
‚îú‚îÄ‚îÄ package.json                 -> All the dependencies require to run the template
‚îú‚îÄ‚îÄ tsconfig.json               -> TypeScript configurations
# @core folder src/@core folder is the core of our template which contains core layouts, components and theming where you should not make any change but override them with the help of our layout docs in case of any changes required in core files. src/@core folder isn't meant to get modified. When you will update our template replacing this src/@core folder will hopefully update the template with minimum changes. It's a good idea to have a look at it and know what it contains to use stuff we already invented so you don't have to reinvent the wheel. # Understanding Core folder Understanding the src/@core folder will save your development time and you will know how to get most out of our template. Folder Description components It contains core components of the template. Make sure to check them all in our custom components section context Settings context which is responsible for live template customization hooks useSettings is used to access settings context values, useBgColor is used to get different colors and useClipboard is used to copy some texts layouts All the layouts and layout components like menu, appBar and footer reside in this folder for any user to override from the @core folder styles MUI's stepper styled component and all the third party styled components reside in this folder theme All the MUI theming like palette, breakpoints, typography, component's styling etc. are done in this folder utils All the helpful functions used in whole template. Users can also import and use these useful functions.
# Getting Support In this page you will find how to get support and how to raise perfect support ticket to resolve your issues quickly with minimum conversation. We value your time üïù # Raising Support Ticket Raising support ticket in support portal is as simple as commenting on post. However, If you want to get your issues resolved quickly please follow below guide: # Finding existing solution There might be a case that your issue is already resolved and you are the one who is facing due to some issue. So before creating new support ticket please search your question / issue in our FAQ page where we have listed most common questions / issues asked in our support portal. # Ticket Type Add ticket type to your ticket title to let community understand what your ticket is about. This also helps to find related tickets using ticket type. So, your ticket till will be like [question] how to change theme? Some common ticket types are listed below: question - If you are asking question installation - If you have anything related to installation auth - If you have anything related to JWT or Auth acl - If you have anything related to Access Control feat-req - If you have any feature request for our template bug - If you find any bug in template other - if your ticket isn't related to above mentioned ticket types Good examples can be: üíØ [question] How to change theme? [question] How to change i18n locale? [installation] Getting errors in npm run dev [auth] Unexpected behavior after login [other] Collapse component is not working as expected [auth] I get redirected to login page even after login on refresh # New Issue - New ticket Always consider creating a new support ticket for the question or issue you might have that is not related to your currently open ticket. Let's say you opened ticket for installation issue and want to ask about some component usage then it will be better to close installation ticket and open another ticket for that component to make support portal more accurate and easy find place. # Template Version Mentioning which version of our template you are using will help us to answer more accurately and will mitigate one question from our side. Mentioning template version includes if you are using TypeScript or JavaScript, Full-Version or Starter-Kit. Also, if you are using some other technology with our template then mentioning it will also help us in resolving issue quickly. Good examples can be: üíØ TypeScript + Full Version Javascript + Starter Kit # Sharing Code or Snippet If you want to show us some code it will be better if you can format it properly and use code block so your pasted code get highlighted. # Reproducing Issue/Bug - Starter-kit If you have ticket where we need to have a look at your code like some component's certain feature is working in our live demo but not in your downloaded package then it will better you give us actual issue or reproduction steps. Best solution for this is using our Starter-kit where we can test it without any dependency. This will also help you to clear your issue before sending it to us. You can create zip and share with us using private link. WARNING Never upload our package or modified version of our package on public sites where others can view or download it. # Support Portal Once you have purchased our template, You can get support at our support portal  (opens new window) by raising support ticket. Please make sure to follow standards defined in Raising Support Ticket section. Don't want to waste time? Creating perfect support ticket (Following our Guide) will increase the chances of getting issue resolved with minimum conversation and time. # Framework Support To get support for framework related question, raise issue at their Github  (opens new window) repo. Good candidates for framework support are: How to use x component (x means any MUI Component) x component not working as expected # Third Party Package Support Same as framework support, if you have any query regarding how to use any provided package other than their UI you can ask it in their respective Github repo issue section.
# Folder Structure Heads Up Do not make any changes in the src/@core folder unless suggested by our support team. It is the core functionality of the template which is responsible to run the template and will be updated with every new update. Use src/layouts folder to override core layouts and components. Understand folder structure of the template and what every folder contains. # Overview Before checking folder structure it is better you know some stuff related to folder structure. src/@core folder contains core files of template which shall not get modified unless our support team guide you to do it. Outside of src/@core folder are files you can move and modify as per your wish. Basically that is your playground where you can modify anything. src/@fake-db folder just contains dummy data which we get in response of API call. This enables us to take step forward in providing API ready template. src/layouts folder outside of src/@core are your layouts which you can modify however you like. Template will always render these layouts. # Main Package Following is the folder structure of the full-version under both typescript / javascript version. Not explaining the folder structure for starter kit as everything is covered in the full version. ‚îú‚îÄ‚îÄ public
‚îÇ   ‚îú‚îÄ‚îÄ images                   -> Static assets
‚îÇ   ‚îú‚îÄ‚îÄ locales                  -> Translations
‚îÇ   ‚îî‚îÄ‚îÄ other files
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ @core                    -> Template's core files
‚îÇ   ‚îú‚îÄ‚îÄ @fake-db                 -> Fake Database for mocking axios requests (Fake API Calls)
‚îÇ   ‚îú‚îÄ‚îÄ configs                  -> Configuration files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ acl.ts               -> Your Access Control file/configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts              -> Your authentication file/configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ i18n.ts              -> i18n configurations and initialization
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ themeConfig.ts       -> Template configurations
‚îÇ   ‚îú‚îÄ‚îÄ context                  -> Your context files go here
‚îÇ   ‚îú‚îÄ‚îÄ hooks                    -> Your hooks go here
‚îÇ   ‚îú‚îÄ‚îÄ layouts                  -> Your layouts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components           -> Your components, layout components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserLayout.tsx       -> File responsible to render layout & template
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserThemeOptions.ts  -> Your theming file to override core theming
‚îÇ   ‚îú‚îÄ‚îÄ navigation               -> Vertical & Horizontal static navigation menu files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ horizontal
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vertical
‚îÇ   ‚îú‚îÄ‚îÄ pages                    -> View files that render all the pages
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _app.tsx             -> Main file responsible to render layout
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _document.tsx        -> HTML document & emotions configurations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx            -> Application entry file
‚îÇ   ‚îú‚îÄ‚îÄ store                    -> Redux store
‚îÇ   ‚îú‚îÄ‚îÄ types                    -> All types (only in the typescript version)
‚îÇ   ‚îî‚îÄ‚îÄ views                    -> View files that are included in pages folder
‚îú‚îÄ‚îÄ styles                       -> Global styling
‚îú‚îÄ‚îÄ .env                         -> Environment file
‚îú‚îÄ‚îÄ .eslintrc.json               -> ESLint configurations (Linting code)
‚îú‚îÄ‚îÄ .gitignore                   -> gitignore (ignore files and folder to sync with repo)
‚îú‚îÄ‚îÄ .npmrc                       -> Node configuration file
‚îú‚îÄ‚îÄ .nvmrc                       -> nvm configuration file
‚îú‚îÄ‚îÄ .prettierrc.js               -> Prettier configurations (editor code formatting)
‚îú‚îÄ‚îÄ next.config.js               -> Next js configurations
‚îú‚îÄ‚îÄ next.d.ts                    -> Next js global types configurations
‚îú‚îÄ‚îÄ package.json                 -> All the dependencies require to run the template
‚îú‚îÄ‚îÄ tsconfig.json               -> TypeScript configurations
# @core folder src/@core folder is the core of our template which contains core layouts, components and theming where you should not make any change but override them with the help of our layout docs in case of any changes required in core files. src/@core folder isn't meant to get modified. When you will update our template replacing this src/@core folder will hopefully update the template with minimum changes. It's a good idea to have a look at it and know what it contains to use stuff we already invented so you don't have to reinvent the wheel. # Understanding Core folder Understanding the src/@core folder will save your development time and you will know how to get most out of our template. Folder Description components It contains core components of the template. Make sure to check them all in our custom components section context Settings context which is responsible for live template customization hooks useSettings is used to access settings context values, useBgColor is used to get different colors and useClipboard is used to copy some texts layouts All the layouts and layout components like menu, appBar and footer reside in this folder for any user to override from the @core folder styles MUI's stepper styled component and all the third party styled components reside in this folder theme All the MUI theming like palette, breakpoints, typography, component's styling etc. are done in this folder utils All the helpful functions used in whole template. Users can also import and use these useful functions.
# Getting Support In this page you will find how to get support and how to raise perfect support ticket to resolve your issues quickly with minimum conversation. We value your time üïù # Raising Support Ticket Raising support ticket in support portal is as simple as commenting on post. However, If you want to get your issues resolved quickly please follow below guide: # Finding existing solution There might be a case that your issue is already resolved and you are the one who is facing due to some issue. So before creating new support ticket please search your question / issue in our FAQ page where we have listed most common questions / issues asked in our support portal. # Ticket Type Add ticket type to your ticket title to let community understand what your ticket is about. This also helps to find related tickets using ticket type. So, your ticket till will be like [question] how to change theme? Some common ticket types are listed below: question - If you are asking question installation - If you have anything related to installation auth - If you have anything related to JWT or Auth acl - If you have anything related to Access Control feat-req - If you have any feature request for our template bug - If you find any bug in template other - if your ticket isn't related to above mentioned ticket types Good examples can be: üíØ [question] How to change theme? [question] How to change i18n locale? [installation] Getting errors in npm run dev [auth] Unexpected behavior after login [other] Collapse component is not working as expected [auth] I get redirected to login page even after login on refresh # New Issue - New ticket Always consider creating a new support ticket for the question or issue you might have that is not related to your currently open ticket. Let's say you opened ticket for installation issue and want to ask about some component usage then it will be better to close installation ticket and open another ticket for that component to make support portal more accurate and easy find place. # Template Version Mentioning which version of our template you are using will help us to answer more accurately and will mitigate one question from our side. Mentioning template version includes if you are using TypeScript or JavaScript, Full-Version or Starter-Kit. Also, if you are using some other technology with our template then mentioning it will also help us in resolving issue quickly. Good examples can be: üíØ TypeScript + Full Version Javascript + Starter Kit # Sharing Code or Snippet If you want to show us some code it will be better if you can format it properly and use code block so your pasted code get highlighted. # Reproducing Issue/Bug - Starter-kit If you have ticket where we need to have a look at your code like some component's certain feature is working in our live demo but not in your downloaded package then it will better you give us actual issue or reproduction steps. Best solution for this is using our Starter-kit where we can test it without any dependency. This will also help you to clear your issue before sending it to us. You can create zip and share with us using private link. WARNING Never upload our package or modified version of our package on public sites where others can view or download it. # Support Portal Once you have purchased our template, You can get support at our support portal  (opens new window) by raising support ticket. Please make sure to follow standards defined in Raising Support Ticket section. Don't want to waste time? Creating perfect support ticket (Following our Guide) will increase the chances of getting issue resolved with minimum conversation and time. # Framework Support To get support for framework related question, raise issue at their Github  (opens new window) repo. Good candidates for framework support are: How to use x component (x means any MUI Component) x component not working as expected # Third Party Package Support Same as framework support, if you have any query regarding how to use any provided package other than their UI you can ask it in their respective Github repo issue section.
# Folder Structure Heads Up Do not make any changes in the src/@core folder unless suggested by our support team. It is the core functionality of the template which is responsible to run the template and will be updated with every new update. Use src/layouts folder to override core layouts and components. Understand folder structure of the template and what every folder contains. # Overview Before checking folder structure it is better you know some stuff related to folder structure. src/@core folder contains core files of template which shall not get modified unless our support team guide you to do it. Outside of src/@core folder are files you can move and modify as per your wish. Basically that is your playground where you can modify anything. src/@fake-db folder just contains dummy data which we get in response of API call. This enables us to take step forward in providing API ready template. src/layouts folder outside of src/@core are your layouts which you can modify however you like. Template will always render these layouts. # Main Package Following is the folder structure of the full-version under both typescript / javascript version. Not explaining the folder structure for starter kit as everything is covered in the full version. ‚îú‚îÄ‚îÄ public
‚îÇ   ‚îú‚îÄ‚îÄ images                   -> Static assets
‚îÇ   ‚îú‚îÄ‚îÄ locales                  -> Translations
‚îÇ   ‚îî‚îÄ‚îÄ other files
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ @core                    -> Template's core files
‚îÇ   ‚îú‚îÄ‚îÄ @fake-db                 -> Fake Database for mocking axios requests (Fake API Calls)
‚îÇ   ‚îú‚îÄ‚îÄ configs                  -> Configuration files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ acl.ts               -> Your Access Control file/configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts              -> Your authentication file/configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ i18n.ts              -> i18n configurations and initialization
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ themeConfig.ts       -> Template configurations
‚îÇ   ‚îú‚îÄ‚îÄ context                  -> Your context files go here
‚îÇ   ‚îú‚îÄ‚îÄ hooks                    -> Your hooks go here
‚îÇ   ‚îú‚îÄ‚îÄ layouts                  -> Your layouts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components           -> Your components, layout components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserLayout.tsx       -> File responsible to render layout & template
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserThemeOptions.ts  -> Your theming file to override core theming
‚îÇ   ‚îú‚îÄ‚îÄ navigation               -> Vertical & Horizontal static navigation menu files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ horizontal
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vertical
‚îÇ   ‚îú‚îÄ‚îÄ pages                    -> View files that render all the pages
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _app.tsx             -> Main file responsible to render layout
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _document.tsx        -> HTML document & emotions configurations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx            -> Application entry file
‚îÇ   ‚îú‚îÄ‚îÄ store                    -> Redux store
‚îÇ   ‚îú‚îÄ‚îÄ types                    -> All types (only in the typescript version)
‚îÇ   ‚îî‚îÄ‚îÄ views                    -> View files that are included in pages folder
‚îú‚îÄ‚îÄ styles                       -> Global styling
‚îú‚îÄ‚îÄ .env                         -> Environment file
‚îú‚îÄ‚îÄ .eslintrc.json               -> ESLint configurations (Linting code)
‚îú‚îÄ‚îÄ .gitignore                   -> gitignore (ignore files and folder to sync with repo)
‚îú‚îÄ‚îÄ .npmrc                       -> Node configuration file
‚îú‚îÄ‚îÄ .nvmrc                       -> nvm configuration file
‚îú‚îÄ‚îÄ .prettierrc.js               -> Prettier configurations (editor code formatting)
‚îú‚îÄ‚îÄ next.config.js               -> Next js configurations
‚îú‚îÄ‚îÄ next.d.ts                    -> Next js global types configurations
‚îú‚îÄ‚îÄ package.json                 -> All the dependencies require to run the template
‚îú‚îÄ‚îÄ tsconfig.json               -> TypeScript configurations
# @core folder src/@core folder is the core of our template which contains core layouts, components and theming where you should not make any change but override them with the help of our layout docs in case of any changes required in core files. src/@core folder isn't meant to get modified. When you will update our template replacing this src/@core folder will hopefully update the template with minimum changes. It's a good idea to have a look at it and know what it contains to use stuff we already invented so you don't have to reinvent the wheel. # Understanding Core folder Understanding the src/@core folder will save your development time and you will know how to get most out of our template. Folder Description components It contains core components of the template. Make sure to check them all in our custom components section context Settings context which is responsible for live template customization hooks useSettings is used to access settings context values, useBgColor is used to get different colors and useClipboard is used to copy some texts layouts All the layouts and layout components like menu, appBar and footer reside in this folder for any user to override from the @core folder styles MUI's stepper styled component and all the third party styled components reside in this folder theme All the MUI theming like palette, breakpoints, typography, component's styling etc. are done in this folder utils All the helpful functions used in whole template. Users can also import and use these useful functions.
# Layout Types TIP We recommend you to go through the Layout Docs of NextJS  (opens new window) to understand how the layout works in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview We provide four types of layouts: Vertical Layout, Horizontal Layout, Blank Layout and Blank Layout with AppBar. Each of them is explained in detail. # Vertical Layout This is the default layout. With this layout, you will get the following layout components: Navigation Menu (left sidebar) Navbar (at top of the page) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Vertical Layout looks like this:  # Horizontal Layout You can make this your default layout. With this layout, you will get the following layout components: Navbar (at top of the page) Navigation Menu (on top of the page below the Navbar) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Horizontal Layout looks like this:  # Blank Layout This is useful if you want to create pages without any other content and where you don't need a navbar, navigation menu and footer. For example, an Authentication page. This is a blank page where you can create everything from scratch. Blank Layout in Login page looks like this:  # Blank Layout with AppBar This is useful if you want to create pages where you don't need a navigation menu and footer. For example, an Authentication page. With this layout, you will get a navbar (or AppBar) on top of the page. AppBar is explained here. Blank Layout with AppBar in Login page looks like this: 
# Access Control (ACL) # Overview Vuexy uses the CASL  (opens new window) package to provide access control. CASL is future-oriented and is more detailed on Access Control. We suggest you read the CASL  (opens new window) documentation to learn how it works. CASL may look complex at first so please make sure you first read their docs carefully and understand the base logic of Access Control to proceed further. # Config You can find CASL configuration in src/configs/acl.ts. We have defined two roles admin & client and their actions in the configuration file. You'll have to update these roles & actions according to your application requirement. const defineRulesFor = (role, subject) => {
  const { can, rules } = new AbilityBuilder(AppAbility)

  if (role === 'admin') {
    can('manage', 'all')
  } else if (role === 'client') {
    can(['read'], 'acl-page')
  } else {
    can(['read', 'create', 'update', 'delete'], subject)
  }

  return rules
}
# Component To define an accessible component use acl method with action & subject properties like shown below. You can also refer full-version/src/pages/acl/index.tsx file for implementation. ¬†¬†¬†¬†const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
# Navigation Define the action & subject properties in navigation file to show/hide the navigation links/groups based on user role. Refer to the example below: ¬†¬†{
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
# Home URL Please update home URL based on yser role in src/pages/index.tsx file. Currently, we have set default URL for client and admin like following:  # How to remove ACL It is quite easy to remove access control from the template. Remove the src/configs/acl.ts file Remove the import type { ACLObj } from 'src/configs/acl' import statement & acl?: ACLObj from next.d.ts file if next.d.ts file is present in your project. Remove the src/@core/components/auth/AclGuard.tsx file Remove the AclGuard wrapper & ACL related imports from src/pages/_app.tsx file. Change following code from: // Code before removing ACL Guard
import { defaultACLObj } from 'src/configs/acl'
import AclGuard from 'src/@core/components/auth/AclGuard'

const aclAbilities = Component.acl ?? defaultACLObj

<AclGuard aclAbilities={aclAbilities} guestGuard={guestGuard}>
  {getLayout(<Component {...pageProps} />)}
</AclGuard>
to // Code after removing ACL Guard
{getLayout(<Component {...pageProps} />)}
 Remove the acl method from all the components. Component from: const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
to const Component = () => <h1>Component</h1>

export default Component
 Remove action & subject properties if defined in your navigation files. Navigation object from: {
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
to {
  path: '/acl',
  icon: 'tabler:shield',
  title: 'Access Control'
}
 In the src/pages/index.tsx file, update Home URL like the following: // Set Home URL based on User Roles
export const getHomeRoute = () => {
  return '/dashboards/analytics'
}

// And call this function like this:
const homeRoute = getHomeRoute()
OR Empty src/pages/index.tsx file and render your Home component like following: const Component = () => <h1>Component</h1>

export default Component
 Remove the ability & ability.can function in all the CanView files in src/layouts/components/acl folder. Replace the following codes in respective files in order to remove ACL functionality.   
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# Access Control (ACL) # Overview Vuexy uses the CASL  (opens new window) package to provide access control. CASL is future-oriented and is more detailed on Access Control. We suggest you read the CASL  (opens new window) documentation to learn how it works. CASL may look complex at first so please make sure you first read their docs carefully and understand the base logic of Access Control to proceed further. # Config You can find CASL configuration in src/configs/acl.ts. We have defined two roles admin & client and their actions in the configuration file. You'll have to update these roles & actions according to your application requirement. const defineRulesFor = (role, subject) => {
  const { can, rules } = new AbilityBuilder(AppAbility)

  if (role === 'admin') {
    can('manage', 'all')
  } else if (role === 'client') {
    can(['read'], 'acl-page')
  } else {
    can(['read', 'create', 'update', 'delete'], subject)
  }

  return rules
}
# Component To define an accessible component use acl method with action & subject properties like shown below. You can also refer full-version/src/pages/acl/index.tsx file for implementation. ¬†¬†¬†¬†const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
# Navigation Define the action & subject properties in navigation file to show/hide the navigation links/groups based on user role. Refer to the example below: ¬†¬†{
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
# Home URL Please update home URL based on yser role in src/pages/index.tsx file. Currently, we have set default URL for client and admin like following:  # How to remove ACL It is quite easy to remove access control from the template. Remove the src/configs/acl.ts file Remove the import type { ACLObj } from 'src/configs/acl' import statement & acl?: ACLObj from next.d.ts file if next.d.ts file is present in your project. Remove the src/@core/components/auth/AclGuard.tsx file Remove the AclGuard wrapper & ACL related imports from src/pages/_app.tsx file. Change following code from: // Code before removing ACL Guard
import { defaultACLObj } from 'src/configs/acl'
import AclGuard from 'src/@core/components/auth/AclGuard'

const aclAbilities = Component.acl ?? defaultACLObj

<AclGuard aclAbilities={aclAbilities} guestGuard={guestGuard}>
  {getLayout(<Component {...pageProps} />)}
</AclGuard>
to // Code after removing ACL Guard
{getLayout(<Component {...pageProps} />)}
 Remove the acl method from all the components. Component from: const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
to const Component = () => <h1>Component</h1>

export default Component
 Remove action & subject properties if defined in your navigation files. Navigation object from: {
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
to {
  path: '/acl',
  icon: 'tabler:shield',
  title: 'Access Control'
}
 In the src/pages/index.tsx file, update Home URL like the following: // Set Home URL based on User Roles
export const getHomeRoute = () => {
  return '/dashboards/analytics'
}

// And call this function like this:
const homeRoute = getHomeRoute()
OR Empty src/pages/index.tsx file and render your Home component like following: const Component = () => <h1>Component</h1>

export default Component
 Remove the ability & ability.can function in all the CanView files in src/layouts/components/acl folder. Replace the following codes in respective files in order to remove ACL functionality.   
# Loaders # Pace Loader (Page Loader) We're using nprogress  (opens new window) as the paceloader (or page loader). If you want to disable it, change the routingLoader property to false in the src/configs/themeConfig.ts file. But if you want to remove the package, follow these steps: Remove nprogress & @types/nprogress packages from the package.json file Remove the following snippet in the src/pages/_app.ts file import NProgress from 'nprogress'

// ** Pace Loader
if (themeConfig.routingLoader) {
  Router.events.on('routeChangeStart', () => {
    NProgress.start()
  })
  Router.events.on('routeChangeError', () => {
    NProgress.done()
  })
  Router.events.on('routeChangeComplete', () => {
    NProgress.done()
  })
}
# Splash Screen (Loader with Logo) If you want to keep the splash screen as it is with your logo, then follow these steps: Make a new file in the src/layouts/components folder Copy the code from the src/@core/components/spinner/index.tsx file and paste it in the file you just made Remove our SVG logo and add your logo (you can add the logo of any format viz. JPEG, PNG, SVG, etc.) Pass your component in the fallback prop with the AuthGuard and GuestGuard components in the src/pages/_app.tsx file. // src/pages/_app.tsx

import UserSpinner from 'src/layouts/components/UserSpinner.tsx'

<GuestGuard fallback={<UserSpinner />}>{children}</GuestGuard>
<AuthGuard fallback={<UserSpinner />}>{children}</AuthGuard>
If you want to change the whole splash screen, then follow these steps: Make your own loader component in the src/layouts/components folder Pass your component in the fallback prop with the AuthGuard and GuestGuard components in the src/pages/_app.tsx file. // src/pages/_app.tsx

import UserSpinner from 'src/layouts/components/UserSpinner.tsx'

<GuestGuard fallback={<UserSpinner />}>{children}</GuestGuard>
<AuthGuard fallback={<UserSpinner />}>{children}</AuthGuard>
You can also pass null instead of a loader if you don't want to show a loader in the splash screen.
# Access Control (ACL) # Overview Vuexy uses the CASL  (opens new window) package to provide access control. CASL is future-oriented and is more detailed on Access Control. We suggest you read the CASL  (opens new window) documentation to learn how it works. CASL may look complex at first so please make sure you first read their docs carefully and understand the base logic of Access Control to proceed further. # Config You can find CASL configuration in src/configs/acl.ts. We have defined two roles admin & client and their actions in the configuration file. You'll have to update these roles & actions according to your application requirement. const defineRulesFor = (role, subject) => {
  const { can, rules } = new AbilityBuilder(AppAbility)

  if (role === 'admin') {
    can('manage', 'all')
  } else if (role === 'client') {
    can(['read'], 'acl-page')
  } else {
    can(['read', 'create', 'update', 'delete'], subject)
  }

  return rules
}
# Component To define an accessible component use acl method with action & subject properties like shown below. You can also refer full-version/src/pages/acl/index.tsx file for implementation. ¬†¬†¬†¬†const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
# Navigation Define the action & subject properties in navigation file to show/hide the navigation links/groups based on user role. Refer to the example below: ¬†¬†{
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
# Home URL Please update home URL based on yser role in src/pages/index.tsx file. Currently, we have set default URL for client and admin like following:  # How to remove ACL It is quite easy to remove access control from the template. Remove the src/configs/acl.ts file Remove the import type { ACLObj } from 'src/configs/acl' import statement & acl?: ACLObj from next.d.ts file if next.d.ts file is present in your project. Remove the src/@core/components/auth/AclGuard.tsx file Remove the AclGuard wrapper & ACL related imports from src/pages/_app.tsx file. Change following code from: // Code before removing ACL Guard
import { defaultACLObj } from 'src/configs/acl'
import AclGuard from 'src/@core/components/auth/AclGuard'

const aclAbilities = Component.acl ?? defaultACLObj

<AclGuard aclAbilities={aclAbilities} guestGuard={guestGuard}>
  {getLayout(<Component {...pageProps} />)}
</AclGuard>
to // Code after removing ACL Guard
{getLayout(<Component {...pageProps} />)}
 Remove the acl method from all the components. Component from: const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
to const Component = () => <h1>Component</h1>

export default Component
 Remove action & subject properties if defined in your navigation files. Navigation object from: {
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
to {
  path: '/acl',
  icon: 'tabler:shield',
  title: 'Access Control'
}
 In the src/pages/index.tsx file, update Home URL like the following: // Set Home URL based on User Roles
export const getHomeRoute = () => {
  return '/dashboards/analytics'
}

// And call this function like this:
const homeRoute = getHomeRoute()
OR Empty src/pages/index.tsx file and render your Home component like following: const Component = () => <h1>Component</h1>

export default Component
 Remove the ability & ability.can function in all the CanView files in src/layouts/components/acl folder. Replace the following codes in respective files in order to remove ACL functionality.   
# Starter-kit vs Full Package # Starter-kit Starter-kit is a minimal template from where you can start your project quickly instead of removing stuff that isn't needed. Below are quick notes on the starter-kit: No i18n Simple Navbar Four pages (Two sample pages + 404 + Login) Customizer (disabled) No Axios Use it if you don't want to clutter your project with extra libs which aren't required. You still need to streamline all the dependencies from package.json file. We have taken care of cleaning up unnecessary code . You can just copy components from full version into the starter kit and it should work üòç. TIP Use starter-kit to provide reproduction steps if you raise any technical issue on GitHub. # Full Package This setup has all the things which you can see in the live demo except for that red Buy Now button üòÖ. With this, you have to remove things that you don't use or replace them with your content. # Conclusion According to us, starter-kit is easy to get started with minimal setup and our folder and code structure will help you add libs support in starter-kit more easily than ever. Still, if your project becomes easy with the full package, go for it. WARNING Please make sure to copy required images from the full version if you copy content from the full version to the starter-kit.
# Settings Context # Overview Settings Context has been created so that the template is independent of the redux store for storing the variables used in the template. # Properties Following are the properties and their values that are stored in the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed navHidden true, false If true, the navigation menu is hidden layout vertical, horizontal Set Vertical or Horizontal layout for the template lastLayout vertical, horizontal For internal usage (used when window is resized in Horizontal layout) verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity footer fixed, static, hidden Change footer position themeColor primary, secondary, success, error, warning, info Change primary color in the template toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Default toast position of react-hot-toast # LocalStorage Following are the properties and their values that are stored in localStorage from the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBarBlur true, false If true, background of appBar will have opacity themeColor primary, secondary, success, error, warning, info Change primary color in the template # Provider and Consumer Settings context relies on the context feature of React  (opens new window) to pass the settings down to the components. Settings context exports SettingsProvider and SettingsConsumer and they must be parents of ThemeComponent in src/pages/_app.tsx file. See the following code: <SettingsProvider>
  <SettingsConsumer>
    {({ settings }) => (
      <ThemeComponent settings={settings}>{getLayout(<Component {...pageProps} />)}</ThemeComponent>
    )}
  </SettingsConsumer>
</SettingsProvider>

# Styled Components # Overview These are the styles available in the src/@core/styles folder: MUI Stepper Fullcalendar Keen Slider React Apexcharts CleaveJs React Credit Cards React Datepicker React Draft Wysiwyg React Dropzone React Hot Toast Recharts TIP If you do not want to use these styles, then render your component directly. This will apply the default styles provided by MUI and/or third-party plugins. # Usage You need to import styles as a component and wrap them around your components. Let us take an example of React Datepicker: import DatePicker from 'react-datepicker'
import DatePickerWrapper from 'src/@core/styles/libs/react-datepicker'

<DatePickerWrapper>
  <DatePicker
    {...} // all of your props
  />
</DatePickerWrapper>
If you do not want to use these styles: import DatePicker from 'react-datepicker'

<DatePicker
  {...} // all of your props
/>
TIP If you have to use any styles with multiple components like multiple CleaveJS components used in a single page, then you need to import the styles once and then wrap the index file of that page with the styled component, so that the styles are not called multiple times. # Override Styled Components Overriding these styles components is very easy. Follow these steps to override any styles: Make a new file in the src/layouts/styles folder Copy the code of that component that you want to override from the src/@core/styles folder and paste it into the new file that you just made Override the styles as per your project requirements Let us say that you want to override the styles of React Credit Cards: // src/layouts/styles/react-credit-cards/index.ts

import { styled } from '@mui/material/styles'

const CardWrapper = styled('div')(({ theme }) => ({
  display: 'flex',
  '& .rccs, & .rccs__card': {
    margin: theme.spacing(4)
  }
}))

export default CardWrapper
# React Hot Toast The styles of React Hot Toast are globally included in the src/pages/_app.tsx file, so you do not need to add a wrapper in any of your toast components. # Usage // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import ReactHotToast from 'src/@core/styles/libs/react-hot-toast'

<ReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</ReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>
# Override To override the styles, you need to follow the same steps that are explained above. Now, suppose you want to open the toasts at their default position, then: Make a new file in the src/layouts/styles folder (say src/layouts/styles/react-hot-toast/index.ts) Copy the code from the src/@core/styles/react-hot-toast/index.ts file and paste it into the src/layouts/styles/react-hot-toast/index.ts file Remove the following code: '& > div': {
  top: '75px !important',
  right: `${theme.spacing(6)} !important`
}
Import and render src/layouts/styles/react-hot-toast/index.ts file in src/pages/_app.tsx file // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import UserReactHotToast from 'src/layouts/styles/react-hot-toast'

<UserReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</UserReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>

# Access Control (ACL) # Overview Vuexy uses the CASL  (opens new window) package to provide access control. CASL is future-oriented and is more detailed on Access Control. We suggest you read the CASL  (opens new window) documentation to learn how it works. CASL may look complex at first so please make sure you first read their docs carefully and understand the base logic of Access Control to proceed further. # Config You can find CASL configuration in src/configs/acl.ts. We have defined two roles admin & client and their actions in the configuration file. You'll have to update these roles & actions according to your application requirement. const defineRulesFor = (role, subject) => {
  const { can, rules } = new AbilityBuilder(AppAbility)

  if (role === 'admin') {
    can('manage', 'all')
  } else if (role === 'client') {
    can(['read'], 'acl-page')
  } else {
    can(['read', 'create', 'update', 'delete'], subject)
  }

  return rules
}
# Component To define an accessible component use acl method with action & subject properties like shown below. You can also refer full-version/src/pages/acl/index.tsx file for implementation. ¬†¬†¬†¬†const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
# Navigation Define the action & subject properties in navigation file to show/hide the navigation links/groups based on user role. Refer to the example below: ¬†¬†{
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
# Home URL Please update home URL based on yser role in src/pages/index.tsx file. Currently, we have set default URL for client and admin like following:  # How to remove ACL It is quite easy to remove access control from the template. Remove the src/configs/acl.ts file Remove the import type { ACLObj } from 'src/configs/acl' import statement & acl?: ACLObj from next.d.ts file if next.d.ts file is present in your project. Remove the src/@core/components/auth/AclGuard.tsx file Remove the AclGuard wrapper & ACL related imports from src/pages/_app.tsx file. Change following code from: // Code before removing ACL Guard
import { defaultACLObj } from 'src/configs/acl'
import AclGuard from 'src/@core/components/auth/AclGuard'

const aclAbilities = Component.acl ?? defaultACLObj

<AclGuard aclAbilities={aclAbilities} guestGuard={guestGuard}>
  {getLayout(<Component {...pageProps} />)}
</AclGuard>
to // Code after removing ACL Guard
{getLayout(<Component {...pageProps} />)}
 Remove the acl method from all the components. Component from: const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
to const Component = () => <h1>Component</h1>

export default Component
 Remove action & subject properties if defined in your navigation files. Navigation object from: {
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
to {
  path: '/acl',
  icon: 'tabler:shield',
  title: 'Access Control'
}
 In the src/pages/index.tsx file, update Home URL like the following: // Set Home URL based on User Roles
export const getHomeRoute = () => {
  return '/dashboards/analytics'
}

// And call this function like this:
const homeRoute = getHomeRoute()
OR Empty src/pages/index.tsx file and render your Home component like following: const Component = () => <h1>Component</h1>

export default Component
 Remove the ability & ability.can function in all the CanView files in src/layouts/components/acl folder. Replace the following codes in respective files in order to remove ACL functionality.   
# How to change Logo / Branding ? The main question here is, How can you change your branding in the core components like vertical / horizontal menu as we do not suggest to make any changes in the src/@core directory. Please refer following docs in order to override Logo / Branding in Vertical menu: Vertical Menu Logo / Branding Change Please refer following docs in order to override Logo / Branding in Horizontal menu: Horizontal Menu Logo / Branding Change There are many other instances where you will have to change Logo / Branding like Login, Registration, Invoice pages but as they are not inside the src/@core directory, you don't need to worry and just remove our Logo / Branding code and replace it with your code.
# Theme Configurations # Overview To configure your template, we will be using the src/configs/themeConfig.ts file, which has all the template configurations listed with their valid values. Just change the configurations as per your requirement and you are done. If you are looking to match up with one of our demos, then please read demo configs doc. Important Make sure you clear the browser's local storage in order to see the config changes in the template. Refer: How to clear local storage?  (opens new window) # Properties Following are the properties with their values that we have used in the theme:  # beforeVerticalNavMenuContentPosition If the value is set to static, then the content will get scrolled along with the vertical navigation. If the value is set to fixed, then the content will not get scrolled along with the vertical navigation. # beforeVerticalNavMenuContentPosition: 'static'   # beforeVerticalNavMenuContentPosition: 'fixed'   # afterVerticalNavMenuContentPosition If the value is set to static, then the content will get scrolled along with the vertical navigation. If the value is set to fixed, then the content will not get scrolled along with the vertical navigation. # afterVerticalNavMenuContentPosition: 'static'   # afterVerticalNavMenuContentPosition: 'fixed'   # Property Options Following is the table of all the properties and their possible values that are available in the theme configurations: Properties Values Description templateName string Name of the template, project or company layout vertical, horizontal Set Vertical or Horizontal layout for the template mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction skin default, bordered Change template skin contentWidth full, boxed Full or container width of AppBar, Content and Footer footer fixed, static, hidden Change footer position routingLoader true, false Loader on top of the app on route change navHidden true, false If true, the navigation menu is hidden menuTextTruncate true, false If true, text truncate in the navigation menu is enabled navSubItemIcon string Change icon for the sub menus in the navigation menu verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu navCollapsed true, false If true, the vertical navigation menu is collapsed navigationSize number Width of navigation menu when menu is not collapsed collapsedNavigationSize number Width of navigation menu when menu is collapsed afterVerticalNavMenuContentPosition fixed, static Position of the content which is added after the vertical navigation menu beforeVerticalNavMenuContentPosition fixed, static Position of the content which is added before the vertical navigation menu horizontalMenuToggle click, hover Set behavior of menu group in the horizontal navigation menu horizontalMenuAnimation true, false If true, animation is enabled for the horizontal navigation menu appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity responsiveFontSizes true, false If true, responsive font sizes are enabled disableRipple true, false If true, the Ripple effect is disabled disableCustomizer true, false If true, customizer is disabled as right sidebar to configure in live app toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Set default toast position in the template
# Routing Vuexy uses Next.js's file-system based router built on the concept of pages. When a file is added to the src/pages directory, it's automatically available as a route. # Index routes The router will automatically route files named index to the root of the directory. pages/index.tsx ‚Üí / pages/dashboards/index.tsx ‚Üí /blog # Nested routes The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way. pages/dashboards/ecommerce/index.tsx ‚Üí /dashboards/ecommerce # Dynamic route segments Defining routes by using predefined paths is not always enough for complex applications. In Next.js you can add brackets to a page param to create a dynamic route (a.k.a. URL slugs, pretty URLs, and others). To match a dynamic segment you can use the bracket syntax. This allows you to match named parameters. pages/apps/email/[folder].tsx ‚Üí /apps/email/spam pages/apps/email/label/[label].tsx ‚Üí /apps/email/label/company pages/apps/email/[...all].tsx ‚Üí /apps/email/* (/apps/email/view/id/1)
# Internationalization (i18n) # Overview We're using react-i18next  (opens new window) for Internationalization. You can find its configurations in src/configs/i18n.ts file and the locales in public/locales folder in the full version. # Usage Refer to this article to implement the internationalization. # Add i18n WARNING Only for those who are using the starter-kit If you are using the full version, then you don't need to add i18n as it is already available in that version. But if you are using the starter-kit (which is recommended) and want to add i18n, then follow these steps: You need to add these npm packages:
i18next react-i18next i18next-http-backend i18next-browser-languagedetector  Copy src/configs/i18n.ts file from the full version and paste it under the same directory in your project Add import 'src/configs/i18n' import statement in src/pages/_app.tsx file Add your locale files in public/locales folder If you want to translate the navigation menu, then copy the whole code from src/layouts/components/Translations.tsx file from the full version and paste it under the same directory in your project If you want a language dropdown in the appBar to change the current language in the app, then import src/@core/layouts/components/shared-components/LanguageDropdown.tsx file and render LanguageDropdown component in src/layouts/components/vertical/AppBarContent.tsx or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
# Remove i18n WARNING Only for those who are using the full version If you do not want to use i18n, we recommend you start your project with the starter-kit. But if you are using the full version and does not want to use i18n, then follow these steps: You may remove all the packages related to i18n from package.json file if you want to
i18next react-i18next i18next-http-backend i18next-browser-languagedetector Remove src/configs/i18n.ts file Remove import 'src/configs/i18n' import statement from src/pages/_app.tsx file Replace the following code in src/layouts/components/Translations.tsx file  Remove LanguageDropdown file import statement and rendered component from src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
Remove your locale files from public/locales folder # Add / Remove a language Suppose you want to add de (German) language and remove ar (Arabic) language. For this, you need to follow these steps: Remove public/locales/ar.json file and add public/locales/de.json file. You need to keep the format of the file as it is in other locale files Make a new file in src/layouts/components folder and place the following code in this file  Import the src/layouts/components/UserLanguageDropdown.tsx file and render it in the src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file. 
# Internationalization (i18n) # Overview We're using react-i18next  (opens new window) for Internationalization. You can find its configurations in src/configs/i18n.ts file and the locales in public/locales folder in the full version. # Usage Refer to this article to implement the internationalization. # Add i18n WARNING Only for those who are using the starter-kit If you are using the full version, then you don't need to add i18n as it is already available in that version. But if you are using the starter-kit (which is recommended) and want to add i18n, then follow these steps: You need to add these npm packages:
i18next react-i18next i18next-http-backend i18next-browser-languagedetector  Copy src/configs/i18n.ts file from the full version and paste it under the same directory in your project Add import 'src/configs/i18n' import statement in src/pages/_app.tsx file Add your locale files in public/locales folder If you want to translate the navigation menu, then copy the whole code from src/layouts/components/Translations.tsx file from the full version and paste it under the same directory in your project If you want a language dropdown in the appBar to change the current language in the app, then import src/@core/layouts/components/shared-components/LanguageDropdown.tsx file and render LanguageDropdown component in src/layouts/components/vertical/AppBarContent.tsx or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
# Remove i18n WARNING Only for those who are using the full version If you do not want to use i18n, we recommend you start your project with the starter-kit. But if you are using the full version and does not want to use i18n, then follow these steps: You may remove all the packages related to i18n from package.json file if you want to
i18next react-i18next i18next-http-backend i18next-browser-languagedetector Remove src/configs/i18n.ts file Remove import 'src/configs/i18n' import statement from src/pages/_app.tsx file Replace the following code in src/layouts/components/Translations.tsx file  Remove LanguageDropdown file import statement and rendered component from src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
Remove your locale files from public/locales folder # Add / Remove a language Suppose you want to add de (German) language and remove ar (Arabic) language. For this, you need to follow these steps: Remove public/locales/ar.json file and add public/locales/de.json file. You need to keep the format of the file as it is in other locale files Make a new file in src/layouts/components folder and place the following code in this file  Import the src/layouts/components/UserLanguageDropdown.tsx file and render it in the src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file. 
# :first-child console error When we use one of the pseudo-classes  :first-child, :nth-child(N) or :nth-last-child(N), we may get errors in the browser console like the following: The pseudo class ":first-child" is potentially unsafe when doing server-side rendering.
The pseudo class ":nth-child(N)" is potentially unsafe when doing server-side rendering.
The pseudo class ":nth-last-child(N)" is potentially unsafe when doing server-side rendering.
There is nothing wrong with using these pseudo-classes. This issue is a warning for those who are using server-side rendering that these pseudo-classes might not work. This issue is not from our template or MUI framework but rather it is from emotion's  (opens new window) side. Please read this issue  (opens new window) for further details.
# How to use i18n in a page Vuexy admin provides i18n for navigation only. There might be a time when you might want to translate any text in a page. Here's how you can achieve that: Make sure your have i18next, react-i18next, i18next-http-backend and i18next-browser-languagedetector packages installed Copy the src/configs/i18n.ts file from the full version and paste it under the same directory in your project Add import 'src/configs/i18n' import statement in the src/pages/_app.tsx file Create a locales folder in the public folder Create JSON files with language as their file names in locales depending on the languages you need. For example, we're using three languages English, French & Arabic // en.json
{
  "Hello World": "Hello World"
}
// fr.json
{
  "Hello World": "Bonjour le monde"
}
// ar.json
{
  "Hello World": "ŸÖÿ±ÿ≠ÿ®ÿß ÿ®ÿßŸÑÿπÿßŸÑŸÖ"
}
Import useTranslation in the page where you want to translate the content import { useTranslation } from 'react-i18next'
You can now initialize the useTranslation and use the changeLanguage function to change the language import { useTranslation } from 'react-i18next'

const Component = () => {
  const { t, i18n } = useTranslation()

  return (
    <div>
      <h1>{t('Hello World')}</h1>
      <button onClick={() => i18n.changeLanguage('fr')}>Translate</button>
    </div>
  )
}

export default Component

# Internationalization (i18n) # Overview We're using react-i18next  (opens new window) for Internationalization. You can find its configurations in src/configs/i18n.ts file and the locales in public/locales folder in the full version. # Usage Refer to this article to implement the internationalization. # Add i18n WARNING Only for those who are using the starter-kit If you are using the full version, then you don't need to add i18n as it is already available in that version. But if you are using the starter-kit (which is recommended) and want to add i18n, then follow these steps: You need to add these npm packages:
i18next react-i18next i18next-http-backend i18next-browser-languagedetector  Copy src/configs/i18n.ts file from the full version and paste it under the same directory in your project Add import 'src/configs/i18n' import statement in src/pages/_app.tsx file Add your locale files in public/locales folder If you want to translate the navigation menu, then copy the whole code from src/layouts/components/Translations.tsx file from the full version and paste it under the same directory in your project If you want a language dropdown in the appBar to change the current language in the app, then import src/@core/layouts/components/shared-components/LanguageDropdown.tsx file and render LanguageDropdown component in src/layouts/components/vertical/AppBarContent.tsx or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
# Remove i18n WARNING Only for those who are using the full version If you do not want to use i18n, we recommend you start your project with the starter-kit. But if you are using the full version and does not want to use i18n, then follow these steps: You may remove all the packages related to i18n from package.json file if you want to
i18next react-i18next i18next-http-backend i18next-browser-languagedetector Remove src/configs/i18n.ts file Remove import 'src/configs/i18n' import statement from src/pages/_app.tsx file Replace the following code in src/layouts/components/Translations.tsx file  Remove LanguageDropdown file import statement and rendered component from src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
Remove your locale files from public/locales folder # Add / Remove a language Suppose you want to add de (German) language and remove ar (Arabic) language. For this, you need to follow these steps: Remove public/locales/ar.json file and add public/locales/de.json file. You need to keep the format of the file as it is in other locale files Make a new file in src/layouts/components folder and place the following code in this file  Import the src/layouts/components/UserLanguageDropdown.tsx file and render it in the src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file. 
# Settings Context # Overview Settings Context has been created so that the template is independent of the redux store for storing the variables used in the template. # Properties Following are the properties and their values that are stored in the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed navHidden true, false If true, the navigation menu is hidden layout vertical, horizontal Set Vertical or Horizontal layout for the template lastLayout vertical, horizontal For internal usage (used when window is resized in Horizontal layout) verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity footer fixed, static, hidden Change footer position themeColor primary, secondary, success, error, warning, info Change primary color in the template toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Default toast position of react-hot-toast # LocalStorage Following are the properties and their values that are stored in localStorage from the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBarBlur true, false If true, background of appBar will have opacity themeColor primary, secondary, success, error, warning, info Change primary color in the template # Provider and Consumer Settings context relies on the context feature of React  (opens new window) to pass the settings down to the components. Settings context exports SettingsProvider and SettingsConsumer and they must be parents of ThemeComponent in src/pages/_app.tsx file. See the following code: <SettingsProvider>
  <SettingsConsumer>
    {({ settings }) => (
      <ThemeComponent settings={settings}>{getLayout(<Component {...pageProps} />)}</ThemeComponent>
    )}
  </SettingsConsumer>
</SettingsProvider>

# How to update this template ? We are making template update as easy as possible from our side. We create our folder structure which makes updating process easier than ever. üòç TIP If you are using React only version then mostly replacing @core folder in your project is enough. Still, verifying if something outside of @core is changed or not is always helpful and keeps you error free. üòá Let's check how you can view each and every change in our template's latest release with ease. # Prerequisite VS Code  (opens new window) VS Code Extension: Compare Folders  (opens new window) Vuexy Package you started your project with (Older version of Vuexy package which you used) Vuexy Latest Package # Step 1 Install VS Code and install "Compare Folders" extension using above link. # Step 2 unzip/extract/decompress Vuexy Latest Package and Vuexy old package in your desired folder # Step 3 Use compare folders extension and compare both packages for changes to adopt them in your project.
# Access Control (ACL) # Overview Vuexy uses the CASL  (opens new window) package to provide access control. CASL is future-oriented and is more detailed on Access Control. We suggest you read the CASL  (opens new window) documentation to learn how it works. CASL may look complex at first so please make sure you first read their docs carefully and understand the base logic of Access Control to proceed further. # Config You can find CASL configuration in src/configs/acl.ts. We have defined two roles admin & client and their actions in the configuration file. You'll have to update these roles & actions according to your application requirement. const defineRulesFor = (role, subject) => {
  const { can, rules } = new AbilityBuilder(AppAbility)

  if (role === 'admin') {
    can('manage', 'all')
  } else if (role === 'client') {
    can(['read'], 'acl-page')
  } else {
    can(['read', 'create', 'update', 'delete'], subject)
  }

  return rules
}
# Component To define an accessible component use acl method with action & subject properties like shown below. You can also refer full-version/src/pages/acl/index.tsx file for implementation. ¬†¬†¬†¬†const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
# Navigation Define the action & subject properties in navigation file to show/hide the navigation links/groups based on user role. Refer to the example below: ¬†¬†{
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
# Home URL Please update home URL based on yser role in src/pages/index.tsx file. Currently, we have set default URL for client and admin like following:  # How to remove ACL It is quite easy to remove access control from the template. Remove the src/configs/acl.ts file Remove the import type { ACLObj } from 'src/configs/acl' import statement & acl?: ACLObj from next.d.ts file if next.d.ts file is present in your project. Remove the src/@core/components/auth/AclGuard.tsx file Remove the AclGuard wrapper & ACL related imports from src/pages/_app.tsx file. Change following code from: // Code before removing ACL Guard
import { defaultACLObj } from 'src/configs/acl'
import AclGuard from 'src/@core/components/auth/AclGuard'

const aclAbilities = Component.acl ?? defaultACLObj

<AclGuard aclAbilities={aclAbilities} guestGuard={guestGuard}>
  {getLayout(<Component {...pageProps} />)}
</AclGuard>
to // Code after removing ACL Guard
{getLayout(<Component {...pageProps} />)}
 Remove the acl method from all the components. Component from: const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
to const Component = () => <h1>Component</h1>

export default Component
 Remove action & subject properties if defined in your navigation files. Navigation object from: {
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
to {
  path: '/acl',
  icon: 'tabler:shield',
  title: 'Access Control'
}
 In the src/pages/index.tsx file, update Home URL like the following: // Set Home URL based on User Roles
export const getHomeRoute = () => {
  return '/dashboards/analytics'
}

// And call this function like this:
const homeRoute = getHomeRoute()
OR Empty src/pages/index.tsx file and render your Home component like following: const Component = () => <h1>Component</h1>

export default Component
 Remove the ability & ability.can function in all the CanView files in src/layouts/components/acl folder. Replace the following codes in respective files in order to remove ACL functionality.   
# Environment Variables Vuexy comes with support for environment variables, which allows you to use .env to load the environment variables. Tip We recommend you to read the official guide  (opens new window) given by Next.js for using environment variables. # Loading Environment Variables Next.js has built-in support for loading environment variables from .env file into process.env. An example .env.local: DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods  (opens new window) and API routes  (opens new window). For example, using getStaticProps  (opens new window): // pages/index.js
export async function getStaticProps() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS
  })
  // ...
}
# Exposing Environment Variables to the Browser By default environment variables are only available in the Node.js environment, meaning they won't be exposed to the browser. In order to use an environment variable inside a component and to expose a variable to the browser, you have to prefix the variable with NEXT_PUBLIC_. For example: NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk
WARNING Do not store any secrets (such as private API keys or passwords) in the public variables! These environment variables are embedded into the build, meaning anyone can view them by inspecting your app's files. # Private Variables Having access to the NODE_ENV is also useful for performing actions conditionally: if (process.env.NODE_ENV !== 'production') {
  analytics.disable()
}
Read more nextjs official documentation for more info on environment variables from here  (opens new window). # Environment variables used in the template We have use the fake-db and fake-db API calls are not supported to access the environment variables. Hence, we have used NEXT_PUBLIC prefix with our environment variables. You can find the environment variables' file .env.development in the root of the project. The environment variables that we have used in the .env.development file are as follows: NEXT_PUBLIC_JWT_EXPIRATION
NEXT_PUBLIC_JWT_SECRET
NEXT_PUBLIC_JWT_REFRESH_TOKEN_SECRET
Make sure to replace JWT secrets and token with your actual values and it's advisable to remove the NEXT_PUBLIC prefix if you are using the Next.js data fetching method or API routes.
# How to implement server-side menu ? If a user wants to render a server-side menu in the Vertical menu, please refer to this docs. If a user wants to render a server-side menu in the Horizontal menu, please refer to this docs.
# Loaders # Pace Loader (Page Loader) We're using nprogress  (opens new window) as the paceloader (or page loader). If you want to disable it, change the routingLoader property to false in the src/configs/themeConfig.ts file. But if you want to remove the package, follow these steps: Remove nprogress & @types/nprogress packages from the package.json file Remove the following snippet in the src/pages/_app.ts file import NProgress from 'nprogress'

// ** Pace Loader
if (themeConfig.routingLoader) {
  Router.events.on('routeChangeStart', () => {
    NProgress.start()
  })
  Router.events.on('routeChangeError', () => {
    NProgress.done()
  })
  Router.events.on('routeChangeComplete', () => {
    NProgress.done()
  })
}
# Splash Screen (Loader with Logo) If you want to keep the splash screen as it is with your logo, then follow these steps: Make a new file in the src/layouts/components folder Copy the code from the src/@core/components/spinner/index.tsx file and paste it in the file you just made Remove our SVG logo and add your logo (you can add the logo of any format viz. JPEG, PNG, SVG, etc.) Pass your component in the fallback prop with the AuthGuard and GuestGuard components in the src/pages/_app.tsx file. // src/pages/_app.tsx

import UserSpinner from 'src/layouts/components/UserSpinner.tsx'

<GuestGuard fallback={<UserSpinner />}>{children}</GuestGuard>
<AuthGuard fallback={<UserSpinner />}>{children}</AuthGuard>
If you want to change the whole splash screen, then follow these steps: Make your own loader component in the src/layouts/components folder Pass your component in the fallback prop with the AuthGuard and GuestGuard components in the src/pages/_app.tsx file. // src/pages/_app.tsx

import UserSpinner from 'src/layouts/components/UserSpinner.tsx'

<GuestGuard fallback={<UserSpinner />}>{children}</GuestGuard>
<AuthGuard fallback={<UserSpinner />}>{children}</AuthGuard>
You can also pass null instead of a loader if you don't want to show a loader in the splash screen.
# Environment Variables Vuexy comes with support for environment variables, which allows you to use .env to load the environment variables. Tip We recommend you to read the official guide  (opens new window) given by Next.js for using environment variables. # Loading Environment Variables Next.js has built-in support for loading environment variables from .env file into process.env. An example .env.local: DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods  (opens new window) and API routes  (opens new window). For example, using getStaticProps  (opens new window): // pages/index.js
export async function getStaticProps() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS
  })
  // ...
}
# Exposing Environment Variables to the Browser By default environment variables are only available in the Node.js environment, meaning they won't be exposed to the browser. In order to use an environment variable inside a component and to expose a variable to the browser, you have to prefix the variable with NEXT_PUBLIC_. For example: NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk
WARNING Do not store any secrets (such as private API keys or passwords) in the public variables! These environment variables are embedded into the build, meaning anyone can view them by inspecting your app's files. # Private Variables Having access to the NODE_ENV is also useful for performing actions conditionally: if (process.env.NODE_ENV !== 'production') {
  analytics.disable()
}
Read more nextjs official documentation for more info on environment variables from here  (opens new window). # Environment variables used in the template We have use the fake-db and fake-db API calls are not supported to access the environment variables. Hence, we have used NEXT_PUBLIC prefix with our environment variables. You can find the environment variables' file .env.development in the root of the project. The environment variables that we have used in the .env.development file are as follows: NEXT_PUBLIC_JWT_EXPIRATION
NEXT_PUBLIC_JWT_SECRET
NEXT_PUBLIC_JWT_REFRESH_TOKEN_SECRET
Make sure to replace JWT secrets and token with your actual values and it's advisable to remove the NEXT_PUBLIC prefix if you are using the Next.js data fetching method or API routes.
# Internationalization (i18n) # Overview We're using react-i18next  (opens new window) for Internationalization. You can find its configurations in src/configs/i18n.ts file and the locales in public/locales folder in the full version. # Usage Refer to this article to implement the internationalization. # Add i18n WARNING Only for those who are using the starter-kit If you are using the full version, then you don't need to add i18n as it is already available in that version. But if you are using the starter-kit (which is recommended) and want to add i18n, then follow these steps: You need to add these npm packages:
i18next react-i18next i18next-http-backend i18next-browser-languagedetector  Copy src/configs/i18n.ts file from the full version and paste it under the same directory in your project Add import 'src/configs/i18n' import statement in src/pages/_app.tsx file Add your locale files in public/locales folder If you want to translate the navigation menu, then copy the whole code from src/layouts/components/Translations.tsx file from the full version and paste it under the same directory in your project If you want a language dropdown in the appBar to change the current language in the app, then import src/@core/layouts/components/shared-components/LanguageDropdown.tsx file and render LanguageDropdown component in src/layouts/components/vertical/AppBarContent.tsx or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
# Remove i18n WARNING Only for those who are using the full version If you do not want to use i18n, we recommend you start your project with the starter-kit. But if you are using the full version and does not want to use i18n, then follow these steps: You may remove all the packages related to i18n from package.json file if you want to
i18next react-i18next i18next-http-backend i18next-browser-languagedetector Remove src/configs/i18n.ts file Remove import 'src/configs/i18n' import statement from src/pages/_app.tsx file Replace the following code in src/layouts/components/Translations.tsx file  Remove LanguageDropdown file import statement and rendered component from src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
Remove your locale files from public/locales folder # Add / Remove a language Suppose you want to add de (German) language and remove ar (Arabic) language. For this, you need to follow these steps: Remove public/locales/ar.json file and add public/locales/de.json file. You need to keep the format of the file as it is in other locale files Make a new file in src/layouts/components folder and place the following code in this file  Import the src/layouts/components/UserLanguageDropdown.tsx file and render it in the src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file. 
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# How to change Mode [Light / Dark] ? In Modern era most of the user prefer to work in dark mode due to eye strain and long working hours. It's very easy to change the default mode to dark from the ThemeConfig. Please refer our Theme Configurations docs and set mode property from light to dark. Theme Configuration Doc There may be times where you would want to have both light & dark mode in your application and implement some functionalities or styling based on the current mode. To read the current mode please refer following docs: Read Current Mode for Conditional Styling Doc We already provide mode toggle in the Appbar(Navbar) but In case you want to implement mode toggler on your own or make changes in the mode toggler, please follow below documentation: Mode Toggler Doc
# Deployment TIP Read official Next.js docs  (opens new window) to handle deployment smoothly. # Node.js Server Next.js can be deployed to any hosting provider that supports Node.js. Make sure your package.json has the build and start scripts: "scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start"
}
next build builds the production application in the .next folder. After building, next start starts a Node.js server that supports hybrid pages, serving both statically generated and server-side rendered pages. # Static HTML Export Command next export allows you to export your app to static HTML, which can be run standalone without the need of a Node.js server. The exported app supports almost every feature of Next.js, including dynamic routes, prefetching, preloading and dynamic imports. next export works by pre-rendering all pages to HTML. For dynamic routes, your page can export a getStaticPaths function to let the exporter know which HTML pages to generate for that route. By default, next export will generate an out directory, which can be served by any static hosting service or CDN. The choice of your server software isn‚Äôt important either. Since the output of the export command is completely platform-agnostic, there‚Äôs no need to explicitly use Node. WARNING We are using img element instead of nextjs/Image  (opens new window). If you're using nextjs/Image instead of img element then you'll get image optimization error with static HTML export. You'll need a loader to fix this. Read this doc  (opens new window) for more info. # Vercel Deployment Read the this documentation  (opens new window) to deploy your app to vercel. Heads Up! If you are going to deploy your project under a subfolder, please read this FAQ before generating build or exporting your project.
# How to change fonts / typography ? In case you want to add new fonts or change the current font or use multiple fonts, Please refer following doc: How to Add / Change fonts
# Getting Started TIP Get Started with the Starter kit version and copy components from full version We only provide documentation for custom components and customizations made to MUI's components. For MUI components' documentation please visit MUI's official docs  (opens new window). Heads Up! When using Javascript version, please consider respective file paths, we only show ts & tsx file paths for reference code in documentation. e.g. Following is the file path in TypeScript version: src/layouts/UserLayout.tsx and consider looking at following path in JavaScript version: src/layouts/UserLayout.js There can be two possibilities, you are planning to start a new project with our template or trying to add our template into your existing project. # Starting a new project with our template It is always suggested to get started with the minimal setup and we exactly provide that with our starter kit version. Once you unzip the template you will find TypeScript / JavaScript version folder and under that full-version and starter-kit folders. First step should be to verify all the dependencies and clean up all the packages that are not required for your project. # What's the point including all the dependencies with starter kit? Your question is totally valid and legit. To make the experience smoother, we have listed all the dependencies and provided freedom to remove dependencies which are not required in your project. Searching for packages that are required and to install them can be difficult and confusing for new users. Hence, we have included all the packages in the starter-kit. New user can just copy components from full version without worring about packages. # Integrating our template into your existing project Since this is a template and a starter project, it‚Äôs built as the starting point of your project. It cannot be simply installed and used with an existing project like a third party library. Although using our template with any existing project is still possible, it would require extra work to connect everything together. We strongly recommend you to either start your project with Vuexy, or move your project on top of it to have the best experience. # Follow Installation Guide Next, Follow the installation guide once you streamline all the dependencies and make sure you meet all the system requirements mentioned in the installation page to run the project and read all the notices carefully given on the installation page. # Demo Configs You want your local template to look like one of the 6 demos you saw online then please follow demo configs documentation which will help you achieve your goal. # FAQs If you face any difficulties with installation, or has any question on usage of this template like changing colors, fonts, branding etc., then treat yourself by visiting FAQs section. You are most likely to find your answer there. # Search Docs Our template has large documentation and sometime it can be daunting to find what you are looking for in the docs. Fastest way to find anything is to search doc using search input in the Navigation bar. You can write keywords and it will filter out results and come up with the best possible match.
# How to remove Auth from the project Authentication (Auth) is used to check whether a user is logged in or not. Authentication is implemented in both full-version and starter-kit versions. Please refer to this docs if a user wants to remove Authentication completely from the project.
# getLayout TIP We recommend you to go through the Per page Layout Docs of NextJS  (opens new window) to understand how the layout works on any single page in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview If you want to change the default layout for a particular page, you can use the getLayout method with your component. # Blank Layout Here is an example of how to change the layout from default layout to blank layout for any page:  # Blank Layout with AppBar Here is an example of how to change the layout from default layout to blank layout with appBar for any page:  # Custom Layout Refer to the code below to create a blog layout:  Result:  # Change the default page layout Suppose, you want to change the default page layout for all the pages in your project, then follow the below steps: Make a layout as per your requirements in the src/layouts folder (let us assume that you named the file as UserDefaultLayout.tsx) Import the newly created file in the src/pages/_app.tsx file as: import UserDefaultLayout from 'src/layouts/UserDefaultLayout'
Change the getLayout variable from const getLayout = Component.getLayout ?? (page => <UserLayout contentHeightFixed={contentHeightFixed}>{page}</UserLayout>)
to const getLayout = Component.getLayout ?? (page => <UserDefaultLayout>{page}</UserDefaultLayout>)

# Routing Vuexy uses Next.js's file-system based router built on the concept of pages. When a file is added to the src/pages directory, it's automatically available as a route. # Index routes The router will automatically route files named index to the root of the directory. pages/index.tsx ‚Üí / pages/dashboards/index.tsx ‚Üí /blog # Nested routes The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way. pages/dashboards/ecommerce/index.tsx ‚Üí /dashboards/ecommerce # Dynamic route segments Defining routes by using predefined paths is not always enough for complex applications. In Next.js you can add brackets to a page param to create a dynamic route (a.k.a. URL slugs, pretty URLs, and others). To match a dynamic segment you can use the bracket syntax. This allows you to match named parameters. pages/apps/email/[folder].tsx ‚Üí /apps/email/spam pages/apps/email/label/[label].tsx ‚Üí /apps/email/label/company pages/apps/email/[...all].tsx ‚Üí /apps/email/* (/apps/email/view/id/1)
# Deployment TIP Read official Next.js docs  (opens new window) to handle deployment smoothly. # Node.js Server Next.js can be deployed to any hosting provider that supports Node.js. Make sure your package.json has the build and start scripts: "scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start"
}
next build builds the production application in the .next folder. After building, next start starts a Node.js server that supports hybrid pages, serving both statically generated and server-side rendered pages. # Static HTML Export Command next export allows you to export your app to static HTML, which can be run standalone without the need of a Node.js server. The exported app supports almost every feature of Next.js, including dynamic routes, prefetching, preloading and dynamic imports. next export works by pre-rendering all pages to HTML. For dynamic routes, your page can export a getStaticPaths function to let the exporter know which HTML pages to generate for that route. By default, next export will generate an out directory, which can be served by any static hosting service or CDN. The choice of your server software isn‚Äôt important either. Since the output of the export command is completely platform-agnostic, there‚Äôs no need to explicitly use Node. WARNING We are using img element instead of nextjs/Image  (opens new window). If you're using nextjs/Image instead of img element then you'll get image optimization error with static HTML export. You'll need a loader to fix this. Read this doc  (opens new window) for more info. # Vercel Deployment Read the this documentation  (opens new window) to deploy your app to vercel. Heads Up! If you are going to deploy your project under a subfolder, please read this FAQ before generating build or exporting your project.
# Why Next.js image component doesn't work with next export? We haven't used the Next.js image component in our template as it doesn't work with the next export. The reason is that the default Next.js loader is not compatible with the Next.js image optimization API. So when we run the next export command, it throws an error. Please refer to this  (opens new window) docs confirming this issue. It shows the possible ways to solve this issue as well.
# How to Configure local template to look like one of the 6 demos you see online ? When you run the template for the first time your local template will always look like 1st demo you saw from the store. There are 6 demos in total and you may want your local template to look like any of the demos you saw online. To achieve this, we provide a demo-configs folder in the package and you can easily override configs with the help of those demo config files. Please refer to demo configs doc to change the demo config and make it look like you wanted.
# RTL # Change to RTL We provide Left to Right (LTR) by default but you can easily change it to Right to Left (RTL). To change the whole template to RTL, you need to go to the src/configs/themeConfig.ts file and change the direction property from ltr to rtl. # RTL Toggler You can also make a direction toggler which toggle between LTR and RTL directions. Look at the following code to make one:  # Get current direction You might need to render some code conditionally based on the current direction of the template. You can write the following code to do so: ¬†¬†¬†import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  if (settings.direction === 'rtl') {
    return (
      {/* Some code */}
    )
  } else {
    return (
      {/* Some other code */}
    )
  }
}

export default SomeComponent
If you need to style something conditionally based on the current direction of the template, do the following: ¬†¬†¬†import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return (
    <Box sx={{ backgroundColor: settings.direction === 'rtl' ? 'red' : 'blue' }}>
      ...
    </Box>
  )
}

export default SomeComponent
# Remove RTL from the template To remove the RTL from the whole template, follow these steps: Remove all the plugins related to RTL. View all the dependencies of RTL in this section Replace the following code in the src/layouts/components/Direction.tsx file: 
# Layout Types TIP We recommend you to go through the Layout Docs of NextJS  (opens new window) to understand how the layout works in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview We provide four types of layouts: Vertical Layout, Horizontal Layout, Blank Layout and Blank Layout with AppBar. Each of them is explained in detail. # Vertical Layout This is the default layout. With this layout, you will get the following layout components: Navigation Menu (left sidebar) Navbar (at top of the page) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Vertical Layout looks like this:  # Horizontal Layout You can make this your default layout. With this layout, you will get the following layout components: Navbar (at top of the page) Navigation Menu (on top of the page below the Navbar) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Horizontal Layout looks like this:  # Blank Layout This is useful if you want to create pages without any other content and where you don't need a navbar, navigation menu and footer. For example, an Authentication page. This is a blank page where you can create everything from scratch. Blank Layout in Login page looks like this:  # Blank Layout with AppBar This is useful if you want to create pages where you don't need a navigation menu and footer. For example, an Authentication page. With this layout, you will get a navbar (or AppBar) on top of the page. AppBar is explained here. Blank Layout with AppBar in Login page looks like this: 
# How to change Direction ? Great thing is our template comes with RTL(Right to Left) support. There can be two possibilities, If you want to set default direction to RTL Please refer our configuration docs and set direction value from ltr to rtl Theme Configuration Doc And, in case you want to implement toggle button functionality which can toggle direction, refer below doc: Toggle Direction Doc
# Installation Vuexy is built using Create Next App  (opens new window). Create Next App sets up everything automatically for you. # Guide First of all make sure you have installed Node  (opens new window) and npm  (opens new window) / yarn  (opens new window) TIP Yarn package manager is recommended Requirements Please make sure you use the node‚Äôs LTS version which is recommended by the official node site and not the one with the latest features or previous versions. Our project is not tested to work with other Node versions. Important! Before installing the node_modules, make sure you have files starting with a dot(.eslintrc, .env etc..). It mostly happens when hidden files are not enabled on your machine and you try to copy our template at some other place on your system. After downloading zip, copy this zip to your desired location and then unzip it. Do not unzip first and then copy files to another location, it may not be able to run the template due to missing hidden files not copied over. In the uncompressed folder, you will find the typescript-version and javascript-version folders which contains the full-version & starter-kit folders. Open the one you want to get started with in your code editor. Run below command in console:  After installing the modules run your project with following command:  You will find following output after running above command in console:  Congratulations!! You have successfully run the project. Visit http://localhost:3000/  (opens new window) to check it in your browser. NOTE Your network URL might not have same URL as screenshot and that is completely fine. It depends on your network.
# useSettings Hook # Overview useSettings hook is created to get the values from the Settings context and set the values to the Settings context. useSettings hook must be used inside a functional component. The values that are accessible in the useSettings hook is mentioned in the Settings Context. # Read values from Settings Context Below is the example of how to get template skin. You can get any other values by replacing skin with any other property that is available in the Settings Context. import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return <Box sx={{ boxShadow: theme => theme.shadows[settings.skin === 'bordered' ? 0 : 7] }}>...</Box>
}

export default SomeComponent
# Update single value in Settings Context Below is the example of how to change template mode, i.e. Light or Dark mode. You can change any other values by replacing mode with any other property that is available in the Settings Context.  # Update multiple values in Settings Context Below is the example of how to change content width (i.e. Full or Container width) and template layout (i.e. Vertical or Horizontal layout). You can change any other values that are available in the Settings Context. 
# Getting Started TIP Get Started with the Starter kit version and copy components from full version We only provide documentation for custom components and customizations made to MUI's components. For MUI components' documentation please visit MUI's official docs  (opens new window). Heads Up! When using Javascript version, please consider respective file paths, we only show ts & tsx file paths for reference code in documentation. e.g. Following is the file path in TypeScript version: src/layouts/UserLayout.tsx and consider looking at following path in JavaScript version: src/layouts/UserLayout.js There can be two possibilities, you are planning to start a new project with our template or trying to add our template into your existing project. # Starting a new project with our template It is always suggested to get started with the minimal setup and we exactly provide that with our starter kit version. Once you unzip the template you will find TypeScript / JavaScript version folder and under that full-version and starter-kit folders. First step should be to verify all the dependencies and clean up all the packages that are not required for your project. # What's the point including all the dependencies with starter kit? Your question is totally valid and legit. To make the experience smoother, we have listed all the dependencies and provided freedom to remove dependencies which are not required in your project. Searching for packages that are required and to install them can be difficult and confusing for new users. Hence, we have included all the packages in the starter-kit. New user can just copy components from full version without worring about packages. # Integrating our template into your existing project Since this is a template and a starter project, it‚Äôs built as the starting point of your project. It cannot be simply installed and used with an existing project like a third party library. Although using our template with any existing project is still possible, it would require extra work to connect everything together. We strongly recommend you to either start your project with Vuexy, or move your project on top of it to have the best experience. # Follow Installation Guide Next, Follow the installation guide once you streamline all the dependencies and make sure you meet all the system requirements mentioned in the installation page to run the project and read all the notices carefully given on the installation page. # Demo Configs You want your local template to look like one of the 6 demos you saw online then please follow demo configs documentation which will help you achieve your goal. # FAQs If you face any difficulties with installation, or has any question on usage of this template like changing colors, fonts, branding etc., then treat yourself by visiting FAQs section. You are most likely to find your answer there. # Search Docs Our template has large documentation and sometime it can be daunting to find what you are looking for in the docs. Fastest way to find anything is to search doc using search input in the Navigation bar. You can write keywords and it will filter out results and come up with the best possible match.
# getLayout TIP We recommend you to go through the Per page Layout Docs of NextJS  (opens new window) to understand how the layout works on any single page in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview If you want to change the default layout for a particular page, you can use the getLayout method with your component. # Blank Layout Here is an example of how to change the layout from default layout to blank layout for any page:  # Blank Layout with AppBar Here is an example of how to change the layout from default layout to blank layout with appBar for any page:  # Custom Layout Refer to the code below to create a blog layout:  Result:  # Change the default page layout Suppose, you want to change the default page layout for all the pages in your project, then follow the below steps: Make a layout as per your requirements in the src/layouts folder (let us assume that you named the file as UserDefaultLayout.tsx) Import the newly created file in the src/pages/_app.tsx file as: import UserDefaultLayout from 'src/layouts/UserDefaultLayout'
Change the getLayout variable from const getLayout = Component.getLayout ?? (page => <UserLayout contentHeightFixed={contentHeightFixed}>{page}</UserLayout>)
to const getLayout = Component.getLayout ?? (page => <UserDefaultLayout>{page}</UserDefaultLayout>)

# Access Control (ACL) # Overview Vuexy uses the CASL  (opens new window) package to provide access control. CASL is future-oriented and is more detailed on Access Control. We suggest you read the CASL  (opens new window) documentation to learn how it works. CASL may look complex at first so please make sure you first read their docs carefully and understand the base logic of Access Control to proceed further. # Config You can find CASL configuration in src/configs/acl.ts. We have defined two roles admin & client and their actions in the configuration file. You'll have to update these roles & actions according to your application requirement. const defineRulesFor = (role, subject) => {
  const { can, rules } = new AbilityBuilder(AppAbility)

  if (role === 'admin') {
    can('manage', 'all')
  } else if (role === 'client') {
    can(['read'], 'acl-page')
  } else {
    can(['read', 'create', 'update', 'delete'], subject)
  }

  return rules
}
# Component To define an accessible component use acl method with action & subject properties like shown below. You can also refer full-version/src/pages/acl/index.tsx file for implementation. ¬†¬†¬†¬†const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
# Navigation Define the action & subject properties in navigation file to show/hide the navigation links/groups based on user role. Refer to the example below: ¬†¬†{
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
# Home URL Please update home URL based on yser role in src/pages/index.tsx file. Currently, we have set default URL for client and admin like following:  # How to remove ACL It is quite easy to remove access control from the template. Remove the src/configs/acl.ts file Remove the import type { ACLObj } from 'src/configs/acl' import statement & acl?: ACLObj from next.d.ts file if next.d.ts file is present in your project. Remove the src/@core/components/auth/AclGuard.tsx file Remove the AclGuard wrapper & ACL related imports from src/pages/_app.tsx file. Change following code from: // Code before removing ACL Guard
import { defaultACLObj } from 'src/configs/acl'
import AclGuard from 'src/@core/components/auth/AclGuard'

const aclAbilities = Component.acl ?? defaultACLObj

<AclGuard aclAbilities={aclAbilities} guestGuard={guestGuard}>
  {getLayout(<Component {...pageProps} />)}
</AclGuard>
to // Code after removing ACL Guard
{getLayout(<Component {...pageProps} />)}
 Remove the acl method from all the components. Component from: const Component = () => <h1>Component</h1>

Component.acl = {
  action: 'read',
  subject: 'component'
}

export default Component
to const Component = () => <h1>Component</h1>

export default Component
 Remove action & subject properties if defined in your navigation files. Navigation object from: {
  path: '/acl',
  action: 'read',
  subject: 'acl-page',
  icon: 'tabler:shield',
  title: 'Access Control'
}
to {
  path: '/acl',
  icon: 'tabler:shield',
  title: 'Access Control'
}
 In the src/pages/index.tsx file, update Home URL like the following: // Set Home URL based on User Roles
export const getHomeRoute = () => {
  return '/dashboards/analytics'
}

// And call this function like this:
const homeRoute = getHomeRoute()
OR Empty src/pages/index.tsx file and render your Home component like following: const Component = () => <h1>Component</h1>

export default Component
 Remove the ability & ability.can function in all the CanView files in src/layouts/components/acl folder. Replace the following codes in respective files in order to remove ACL functionality.   
# How to remove Fake DB and use Real API Vuexy uses axios-mock-adapter  (opens new window) for mocking API calls. This makes our template API ready üòç and more easier for you to communicate with your backend. However, you won't need fake-db if you are using real APIs. In this case please follow below steps to remove fake-db from template. Remove @fake-db folder from src directory Remove fake-db import from src/pages/_app.tsx file // File: src/pages/_app.tsx

-  // ** Fake-DB Import
-  import 'src/@fake-db'
Finally we don't need axios-mock-adapter in our package any more so remove it from the package.json file {
  dependencies: {
-    "axios-mock-adapter": "...",
  }
}
This will remove fake-db completely from your package. üéâ NOTE Now all (fake) API calls will result in 404 error until you replace them with your real API endpoints.
# How to override component's styling ? Please refer to MUI Docs  (opens new window) if a user is to override MUI's components. We have created some components which will provide styles to some components. A user may go through the docs to understand how to use these styled components. If a user wants to override those styled components, please refer to this docs. If a user wants to override the styles of React Hot Toast, please refer to this docs.
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# RTL # Change to RTL We provide Left to Right (LTR) by default but you can easily change it to Right to Left (RTL). To change the whole template to RTL, you need to go to the src/configs/themeConfig.ts file and change the direction property from ltr to rtl. # RTL Toggler You can also make a direction toggler which toggle between LTR and RTL directions. Look at the following code to make one:  # Get current direction You might need to render some code conditionally based on the current direction of the template. You can write the following code to do so: ¬†¬†¬†import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  if (settings.direction === 'rtl') {
    return (
      {/* Some code */}
    )
  } else {
    return (
      {/* Some other code */}
    )
  }
}

export default SomeComponent
If you need to style something conditionally based on the current direction of the template, do the following: ¬†¬†¬†import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return (
    <Box sx={{ backgroundColor: settings.direction === 'rtl' ? 'red' : 'blue' }}>
      ...
    </Box>
  )
}

export default SomeComponent
# Remove RTL from the template To remove the RTL from the whole template, follow these steps: Remove all the plugins related to RTL. View all the dependencies of RTL in this section Replace the following code in the src/layouts/components/Direction.tsx file: 
# Avatar # Overview Please visit MUI Avatar Docs  (opens new window) for a proper explanation of the Avatar component. Avatar component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI avatar props. # Avatar Colors Use the color prop so you don't have to use the sx prop and write the styles inside it. Use the MUI colors primary | secondary | success | error | warning | info to create colored avatars. Here is the example of how to use the colors mentioned above: import Icon from 'src/@core/components/icon'
import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar color='primary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='secondary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='success'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='error'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='warning'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='info'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
Result:  # Avatar Skins There are three skins avatar skins filled | light | light-static. Please Note: The difference between light & light-static can only be seen in the Dark layout. Here is the example of how to use the skins mentioned above: import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar skin='filled'>N</CustomAvatar> // OR <CustomAvatar>N</CustomAvatar>
<CustomAvatar skin='light' color='error'>OP</CustomAvatar>
<CustomAvatar skin='light-static' color='error'>AB</CustomAvatar>
Result:  # Props Prop Type Default Required Description skin filled, light, light-static filled No Skin of the avatar color primary, secondary, success, error, warning, info primary No Background color of the avatar
# Can I remove Next.js? Next.js  (opens new window) is a react framework which gives you the best developer experience with all the features you need for production: hybrid static & server-side rendering, TypeScript support, smart bundling, route pre-fetching, your custom webpack, etc. Please refer following articles which should convince you to start your next project on Next.js rather than on plain React. It does not have a huge learning curve and it will benefit you in many ways: Create React App (CRA) vs Next.js  (opens new window) Next.js Benefits  (opens new window) You can read Next.js docs here  (opens new window). This template is created with Next.js as the base and thus, Next.js cannot be removed from the template.
# Installation errors Causes of yarn install or npm install issues can be due to various things which include: Missing or inappropriate dependencies like node or some other environmental issues Dependency resolved by package manager (yarn/npm) conflicts with other installed dependency The dependency of the package we use have an internal issue or that dependency has some issue with your environment Package or dependency of the package requires some additional step or configuration to work in your environment Downloaded package is broken or is tampered with. To resolve such installation issues: Try using yarn if possible (recommended) Please try downloading the fresh package/zip and performing the installation again Please make sure you are using the LTS version of node which is recommended and not one with the latest features Try running the yarn cache clean or npm cache clean command. After following the steps explained above, if you are still getting any errors, please raise support at our support portal with the below details: Your OS information, Node version, yarn/npm version, Template/Package version Mention if you can run a fresh react project using create-next-app without our template Attach log file of the error you are getting in your console (provide full log) Mention which command you are running Mention if you were able to run our template on one machine and not on another.
# Theme Configurations # Overview To configure your template, we will be using the src/configs/themeConfig.ts file, which has all the template configurations listed with their valid values. Just change the configurations as per your requirement and you are done. If you are looking to match up with one of our demos, then please read demo configs doc. Important Make sure you clear the browser's local storage in order to see the config changes in the template. Refer: How to clear local storage?  (opens new window) # Properties Following are the properties with their values that we have used in the theme:  # beforeVerticalNavMenuContentPosition If the value is set to static, then the content will get scrolled along with the vertical navigation. If the value is set to fixed, then the content will not get scrolled along with the vertical navigation. # beforeVerticalNavMenuContentPosition: 'static'   # beforeVerticalNavMenuContentPosition: 'fixed'   # afterVerticalNavMenuContentPosition If the value is set to static, then the content will get scrolled along with the vertical navigation. If the value is set to fixed, then the content will not get scrolled along with the vertical navigation. # afterVerticalNavMenuContentPosition: 'static'   # afterVerticalNavMenuContentPosition: 'fixed'   # Property Options Following is the table of all the properties and their possible values that are available in the theme configurations: Properties Values Description templateName string Name of the template, project or company layout vertical, horizontal Set Vertical or Horizontal layout for the template mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction skin default, bordered Change template skin contentWidth full, boxed Full or container width of AppBar, Content and Footer footer fixed, static, hidden Change footer position routingLoader true, false Loader on top of the app on route change navHidden true, false If true, the navigation menu is hidden menuTextTruncate true, false If true, text truncate in the navigation menu is enabled navSubItemIcon string Change icon for the sub menus in the navigation menu verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu navCollapsed true, false If true, the vertical navigation menu is collapsed navigationSize number Width of navigation menu when menu is not collapsed collapsedNavigationSize number Width of navigation menu when menu is collapsed afterVerticalNavMenuContentPosition fixed, static Position of the content which is added after the vertical navigation menu beforeVerticalNavMenuContentPosition fixed, static Position of the content which is added before the vertical navigation menu horizontalMenuToggle click, hover Set behavior of menu group in the horizontal navigation menu horizontalMenuAnimation true, false If true, animation is enabled for the horizontal navigation menu appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity responsiveFontSizes true, false If true, responsive font sizes are enabled disableRipple true, false If true, the Ripple effect is disabled disableCustomizer true, false If true, customizer is disabled as right sidebar to configure in live app toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Set default toast position in the template
# Getting Started TIP Get Started with the Starter kit version and copy components from full version We only provide documentation for custom components and customizations made to MUI's components. For MUI components' documentation please visit MUI's official docs  (opens new window). Heads Up! When using Javascript version, please consider respective file paths, we only show ts & tsx file paths for reference code in documentation. e.g. Following is the file path in TypeScript version: src/layouts/UserLayout.tsx and consider looking at following path in JavaScript version: src/layouts/UserLayout.js There can be two possibilities, you are planning to start a new project with our template or trying to add our template into your existing project. # Starting a new project with our template It is always suggested to get started with the minimal setup and we exactly provide that with our starter kit version. Once you unzip the template you will find TypeScript / JavaScript version folder and under that full-version and starter-kit folders. First step should be to verify all the dependencies and clean up all the packages that are not required for your project. # What's the point including all the dependencies with starter kit? Your question is totally valid and legit. To make the experience smoother, we have listed all the dependencies and provided freedom to remove dependencies which are not required in your project. Searching for packages that are required and to install them can be difficult and confusing for new users. Hence, we have included all the packages in the starter-kit. New user can just copy components from full version without worring about packages. # Integrating our template into your existing project Since this is a template and a starter project, it‚Äôs built as the starting point of your project. It cannot be simply installed and used with an existing project like a third party library. Although using our template with any existing project is still possible, it would require extra work to connect everything together. We strongly recommend you to either start your project with Vuexy, or move your project on top of it to have the best experience. # Follow Installation Guide Next, Follow the installation guide once you streamline all the dependencies and make sure you meet all the system requirements mentioned in the installation page to run the project and read all the notices carefully given on the installation page. # Demo Configs You want your local template to look like one of the 6 demos you saw online then please follow demo configs documentation which will help you achieve your goal. # FAQs If you face any difficulties with installation, or has any question on usage of this template like changing colors, fonts, branding etc., then treat yourself by visiting FAQs section. You are most likely to find your answer there. # Search Docs Our template has large documentation and sometime it can be daunting to find what you are looking for in the docs. Fastest way to find anything is to search doc using search input in the Navigation bar. You can write keywords and it will filter out results and come up with the best possible match.
# Starter-kit vs Full Package # Starter-kit Starter-kit is a minimal template from where you can start your project quickly instead of removing stuff that isn't needed. Below are quick notes on the starter-kit: No i18n Simple Navbar Four pages (Two sample pages + 404 + Login) Customizer (disabled) No Axios Use it if you don't want to clutter your project with extra libs which aren't required. You still need to streamline all the dependencies from package.json file. We have taken care of cleaning up unnecessary code . You can just copy components from full version into the starter kit and it should work üòç. TIP Use starter-kit to provide reproduction steps if you raise any technical issue on GitHub. # Full Package This setup has all the things which you can see in the live demo except for that red Buy Now button üòÖ. With this, you have to remove things that you don't use or replace them with your content. # Conclusion According to us, starter-kit is easy to get started with minimal setup and our folder and code structure will help you add libs support in starter-kit more easily than ever. Still, if your project becomes easy with the full package, go for it. WARNING Please make sure to copy required images from the full version if you copy content from the full version to the starter-kit.
# Layout Types TIP We recommend you to go through the Layout Docs of NextJS  (opens new window) to understand how the layout works in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview We provide four types of layouts: Vertical Layout, Horizontal Layout, Blank Layout and Blank Layout with AppBar. Each of them is explained in detail. # Vertical Layout This is the default layout. With this layout, you will get the following layout components: Navigation Menu (left sidebar) Navbar (at top of the page) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Vertical Layout looks like this:  # Horizontal Layout You can make this your default layout. With this layout, you will get the following layout components: Navbar (at top of the page) Navigation Menu (on top of the page below the Navbar) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Horizontal Layout looks like this:  # Blank Layout This is useful if you want to create pages without any other content and where you don't need a navbar, navigation menu and footer. For example, an Authentication page. This is a blank page where you can create everything from scratch. Blank Layout in Login page looks like this:  # Blank Layout with AppBar This is useful if you want to create pages where you don't need a navigation menu and footer. For example, an Authentication page. With this layout, you will get a navbar (or AppBar) on top of the page. AppBar is explained here. Blank Layout with AppBar in Login page looks like this: 
# Theme Configurations # Overview To configure your template, we will be using the src/configs/themeConfig.ts file, which has all the template configurations listed with their valid values. Just change the configurations as per your requirement and you are done. If you are looking to match up with one of our demos, then please read demo configs doc. Important Make sure you clear the browser's local storage in order to see the config changes in the template. Refer: How to clear local storage?  (opens new window) # Properties Following are the properties with their values that we have used in the theme:  # beforeVerticalNavMenuContentPosition If the value is set to static, then the content will get scrolled along with the vertical navigation. If the value is set to fixed, then the content will not get scrolled along with the vertical navigation. # beforeVerticalNavMenuContentPosition: 'static'   # beforeVerticalNavMenuContentPosition: 'fixed'   # afterVerticalNavMenuContentPosition If the value is set to static, then the content will get scrolled along with the vertical navigation. If the value is set to fixed, then the content will not get scrolled along with the vertical navigation. # afterVerticalNavMenuContentPosition: 'static'   # afterVerticalNavMenuContentPosition: 'fixed'   # Property Options Following is the table of all the properties and their possible values that are available in the theme configurations: Properties Values Description templateName string Name of the template, project or company layout vertical, horizontal Set Vertical or Horizontal layout for the template mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction skin default, bordered Change template skin contentWidth full, boxed Full or container width of AppBar, Content and Footer footer fixed, static, hidden Change footer position routingLoader true, false Loader on top of the app on route change navHidden true, false If true, the navigation menu is hidden menuTextTruncate true, false If true, text truncate in the navigation menu is enabled navSubItemIcon string Change icon for the sub menus in the navigation menu verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu navCollapsed true, false If true, the vertical navigation menu is collapsed navigationSize number Width of navigation menu when menu is not collapsed collapsedNavigationSize number Width of navigation menu when menu is collapsed afterVerticalNavMenuContentPosition fixed, static Position of the content which is added after the vertical navigation menu beforeVerticalNavMenuContentPosition fixed, static Position of the content which is added before the vertical navigation menu horizontalMenuToggle click, hover Set behavior of menu group in the horizontal navigation menu horizontalMenuAnimation true, false If true, animation is enabled for the horizontal navigation menu appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity responsiveFontSizes true, false If true, responsive font sizes are enabled disableRipple true, false If true, the Ripple effect is disabled disableCustomizer true, false If true, customizer is disabled as right sidebar to configure in live app toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Set default toast position in the template
# Page Specific Settings If you want to override specific settings for specific page only, you can do that as well. # Usage To change a setting for a specific page, use setConfig method and return an object with your settings like below: const AnalyticsDashboard = () => <h1>Analytics Dashboard</h1>

AnalyticsDashboard.setConfig = () => {
  return {
    mode: 'dark'
    ...
  }
}

export default AnalyticsDashboard
Note You can override any config property at page level. Please refer Theme Configurations doc for each configurable property. Important It is not advisable to override layout or rtl  property for a specific page, they should be set only globally. Overriding them at page level will throw a memory leak error.
# How to change screen size to hide menu ? The main question is what will happen to the navigation menu in screen size smaller than desktop and laptop. We hide the navigation menu inside a drawer which would be accessible from the Hamburger menu icon in the navbar. Currently, we hide the navigation menu below MUI's lg breakpoint. A user has the freedom to change the breakpoint from which the user wants to hide the navigation menu. Please refer to this docs to change the breakpoint in the Vertical layout. Please refer to this docs to change the breakpoint in the Horizontal layout.
# Why app runs slow in local? There are three main reasons why the app runs slow in your local system: getStaticProps has about 2-3 seconds of redundant overhead during development. Please refer this issue  (opens new window) confirming the same. In case you replace getStaticProps with getServerSideProps you can resolve this issue but that won't be the case always, as you may not need server side props always. Some components of MUI are very complex and thus it takes some time to render those components on your local system. MUI components use sx prop and styled function which are internally styling the components using emotion  (opens new window). When emotion is used, all the components take a little bit more time to render than normal. You may refer this MUI discussion  (opens new window) for detailed information on why MUI v5 is very slow. When your app is running on your server or your site is live, you will not face this issue. It will run normally on the server.
# FakeDB Vuexy is built using FakeDB to mock the real life application functionalities. # Overview Vuexy uses axios-mock-adapter  (opens new window) to simulate the server calls. All of the server calls are located in src/@fake-db. # Setup If you're using the starter-kit you'll have to manually setup the fake-db. First create a folder with name fake-db and create a mock.ts file inside it. Initialize the axios-mock-adapter in mock.ts file. import axios from 'axios'
import MockAdapter from 'axios-mock-adapter'

const mock = new MockAdapter(axios)

export default mock
 Create a index.ts file in fake-db folder & add the following: import mock from './mock'

mock.onAny().passThrough()
 To initialize your fake data create a ts file in fake-db folder. Import mock and use it like following: import mock from '../mock'

const data = [{...}]

mock.onGet('/url/get-data').reply(config => {
  return [200, data]
})
 Import the above created file in fake-db/index.ts: import mock from './mock'

import './FILE_WITH_DATA'

mock.onAny().passThrough()
 Import your fake-db/index.ts in src/pages/_app_.ts to be able to get your data in your app. Finally, use axios to fetch your data from fake-db import { useState, useEffect } from 'react'

import axios from 'axios'

const Component = () => {
  const [data, setData] = useState([])

  useEffect(() => {
    axios.get('/url/get-data').then(response => setData(response.data))
  }, [])

  return <h1>Component</h1>
}
WARNING We have used the fake-db for demo purposes only. fake-db will not work for the real life applications.
# Routing Vuexy uses Next.js's file-system based router built on the concept of pages. When a file is added to the src/pages directory, it's automatically available as a route. # Index routes The router will automatically route files named index to the root of the directory. pages/index.tsx ‚Üí / pages/dashboards/index.tsx ‚Üí /blog # Nested routes The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way. pages/dashboards/ecommerce/index.tsx ‚Üí /dashboards/ecommerce # Dynamic route segments Defining routes by using predefined paths is not always enough for complex applications. In Next.js you can add brackets to a page param to create a dynamic route (a.k.a. URL slugs, pretty URLs, and others). To match a dynamic segment you can use the bracket syntax. This allows you to match named parameters. pages/apps/email/[folder].tsx ‚Üí /apps/email/spam pages/apps/email/label/[label].tsx ‚Üí /apps/email/label/company pages/apps/email/[...all].tsx ‚Üí /apps/email/* (/apps/email/view/id/1)
# Installation warnings You might get some warnings while running yarn install or npm install like below:  The warnings you are receiving while installing is from library/packages we use. We always keep our packages up to date when we make a major release. However, the writer of that package may have used an older dependency that is no longer maintained for backward compatibility or any other code related issue. But, that's not an issue. Those packages will work fine with our template. Also, check if you're missing files staring with a dot(.eslintrc.json) Even if you like to try, you can install this packages in fresh React project without our template and you will get the same.
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# useSettings Hook # Overview useSettings hook is created to get the values from the Settings context and set the values to the Settings context. useSettings hook must be used inside a functional component. The values that are accessible in the useSettings hook is mentioned in the Settings Context. # Read values from Settings Context Below is the example of how to get template skin. You can get any other values by replacing skin with any other property that is available in the Settings Context. import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return <Box sx={{ boxShadow: theme => theme.shadows[settings.skin === 'bordered' ? 0 : 7] }}>...</Box>
}

export default SomeComponent
# Update single value in Settings Context Below is the example of how to change template mode, i.e. Light or Dark mode. You can change any other values by replacing mode with any other property that is available in the Settings Context.  # Update multiple values in Settings Context Below is the example of how to change content width (i.e. Full or Container width) and template layout (i.e. Vertical or Horizontal layout). You can change any other values that are available in the Settings Context. 
# Layout Types TIP We recommend you to go through the Layout Docs of NextJS  (opens new window) to understand how the layout works in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview We provide four types of layouts: Vertical Layout, Horizontal Layout, Blank Layout and Blank Layout with AppBar. Each of them is explained in detail. # Vertical Layout This is the default layout. With this layout, you will get the following layout components: Navigation Menu (left sidebar) Navbar (at top of the page) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Vertical Layout looks like this:  # Horizontal Layout You can make this your default layout. With this layout, you will get the following layout components: Navbar (at top of the page) Navigation Menu (on top of the page below the Navbar) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Horizontal Layout looks like this:  # Blank Layout This is useful if you want to create pages without any other content and where you don't need a navbar, navigation menu and footer. For example, an Authentication page. This is a blank page where you can create everything from scratch. Blank Layout in Login page looks like this:  # Blank Layout with AppBar This is useful if you want to create pages where you don't need a navigation menu and footer. For example, an Authentication page. With this layout, you will get a navbar (or AppBar) on top of the page. AppBar is explained here. Blank Layout with AppBar in Login page looks like this: 
# How to override / remove splash screen and page loader ? A splash screen is a screen that is visible at the first time of launching or refreshing any page or project. Please refer to this docs if a user wants to override the splash screen. A page loader is a loader that is visible when a route is changed (or when someone goes from one page to another). Please refer to this docs if a user wants to override the page loader.
# How to enable / disable responsive font ? We have enabled the responsive fonts by default. If a user wants to disable the responsive fonts, then go to the src/configs/themeConfig.ts file and change the value of the responsiveFontSizes property to false. The user may go to the ThemeConfig docs to look at the other properties.
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# Internationalization (i18n) # Overview We're using react-i18next  (opens new window) for Internationalization. You can find its configurations in src/configs/i18n.ts file and the locales in public/locales folder in the full version. # Usage Refer to this article to implement the internationalization. # Add i18n WARNING Only for those who are using the starter-kit If you are using the full version, then you don't need to add i18n as it is already available in that version. But if you are using the starter-kit (which is recommended) and want to add i18n, then follow these steps: You need to add these npm packages:
i18next react-i18next i18next-http-backend i18next-browser-languagedetector  Copy src/configs/i18n.ts file from the full version and paste it under the same directory in your project Add import 'src/configs/i18n' import statement in src/pages/_app.tsx file Add your locale files in public/locales folder If you want to translate the navigation menu, then copy the whole code from src/layouts/components/Translations.tsx file from the full version and paste it under the same directory in your project If you want a language dropdown in the appBar to change the current language in the app, then import src/@core/layouts/components/shared-components/LanguageDropdown.tsx file and render LanguageDropdown component in src/layouts/components/vertical/AppBarContent.tsx or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
# Remove i18n WARNING Only for those who are using the full version If you do not want to use i18n, we recommend you start your project with the starter-kit. But if you are using the full version and does not want to use i18n, then follow these steps: You may remove all the packages related to i18n from package.json file if you want to
i18next react-i18next i18next-http-backend i18next-browser-languagedetector Remove src/configs/i18n.ts file Remove import 'src/configs/i18n' import statement from src/pages/_app.tsx file Replace the following code in src/layouts/components/Translations.tsx file  Remove LanguageDropdown file import statement and rendered component from src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file <LanguageDropdown settings={settings} saveSettings={saveSettings} />
Remove your locale files from public/locales folder # Add / Remove a language Suppose you want to add de (German) language and remove ar (Arabic) language. For this, you need to follow these steps: Remove public/locales/ar.json file and add public/locales/de.json file. You need to keep the format of the file as it is in other locale files Make a new file in src/layouts/components folder and place the following code in this file  Import the src/layouts/components/UserLanguageDropdown.tsx file and render it in the src/layouts/components/vertical/AppBarContent.tsx and/or src/layouts/components/horizontal/AppBarContent.tsx file. 
# How to override custom components ? If a user wants to override the custom components that we provide in the src/@core/components folder, then please refer to this docs.
# How to Migrate to the New Design? It is not feasible to migrate from the old design to the new design due to the following reasons: Folder structure has been changed Removed Vite & Reactstrap and introduced Next.js  (opens new window) & Material UI  (opens new window) (based on Material Design  (opens new window))
# Why images are missing on deployment ? The reason behind the missing images on deployment is may be that you are deploying the project in a sub-folder. In this case, please consider following this article  (opens new window) suggested by NextJS. Let's consider you are deploying your project under docs folder. So your basePath will look like basePath: '/docs' and you will need to add the basePath in front of src. For example, using /docs/me.png will properly serve your image when basePath is set to /docs. When using next/image consider following: import Image from 'next/image'

function Home() {
  return (
    <>
      <h1>My Homepage</h1>
      <Image src='/docs/me.png' alt='Picture of the author' width={500} height={500} />
      <p>Welcome to my homepage!</p>
    </>
  )
}

export default Home
When using <img> tag to serve images consider following: function Home() {
  return (
    <>
      <h1>My Homepage</h1>
      <img src='/docs/me.png' alt='Picture of the author' />
      <p>Welcome to my homepage!</p>
    </>
  )
}

export default Home

# Layout Types TIP We recommend you to go through the Layout Docs of NextJS  (opens new window) to understand how the layout works in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview We provide four types of layouts: Vertical Layout, Horizontal Layout, Blank Layout and Blank Layout with AppBar. Each of them is explained in detail. # Vertical Layout This is the default layout. With this layout, you will get the following layout components: Navigation Menu (left sidebar) Navbar (at top of the page) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Vertical Layout looks like this:  # Horizontal Layout You can make this your default layout. With this layout, you will get the following layout components: Navbar (at top of the page) Navigation Menu (on top of the page below the Navbar) Footer (at bottom of the page) Each layout component are explained here. All of the above layout components are configurable. You can customize any or all layout components using themeConfig to get your desired layout. Horizontal Layout looks like this:  # Blank Layout This is useful if you want to create pages without any other content and where you don't need a navbar, navigation menu and footer. For example, an Authentication page. This is a blank page where you can create everything from scratch. Blank Layout in Login page looks like this:  # Blank Layout with AppBar This is useful if you want to create pages where you don't need a navigation menu and footer. For example, an Authentication page. With this layout, you will get a navbar (or AppBar) on top of the page. AppBar is explained here. Blank Layout with AppBar in Login page looks like this: 
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# How to remove ACL from the project Access Control (ACL) is used to define which users have access to which pages/sections. ACL is implemented in both full-version and starter-kit versions. Please refer to this docs if a user wants to remove ACL completely from the project.
# Styled Components # Overview These are the styles available in the src/@core/styles folder: MUI Stepper Fullcalendar Keen Slider React Apexcharts CleaveJs React Credit Cards React Datepicker React Draft Wysiwyg React Dropzone React Hot Toast Recharts TIP If you do not want to use these styles, then render your component directly. This will apply the default styles provided by MUI and/or third-party plugins. # Usage You need to import styles as a component and wrap them around your components. Let us take an example of React Datepicker: import DatePicker from 'react-datepicker'
import DatePickerWrapper from 'src/@core/styles/libs/react-datepicker'

<DatePickerWrapper>
  <DatePicker
    {...} // all of your props
  />
</DatePickerWrapper>
If you do not want to use these styles: import DatePicker from 'react-datepicker'

<DatePicker
  {...} // all of your props
/>
TIP If you have to use any styles with multiple components like multiple CleaveJS components used in a single page, then you need to import the styles once and then wrap the index file of that page with the styled component, so that the styles are not called multiple times. # Override Styled Components Overriding these styles components is very easy. Follow these steps to override any styles: Make a new file in the src/layouts/styles folder Copy the code of that component that you want to override from the src/@core/styles folder and paste it into the new file that you just made Override the styles as per your project requirements Let us say that you want to override the styles of React Credit Cards: // src/layouts/styles/react-credit-cards/index.ts

import { styled } from '@mui/material/styles'

const CardWrapper = styled('div')(({ theme }) => ({
  display: 'flex',
  '& .rccs, & .rccs__card': {
    margin: theme.spacing(4)
  }
}))

export default CardWrapper
# React Hot Toast The styles of React Hot Toast are globally included in the src/pages/_app.tsx file, so you do not need to add a wrapper in any of your toast components. # Usage // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import ReactHotToast from 'src/@core/styles/libs/react-hot-toast'

<ReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</ReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>
# Override To override the styles, you need to follow the same steps that are explained above. Now, suppose you want to open the toasts at their default position, then: Make a new file in the src/layouts/styles folder (say src/layouts/styles/react-hot-toast/index.ts) Copy the code from the src/@core/styles/react-hot-toast/index.ts file and paste it into the src/layouts/styles/react-hot-toast/index.ts file Remove the following code: '& > div': {
  top: '75px !important',
  right: `${theme.spacing(6)} !important`
}
Import and render src/layouts/styles/react-hot-toast/index.ts file in src/pages/_app.tsx file // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import UserReactHotToast from 'src/layouts/styles/react-hot-toast'

<UserReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</UserReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>

# getServerSideProps method # What is getServerSideProps? Please refer to this  (opens new window) Next.js docs for the details on the getServerSideProps method. # How to use getServerSideProps? Please refer to this  (opens new window) Next.js docs to know how to use the getServerSideProps method. # Why have we not used the getServerSideProps method? We are using @fake-db; thus, we weren't bound to use the getServerSideProps method. NOTE If you are using the getServerSideProps method and exporting the static HTML files to your server, these  (opens new window) are unsupported features that cannot be computed during the build process.
# How to add Calendar App in starter-kit Vuexy uses fullcalendar  (opens new window) for Calendar App. Follow these steps to integrate Calendar in starter-kit: Create a store/apps folder in src/ Copy Calendar folder from full-version/src/store/apps/ to starter-kit/src/store/apps/ Create index.ts file in store folder and add the following code: // ** Toolkit imports
import { configureStore } from '@reduxjs/toolkit'

import calendar from 'src/store/apps/calendar'

export const store = configureStore({
  reducer: { calendar },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })
})

export type RootState = ReturnType<typeof store.getState>
Navigate to src/pages/_app.tsx & add the following imports // ** Store Imports
import { store } from 'src/store'
import { Provider } from 'react-redux'
Wrap your app with <Provider store={store}> to get access to the redux store. Create a @fake-db folder. Create mock.ts file in the newly created @fake-db folder and add the following code: import axios from 'axios'
import MockAdapter from 'axios-mock-adapter'

const mock = new MockAdapter(axios)

export default mock
Create a apps folder in the @fake-db and copy full-version/src/@fake-db/apps/calendar.ts file to the @fake-db/apps folder. Create index.ts file in the @fake-db folder and add the following code: import mock from './mock'

import './apps/calendar'

mock.onAny().passThrough()
Add the following import in src/pages/_app.tsx: // ** Fake-DB Import
import 'src/@fake-db'
Copy full-version/src/views/apps/calendar folder to starter-kit/src/views/apps/calendar Copy full-version/src/pages/apps/calendar folder to starter-kit/src/pages/apps/calendar Finally add the calendar in src/navigation/vertical/index.ts and src/navigation/horizontal/index.ts: const navigation = () => {
  return [
    ...
    {
      title: 'Calendar',
      path: '/apps/calendar',
      icon: 'tabler:calendar'
    },
    ...
  ]
}

# useSettings Hook # Overview useSettings hook is created to get the values from the Settings context and set the values to the Settings context. useSettings hook must be used inside a functional component. The values that are accessible in the useSettings hook is mentioned in the Settings Context. # Read values from Settings Context Below is the example of how to get template skin. You can get any other values by replacing skin with any other property that is available in the Settings Context. import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return <Box sx={{ boxShadow: theme => theme.shadows[settings.skin === 'bordered' ? 0 : 7] }}>...</Box>
}

export default SomeComponent
# Update single value in Settings Context Below is the example of how to change template mode, i.e. Light or Dark mode. You can change any other values by replacing mode with any other property that is available in the Settings Context.  # Update multiple values in Settings Context Below is the example of how to change content width (i.e. Full or Container width) and template layout (i.e. Vertical or Horizontal layout). You can change any other values that are available in the Settings Context. 
# Deployment TIP Read official Next.js docs  (opens new window) to handle deployment smoothly. # Node.js Server Next.js can be deployed to any hosting provider that supports Node.js. Make sure your package.json has the build and start scripts: "scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start"
}
next build builds the production application in the .next folder. After building, next start starts a Node.js server that supports hybrid pages, serving both statically generated and server-side rendered pages. # Static HTML Export Command next export allows you to export your app to static HTML, which can be run standalone without the need of a Node.js server. The exported app supports almost every feature of Next.js, including dynamic routes, prefetching, preloading and dynamic imports. next export works by pre-rendering all pages to HTML. For dynamic routes, your page can export a getStaticPaths function to let the exporter know which HTML pages to generate for that route. By default, next export will generate an out directory, which can be served by any static hosting service or CDN. The choice of your server software isn‚Äôt important either. Since the output of the export command is completely platform-agnostic, there‚Äôs no need to explicitly use Node. WARNING We are using img element instead of nextjs/Image  (opens new window). If you're using nextjs/Image instead of img element then you'll get image optimization error with static HTML export. You'll need a loader to fix this. Read this doc  (opens new window) for more info. # Vercel Deployment Read the this documentation  (opens new window) to deploy your app to vercel. Heads Up! If you are going to deploy your project under a subfolder, please read this FAQ before generating build or exporting your project.
# RTL # Change to RTL We provide Left to Right (LTR) by default but you can easily change it to Right to Left (RTL). To change the whole template to RTL, you need to go to the src/configs/themeConfig.ts file and change the direction property from ltr to rtl. # RTL Toggler You can also make a direction toggler which toggle between LTR and RTL directions. Look at the following code to make one:  # Get current direction You might need to render some code conditionally based on the current direction of the template. You can write the following code to do so: ¬†¬†¬†import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  if (settings.direction === 'rtl') {
    return (
      {/* Some code */}
    )
  } else {
    return (
      {/* Some other code */}
    )
  }
}

export default SomeComponent
If you need to style something conditionally based on the current direction of the template, do the following: ¬†¬†¬†import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return (
    <Box sx={{ backgroundColor: settings.direction === 'rtl' ? 'red' : 'blue' }}>
      ...
    </Box>
  )
}

export default SomeComponent
# Remove RTL from the template To remove the RTL from the whole template, follow these steps: Remove all the plugins related to RTL. View all the dependencies of RTL in this section Replace the following code in the src/layouts/components/Direction.tsx file: 
# Settings Context # Overview Settings Context has been created so that the template is independent of the redux store for storing the variables used in the template. # Properties Following are the properties and their values that are stored in the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed navHidden true, false If true, the navigation menu is hidden layout vertical, horizontal Set Vertical or Horizontal layout for the template lastLayout vertical, horizontal For internal usage (used when window is resized in Horizontal layout) verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity footer fixed, static, hidden Change footer position themeColor primary, secondary, success, error, warning, info Change primary color in the template toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Default toast position of react-hot-toast # LocalStorage Following are the properties and their values that are stored in localStorage from the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBarBlur true, false If true, background of appBar will have opacity themeColor primary, secondary, success, error, warning, info Change primary color in the template # Provider and Consumer Settings context relies on the context feature of React  (opens new window) to pass the settings down to the components. Settings context exports SettingsProvider and SettingsConsumer and they must be parents of ThemeComponent in src/pages/_app.tsx file. See the following code: <SettingsProvider>
  <SettingsConsumer>
    {({ settings }) => (
      <ThemeComponent settings={settings}>{getLayout(<Component {...pageProps} />)}</ThemeComponent>
    )}
  </SettingsConsumer>
</SettingsProvider>

# How to add Search in starter-kit Search has been implemented in the full-version only. If you have started your project using the starter kit as per our suggestion, please follow the below steps in order to implement search functionality: Copy full-version/src/layouts/components/Autocomplete.tsx and full-version/src/layouts/components/autocompleteIconObj.ts files and paste these files in the same path in the starter-kit folder Using fake-db Copy the full-version/src/@fake-db/app-bar-search/index.ts & AppBarSearchType type from the full-version/src/@fake-db/types.ts files and paste them into the same paths in the starter-kit folder Not using fake-db Update the useEffect hook (in which API is called using axios) according to the your requirement and also copy the AppBarSearchType type from the full-version/src/@fake-db/types.ts file & paste it in the starter-kit/src/layouts/components/Autocomplete.tsx file. Import starter-kit/src/layouts/components/Autocomplete.tsx file in the starter-kit/src/layouts/components/vertical/AppBarContent.tsx and/or starter-kit/src/layouts/components/horizontal/AppBarContent.tsx file(s) and use it in whichever way you want. And this is it. Enjoy searching in the template.
# How to update navbar or footer ? # Navbar While updating the navbar (or appBar), only the content inside the navbar can be overridden which includes all the actions from the left and right sides. Please refer following docs in order to override Navbar / AppBar in Vertical layout: Vertical Navbar / AppBar Content Please refer following docs in order to override Navbar / AppBar in Horizontal layout: Horizontal Navbar / AppBar Content # Footer While updating the footer, only the content inside the footer can be overridden which includes all the texts and links from the left and right sides respectively. Please refer following docs in order to override Footer in Vertical and Horizontal layouts: Footer Content
# Layout Content with Fixed Height # Overview You can use this layout if you want a fixed height of the content area. For example, apps like Email and Chat need a fixed height and a scrollbar should be inside these apps. Heads Up! Do not remove any code related to contentHeightFixed from the src/layouts/UserLayout.tsx file. Otherwise, the whole template would break. # Usage You need to use the contentHeightFixed method on your component to fix the height of the content area. The type accepted by this method is: contentHeightFixed?: boolean
Here is the example code: const Component = () => {
  return (
    // your content
  )
}

Component.contentHeightFixed = true

export default Component

# Environment Variables Vuexy comes with support for environment variables, which allows you to use .env to load the environment variables. Tip We recommend you to read the official guide  (opens new window) given by Next.js for using environment variables. # Loading Environment Variables Next.js has built-in support for loading environment variables from .env file into process.env. An example .env.local: DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods  (opens new window) and API routes  (opens new window). For example, using getStaticProps  (opens new window): // pages/index.js
export async function getStaticProps() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS
  })
  // ...
}
# Exposing Environment Variables to the Browser By default environment variables are only available in the Node.js environment, meaning they won't be exposed to the browser. In order to use an environment variable inside a component and to expose a variable to the browser, you have to prefix the variable with NEXT_PUBLIC_. For example: NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk
WARNING Do not store any secrets (such as private API keys or passwords) in the public variables! These environment variables are embedded into the build, meaning anyone can view them by inspecting your app's files. # Private Variables Having access to the NODE_ENV is also useful for performing actions conditionally: if (process.env.NODE_ENV !== 'production') {
  analytics.disable()
}
Read more nextjs official documentation for more info on environment variables from here  (opens new window). # Environment variables used in the template We have use the fake-db and fake-db API calls are not supported to access the environment variables. Hence, we have used NEXT_PUBLIC prefix with our environment variables. You can find the environment variables' file .env.development in the root of the project. The environment variables that we have used in the .env.development file are as follows: NEXT_PUBLIC_JWT_EXPIRATION
NEXT_PUBLIC_JWT_SECRET
NEXT_PUBLIC_JWT_REFRESH_TOKEN_SECRET
Make sure to replace JWT secrets and token with your actual values and it's advisable to remove the NEXT_PUBLIC prefix if you are using the Next.js data fetching method or API routes.
# getLayout TIP We recommend you to go through the Per page Layout Docs of NextJS  (opens new window) to understand how the layout works on any single page in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview If you want to change the default layout for a particular page, you can use the getLayout method with your component. # Blank Layout Here is an example of how to change the layout from default layout to blank layout for any page:  # Blank Layout with AppBar Here is an example of how to change the layout from default layout to blank layout with appBar for any page:  # Custom Layout Refer to the code below to create a blog layout:  Result:  # Change the default page layout Suppose, you want to change the default page layout for all the pages in your project, then follow the below steps: Make a layout as per your requirements in the src/layouts folder (let us assume that you named the file as UserDefaultLayout.tsx) Import the newly created file in the src/pages/_app.tsx file as: import UserDefaultLayout from 'src/layouts/UserDefaultLayout'
Change the getLayout variable from const getLayout = Component.getLayout ?? (page => <UserLayout contentHeightFixed={contentHeightFixed}>{page}</UserLayout>)
to const getLayout = Component.getLayout ?? (page => <UserDefaultLayout>{page}</UserDefaultLayout>)

# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# How to replace API endpoints In your app you would want to use the real APIs instead of one created with the FakeDB. To replace the APIs with the real ones make sure you have created the API's in your backend & connected the API's with your database. NOTE If the structure of the data you receive from the API is different than ours then, you'll have to update the app structure too. You can refer to the data structure in src/fake-db/folder. # Apps/Pages Let's take the Invoice App as an example to replace the API. Follow these steps to replace the API for the invoice app: You can find the API usage for apps in src/store/apps folder & you can find API usage for pages in the folder for its respective pages. In case of invoice open src/store/apps/invoice/index.{ts|js} and replace the API in createAsyncThunk function. You can also use your editor to find the APIs in the whole template & replace them accordingly. # Authentication In the case of Authentication all the APIs used are located in src/configs/auth.{ts|js}. You won't have to find and replace the Authentication APIs, you can just replace the authentication APIs in the exported object.
# FakeDB Vuexy is built using FakeDB to mock the real life application functionalities. # Overview Vuexy uses axios-mock-adapter  (opens new window) to simulate the server calls. All of the server calls are located in src/@fake-db. # Setup If you're using the starter-kit you'll have to manually setup the fake-db. First create a folder with name fake-db and create a mock.ts file inside it. Initialize the axios-mock-adapter in mock.ts file. import axios from 'axios'
import MockAdapter from 'axios-mock-adapter'

const mock = new MockAdapter(axios)

export default mock
 Create a index.ts file in fake-db folder & add the following: import mock from './mock'

mock.onAny().passThrough()
 To initialize your fake data create a ts file in fake-db folder. Import mock and use it like following: import mock from '../mock'

const data = [{...}]

mock.onGet('/url/get-data').reply(config => {
  return [200, data]
})
 Import the above created file in fake-db/index.ts: import mock from './mock'

import './FILE_WITH_DATA'

mock.onAny().passThrough()
 Import your fake-db/index.ts in src/pages/_app_.ts to be able to get your data in your app. Finally, use axios to fetch your data from fake-db import { useState, useEffect } from 'react'

import axios from 'axios'

const Component = () => {
  const [data, setData] = useState([])

  useEffect(() => {
    axios.get('/url/get-data').then(response => setData(response.data))
  }, [])

  return <h1>Component</h1>
}
WARNING We have used the fake-db for demo purposes only. fake-db will not work for the real life applications.
# getLayout TIP We recommend you to go through the Per page Layout Docs of NextJS  (opens new window) to understand how the layout works on any single page in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview If you want to change the default layout for a particular page, you can use the getLayout method with your component. # Blank Layout Here is an example of how to change the layout from default layout to blank layout for any page:  # Blank Layout with AppBar Here is an example of how to change the layout from default layout to blank layout with appBar for any page:  # Custom Layout Refer to the code below to create a blog layout:  Result:  # Change the default page layout Suppose, you want to change the default page layout for all the pages in your project, then follow the below steps: Make a layout as per your requirements in the src/layouts folder (let us assume that you named the file as UserDefaultLayout.tsx) Import the newly created file in the src/pages/_app.tsx file as: import UserDefaultLayout from 'src/layouts/UserDefaultLayout'
Change the getLayout variable from const getLayout = Component.getLayout ?? (page => <UserLayout contentHeightFixed={contentHeightFixed}>{page}</UserLayout>)
to const getLayout = Component.getLayout ?? (page => <UserDefaultLayout>{page}</UserDefaultLayout>)

# Environment Variables Vuexy comes with support for environment variables, which allows you to use .env to load the environment variables. Tip We recommend you to read the official guide  (opens new window) given by Next.js for using environment variables. # Loading Environment Variables Next.js has built-in support for loading environment variables from .env file into process.env. An example .env.local: DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Node.js environment automatically allowing you to use them in Next.js data fetching methods  (opens new window) and API routes  (opens new window). For example, using getStaticProps  (opens new window): // pages/index.js
export async function getStaticProps() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS
  })
  // ...
}
# Exposing Environment Variables to the Browser By default environment variables are only available in the Node.js environment, meaning they won't be exposed to the browser. In order to use an environment variable inside a component and to expose a variable to the browser, you have to prefix the variable with NEXT_PUBLIC_. For example: NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk
WARNING Do not store any secrets (such as private API keys or passwords) in the public variables! These environment variables are embedded into the build, meaning anyone can view them by inspecting your app's files. # Private Variables Having access to the NODE_ENV is also useful for performing actions conditionally: if (process.env.NODE_ENV !== 'production') {
  analytics.disable()
}
Read more nextjs official documentation for more info on environment variables from here  (opens new window). # Environment variables used in the template We have use the fake-db and fake-db API calls are not supported to access the environment variables. Hence, we have used NEXT_PUBLIC prefix with our environment variables. You can find the environment variables' file .env.development in the root of the project. The environment variables that we have used in the .env.development file are as follows: NEXT_PUBLIC_JWT_EXPIRATION
NEXT_PUBLIC_JWT_SECRET
NEXT_PUBLIC_JWT_REFRESH_TOKEN_SECRET
Make sure to replace JWT secrets and token with your actual values and it's advisable to remove the NEXT_PUBLIC prefix if you are using the Next.js data fetching method or API routes.
# Horizontal scrollbar in Horizontal layout You might get a horizontal scrollbar in the horizontal layout. This is because we have given the feature of animation on the open and close of the horizontal navigation group. If you are facing the problem of the horizontal scrollbar and you do not want an animation in the horizontal navigation menu, then change the value of the horizontalMenuAnimation property to false in the src/configs/themeConfig.ts file.
# useSettings Hook # Overview useSettings hook is created to get the values from the Settings context and set the values to the Settings context. useSettings hook must be used inside a functional component. The values that are accessible in the useSettings hook is mentioned in the Settings Context. # Read values from Settings Context Below is the example of how to get template skin. You can get any other values by replacing skin with any other property that is available in the Settings Context. import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return <Box sx={{ boxShadow: theme => theme.shadows[settings.skin === 'bordered' ? 0 : 7] }}>...</Box>
}

export default SomeComponent
# Update single value in Settings Context Below is the example of how to change template mode, i.e. Light or Dark mode. You can change any other values by replacing mode with any other property that is available in the Settings Context.  # Update multiple values in Settings Context Below is the example of how to change content width (i.e. Full or Container width) and template layout (i.e. Vertical or Horizontal layout). You can change any other values that are available in the Settings Context. 
# Styled Components # Overview These are the styles available in the src/@core/styles folder: MUI Stepper Fullcalendar Keen Slider React Apexcharts CleaveJs React Credit Cards React Datepicker React Draft Wysiwyg React Dropzone React Hot Toast Recharts TIP If you do not want to use these styles, then render your component directly. This will apply the default styles provided by MUI and/or third-party plugins. # Usage You need to import styles as a component and wrap them around your components. Let us take an example of React Datepicker: import DatePicker from 'react-datepicker'
import DatePickerWrapper from 'src/@core/styles/libs/react-datepicker'

<DatePickerWrapper>
  <DatePicker
    {...} // all of your props
  />
</DatePickerWrapper>
If you do not want to use these styles: import DatePicker from 'react-datepicker'

<DatePicker
  {...} // all of your props
/>
TIP If you have to use any styles with multiple components like multiple CleaveJS components used in a single page, then you need to import the styles once and then wrap the index file of that page with the styled component, so that the styles are not called multiple times. # Override Styled Components Overriding these styles components is very easy. Follow these steps to override any styles: Make a new file in the src/layouts/styles folder Copy the code of that component that you want to override from the src/@core/styles folder and paste it into the new file that you just made Override the styles as per your project requirements Let us say that you want to override the styles of React Credit Cards: // src/layouts/styles/react-credit-cards/index.ts

import { styled } from '@mui/material/styles'

const CardWrapper = styled('div')(({ theme }) => ({
  display: 'flex',
  '& .rccs, & .rccs__card': {
    margin: theme.spacing(4)
  }
}))

export default CardWrapper
# React Hot Toast The styles of React Hot Toast are globally included in the src/pages/_app.tsx file, so you do not need to add a wrapper in any of your toast components. # Usage // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import ReactHotToast from 'src/@core/styles/libs/react-hot-toast'

<ReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</ReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>
# Override To override the styles, you need to follow the same steps that are explained above. Now, suppose you want to open the toasts at their default position, then: Make a new file in the src/layouts/styles folder (say src/layouts/styles/react-hot-toast/index.ts) Copy the code from the src/@core/styles/react-hot-toast/index.ts file and paste it into the src/layouts/styles/react-hot-toast/index.ts file Remove the following code: '& > div': {
  top: '75px !important',
  right: `${theme.spacing(6)} !important`
}
Import and render src/layouts/styles/react-hot-toast/index.ts file in src/pages/_app.tsx file // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import UserReactHotToast from 'src/layouts/styles/react-hot-toast'

<UserReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</UserReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>

# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# How to integrate this template into my existing project ? Since this is a template and a starter project, it‚Äôs built as the starting point of your project. It cannot be simply installed and used with an existing project like a third party library. Although using our template with any existing project is still possible, it would require extra effort to connect everything together. We strongly recommend you to either start your project with Vuexy, or move your project on top of it to have the best experience.
# How to add MUI localization WARNING To use MUI localization you'll have to make changes in the ThemeComponent.tsx file. You'll have to make a copy of the ThemeComponent.tsx file to keep it as a backup while updating the template. # Localization Synced With I18n Open the src/@core/theme/ThemeComponent.tsx file Import the locales you need from '@mui/material/locale'  Import the useTranslation hook from react-i18next import { useTranslation } from 'react-i18next'
Create a langObj variable  Initialize the useTranslation hook const { i18n } = useTranslation()
Add the language as a parameter to the createTheme function theme = createTheme(
  theme,
  {
    components: { ...mergeComponentOverrides(theme, settings) },
    typography: { ...mergeTypography(theme) }
  },
  langObj[i18n.language]
  )

# How to create pages accessible to signed-in and signed-out users WARNING This will only work for BlankLayout You might have some pages that you want to be accessible to signed-in or signed-out users. To create such pages follow these steps: Open _app.tsx file and add the noGuard variable and update the authGuard variable const noGuard = Component.noGuard ?? false
const authGuard = Component.authGuard ?? noGuard ? false : true
In  _app.tsx file replace the <AclGuard /> component with the following: <AclGuard aclAbilities={aclAbilities} guestGuard={guestGuard} noGuard={noGuard}>...</AclGuard>
If you're using Typescript version then open next.d.ts file and add noGuard?: boolean type. Open ACLGuard.tsx file and extract the noGuard prop from the props. const { aclAbilities, children, guestGuard, noGuard } = props
In ACLGuard.tsx file replace the if statement with the following: if (guestGuard || router.route === '/404' || router.route === '/500' || router.route === '/' || noGuard) {
  return <>{children}</>
}
Finally, in your component add the Component.noGuard = true at the bottom. Like shown below: // ** React Imports
import { ReactNode } from 'react'

// ** Layout Import
import BlankLayout from 'src/@core/layouts/BlankLayout'

const Component = () => {
  return <div>...</div>
}

Component.getLayout = (page: ReactNode) => <BlankLayout>{page}</BlankLayout>

Component.noGuard = true

export default Component

# How to change colors ? Most of the time very first question to start any project would be to setup project colors. In this case please refer how to change colors doc. You should easily be able to override any colors like primary, secondary, info, warning, success, error or any other. Also consider reading official MUI docs on how to customize MUI palette documentation  (opens new window) for detailed understanding.
# Settings Context # Overview Settings Context has been created so that the template is independent of the redux store for storing the variables used in the template. # Properties Following are the properties and their values that are stored in the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed navHidden true, false If true, the navigation menu is hidden layout vertical, horizontal Set Vertical or Horizontal layout for the template lastLayout vertical, horizontal For internal usage (used when window is resized in Horizontal layout) verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBar fixed, static, hidden Change appBar position appBarBlur true, false If true, background of appBar will have opacity footer fixed, static, hidden Change footer position themeColor primary, secondary, success, error, warning, info Change primary color in the template toastPosition top-left, top-center, top-right, bottom-left, bottom-center, bottom-right Default toast position of react-hot-toast # LocalStorage Following are the properties and their values that are stored in localStorage from the Settings Context: Properties Values Description skin default, bordered Change template skin mode light, dark, semi-dark Set Light or Dark mode for the template direction ltr, rtl Content direction navCollapsed true, false If true, the vertical navigation menu is collapsed verticalNavToggleType accordion, collapse Set behavior of menu group in the vertical navigation menu contentWidth full, boxed Full or container width of AppBar, Content and Footer appBarBlur true, false If true, background of appBar will have opacity themeColor primary, secondary, success, error, warning, info Change primary color in the template # Provider and Consumer Settings context relies on the context feature of React  (opens new window) to pass the settings down to the components. Settings context exports SettingsProvider and SettingsConsumer and they must be parents of ThemeComponent in src/pages/_app.tsx file. See the following code: <SettingsProvider>
  <SettingsConsumer>
    {({ settings }) => (
      <ThemeComponent settings={settings}>{getLayout(<Component {...pageProps} />)}</ThemeComponent>
    )}
  </SettingsConsumer>
</SettingsProvider>

# Layout Content with Fixed Height # Overview You can use this layout if you want a fixed height of the content area. For example, apps like Email and Chat need a fixed height and a scrollbar should be inside these apps. Heads Up! Do not remove any code related to contentHeightFixed from the src/layouts/UserLayout.tsx file. Otherwise, the whole template would break. # Usage You need to use the contentHeightFixed method on your component to fix the height of the content area. The type accepted by this method is: contentHeightFixed?: boolean
Here is the example code: const Component = () => {
  return (
    // your content
  )
}

Component.contentHeightFixed = true

export default Component

# How to change Skin ? We provide default skin as the default skin. If a user wants to change the default skin, then go to the src/configs/themeConfig.ts file and change the value of the skin property as per your project requirements. The user may go to the ThemeConfig docs to see the options available in skin as well as for other properties. If a user wants to style something according to the skins, the user can read the current skin in this doc.
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# Dependencies # Common Heads Up! The following dependencies are common and required to run the template. Do not try to remove any of these dependencies. You may add / update / remove any other dependencies according to your requirements. "@casl/ability"
"@casl/react"
"@emotion/cache"
"@emotion/react"
"@emotion/server"
"@emotion/styled"
"@iconify/react"
"@iconify/iconify"
"@iconify/json"
"@iconify/tools"
"@iconify/types"
"@iconify/utils"
"@mui/lab"
"@mui/material"
"@popperjs/core"
"react-popper"
"clsx"
"next"
"react"
"@types/react" // Typescript version only
"react-dom"
"react-perfect-scrollbar"
"@types/node" // Typescript version only
"prettier"
"typescript" // Typescript version only
# Authentication "jsonwebtoken"
"@types/jsonwebtoken" // Typescript version only
# Calendar "@fullcalendar/bootstrap5"
"@fullcalendar/common"
"@fullcalendar/core"
"@fullcalendar/daygrid"
"@fullcalendar/interaction"
"@fullcalendar/list"
"@fullcalendar/react"
"@fullcalendar/timegrid"
"bootstrap-icons"
# Form Validation "react-hook-form"
"@hookform/resolvers"
"yup"
# Internationalization (i18n) "i18next"
"i18next-browser-languagedetector"
"i18next-http-backend"
"react-i18next"
# Charts // Apexcharts
"apexcharts-clevision"
"react-apexcharts"

// Recharts
"recharts"

// ChartJs
"chart.js"
"react-chartjs-2"
# Redux "@reduxjs/toolkit"
"react-redux"
"@types/react-redux" // Typescript version only
# Editor "react-draft-wysiwyg"
"@types/react-draft-wysiwyg" // Typescript version only
"draft-js"
"@types/draft-js" // Typescript version only
# Right to Left (RTL) "stylis"
"stylis-plugin-rtl"
# Copy to Clipboard "clipboard-copy"
# Upload "react-dropzone"
# API Call "axios"
"axios-mock-adapter"
# Data Grid "@mui/x-data-grid"
# Input Formatter "cleave.js"
"@types/cleave.js" // Typescript version only
# Page loader "nprogress"
"@types/nprogress" // Typescript version only
# Markdown "prismjs"
"@types/prismjs" // Typescript version only
# Toast "react-hot-toast"
# PDF Generator "html2canvas"
"jsPDF"
# Date Time Picker "react-datepicker"
"@types/react-datepicker" // Typescript version only
"date-fns" // date formatter
# Payment "payment"
"@types/payment" // Typescript version only
"react-credit-cards"
"@types/react-credit-cards" // Typescript version only
# Swiper "keen-slider"
# Eslint "@typescript-eslint/eslint-plugin" // Typescript version only
"@typescript-eslint/parser" // Typescript version only
"eslint"
"eslint-config-next"
"eslint-config-prettier"
"eslint-import-resolver-alias"
"eslint-import-resolver-typescript" // Typescript version only
"eslint-plugin-import"

# NextAuth with Google Provider and Prisma Adapter Please find below a guide for authentication with NextAuth using only the GoogleProvider  (opens new window) and PrismaAdapter  (opens new window). Additional providers may be added or removed as per your specific requirements. For your convenience, each functional aspect has been thoroughly commented and accompanied by valuable insights and relevant links that will assist you in customizing your authentication process to align with your specific needs. Please note that customization of NextAuth to meet specific requirements, such as modifying the session strategy, adjusting session expiration times, designating authentication pages, and customizing callback functions, are not considered part of the support. These elements will vary based on the specific implementation. # Connect your project with Google Cloud Please follow the instructions below to set up your Google Cloud account: Open the Google Cloud Console using this  (opens new window) link. If you have multiple projects on Google Cloud, select any one to connect with your project, or create a new one. Follow the complete setup guide for Google Cloud by referring to this  (opens new window) video link. When creating your credentials, ensure that the "Authorized redirect URIs" include your full domain and end in the callback path. For example: For production: https://{YOUR_DOMAIN}/api/auth/callback/google For development: http://localhost:3000/api/auth/callback/google After creating the OAuth client, you will be provided with a CLIENT_ID and CLIENT_SECRET by Google Cloud Console. Store these in your .env file or as per your requirement as shown below: GOOGLE_CLIENT_ID= YOUR_CLIENT_ID_GOES_HERE // your CLIENT_ID provided by Google Cloud Console
GOOGLE_CLIENT_SECRET= YOUR_CLIENT_SECRET_GOES_HERE // your CLIENT_SECRET provided by Google Cloud Console
# Prisma Adapter Setup WARNING If you are using SQLite database with Prisma, then you need to remove @db.Text text from the prisma/schema.prisma file. Please follow all the steps provided in the official NextAuth's PrismaAdapter  (opens new window). The necessary files, lib/prismadb.ts and prisma/schema.prisma, can be found in above link. You may move these files as per your requirements. In this example, we kept these files in the src folder. Note! Please note that you must change the import path of lib/prismadb.ts in the pages/api/auth/[...nextauth].js file to match its new location. In the schema.prisma file, we used SQLite database as the provider, with file:./dev.db specified as the URL in the datasource db. Here is the example code: datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}
However, you may alter the above settings to as per your database. You are free to add or remove tables and columns as per your requirements. In this example, a role column has been added to the User table to define the role of a user. Please refer to the following code to add the same: model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  role          String?  @default("admin")
}
After saving your schema, use the Prisma CLI to generate the Prisma Client by running the following command in the src folder for this example: npx prisma generate
To configure your database to use the new schema (e.g. creating tables and columns), run the following command using the Prisma CLI in the src folder for this example: npx prisma migrate dev
If you want to watch the preview of the Prisma database, you may run the following command: npx prisma studio
# [...nextauth].ts file The implementation of the authentication logic should be performed within the src/pages/api/auth/[...nextauth].ts file. It is advisable to tailor this file to suit the specific requirements of your project. The necessary configurations and instructions for customizing can be located in the NextAuth official documentation  (opens new window). 
In order to successfully customize the file, it is recommended to understand its contents and how it functions. Allow us to commence.
Note All the options used in the above [...nextauth].ts file are outlined and explained below. Please refer to the official NextAuth documentation  (opens new window) for a comprehensive list of available options. # providers  We utilize the GoogleProvider  (opens new window) which enables the handling of sign-in through google. Multiple authentication providers can be configured simultaneously. The following options are available within GoogleProvider: # clientId The client ID provided by Google Cloud Console # clientSecret The client secret provided by Google Cloud Console Kindly consult the official NextAuth documentation  (opens new window) for more providers options. # secret  It is a random string used to hash tokens, sign/encrypt cookies and generate cryptographic keys. If the NEXTAUTH_SECRET is set as an environment variable, it is not necessary to define this option. A secret can be generated by visiting the documentation link provided below. Kindly consult the official NextAuth documentation  (opens new window) for more details on secret. # session  # strategy You are required to make a choice on how you wish to preserve the user session. The default option is jwt, which involves the storage of an encrypted JWT (JWE) within a session cookie. If you elect to use an adapter, the default setting will be changed to database instead. It is still possible to explicitly specify jwt and retain a JWT session. If the option database is chosen, the session cookie will only hold a sessionToken value, which will then be used to retrieve the session information from the database. # maxAge The duration of an idle session until it expires and becomes invalid. It accepts a number in seconds. Kindly consult the official NextAuth documentation  (opens new window) for more session options. # pages  Specify URLs to be used if you want to create custom sign in, sign out and error pages. Pages specified will override the corresponding built-in page. Kindly consult the official NextAuth documentation  (opens new window) for more pages options. # callbacks  Callbacks are asynchronous functions you can use to control what happens when an action is performed. Callbacks are extremely powerful, especially in scenarios involving JSON Web Tokens as they allow you to implement access controls without a database and to integrate with external databases or APIs. # jwt This callback is called whenever a JSON Web Token is created (i.e. at sign in) or updated (i.e whenever a session is accessed in the client). The returned value will be encrypted, and it is stored in a cookie. When utilizing the jwt strategy within the session option, the jwt() callback will be executed prior to the session() callback. The data returned by the authorize function in the providers option will be passed to the jwt() callback in the form of the token. To include custom parameters in the session() callback, they must be added to the token in the jwt() callback, which will then be transferred to the session() callback for further processing. Kindly consult the official NextAuth documentation  (opens new window) for more details on jwt() callback. # session The session callback is called whenever a session is checked. By default, only a subset of the token is returned for increased security. If you want to make something available you added to the token (like access_token and user.id from above) via the jwt() callback, you have to explicitly forward it here to make it available to the client. Kindly consult the official NextAuth documentation  (opens new window) for more details on session() callback. Kindly consult the official NextAuth documentation  (opens new window) for more callbacks options.  We hope that with the information provided, you have now acquired a comprehensive understanding of all the options available within the [...nextauth].ts or [...nextauth].js file. # next-auth.d.ts file It may be necessary to include the next-auth.d.ts file in the root directory of your project to modify certain types specified by NextAuth. In this example, the role option have been added to the user's object. The following type declaration can be added to extend NextAuth's types: import 'next-auth/jwt'
import { DefaultSession } from 'next-auth'

declare module 'next-auth/jwt' {
  interface JWT {
    role: string
  }
}

declare module 'next-auth' {
  interface Session {
    user: {
      role: string
    } & DefaultSession['user']
  }

  interface User {
    role: string
  }
}
You may customize this file to meet your specific requirements. # Login Page To login with Google, add a button like bellow: import { signIn } from 'next-auth/react'

<Button fullWidth size='large' sx={{ mb: 7 }} variant='contained' onClick={() => signIn('google')}>
  Login with google
</Button>
# Useful Links To implement Prisma (SQLite) with Next.js, check out this  (opens new window) video. To implement NextAuth with PrismaAdapter (Planetscale), check out this  (opens new window) video. To implement NextAuth with CredentialProvider  (opens new window), refer to this article.
# Getting Started TIP Get Started with the Starter kit version and copy components from full version We only provide documentation for custom components and customizations made to MUI's components. For MUI components' documentation please visit MUI's official docs  (opens new window). Heads Up! When using Javascript version, please consider respective file paths, we only show ts & tsx file paths for reference code in documentation. e.g. Following is the file path in TypeScript version: src/layouts/UserLayout.tsx and consider looking at following path in JavaScript version: src/layouts/UserLayout.js There can be two possibilities, you are planning to start a new project with our template or trying to add our template into your existing project. # Starting a new project with our template It is always suggested to get started with the minimal setup and we exactly provide that with our starter kit version. Once you unzip the template you will find TypeScript / JavaScript version folder and under that full-version and starter-kit folders. First step should be to verify all the dependencies and clean up all the packages that are not required for your project. # What's the point including all the dependencies with starter kit? Your question is totally valid and legit. To make the experience smoother, we have listed all the dependencies and provided freedom to remove dependencies which are not required in your project. Searching for packages that are required and to install them can be difficult and confusing for new users. Hence, we have included all the packages in the starter-kit. New user can just copy components from full version without worring about packages. # Integrating our template into your existing project Since this is a template and a starter project, it‚Äôs built as the starting point of your project. It cannot be simply installed and used with an existing project like a third party library. Although using our template with any existing project is still possible, it would require extra work to connect everything together. We strongly recommend you to either start your project with Vuexy, or move your project on top of it to have the best experience. # Follow Installation Guide Next, Follow the installation guide once you streamline all the dependencies and make sure you meet all the system requirements mentioned in the installation page to run the project and read all the notices carefully given on the installation page. # Demo Configs You want your local template to look like one of the 6 demos you saw online then please follow demo configs documentation which will help you achieve your goal. # FAQs If you face any difficulties with installation, or has any question on usage of this template like changing colors, fonts, branding etc., then treat yourself by visiting FAQs section. You are most likely to find your answer there. # Search Docs Our template has large documentation and sometime it can be daunting to find what you are looking for in the docs. Fastest way to find anything is to search doc using search input in the Navigation bar. You can write keywords and it will filter out results and come up with the best possible match.
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# Styled Components # Overview These are the styles available in the src/@core/styles folder: MUI Stepper Fullcalendar Keen Slider React Apexcharts CleaveJs React Credit Cards React Datepicker React Draft Wysiwyg React Dropzone React Hot Toast Recharts TIP If you do not want to use these styles, then render your component directly. This will apply the default styles provided by MUI and/or third-party plugins. # Usage You need to import styles as a component and wrap them around your components. Let us take an example of React Datepicker: import DatePicker from 'react-datepicker'
import DatePickerWrapper from 'src/@core/styles/libs/react-datepicker'

<DatePickerWrapper>
  <DatePicker
    {...} // all of your props
  />
</DatePickerWrapper>
If you do not want to use these styles: import DatePicker from 'react-datepicker'

<DatePicker
  {...} // all of your props
/>
TIP If you have to use any styles with multiple components like multiple CleaveJS components used in a single page, then you need to import the styles once and then wrap the index file of that page with the styled component, so that the styles are not called multiple times. # Override Styled Components Overriding these styles components is very easy. Follow these steps to override any styles: Make a new file in the src/layouts/styles folder Copy the code of that component that you want to override from the src/@core/styles folder and paste it into the new file that you just made Override the styles as per your project requirements Let us say that you want to override the styles of React Credit Cards: // src/layouts/styles/react-credit-cards/index.ts

import { styled } from '@mui/material/styles'

const CardWrapper = styled('div')(({ theme }) => ({
  display: 'flex',
  '& .rccs, & .rccs__card': {
    margin: theme.spacing(4)
  }
}))

export default CardWrapper
# React Hot Toast The styles of React Hot Toast are globally included in the src/pages/_app.tsx file, so you do not need to add a wrapper in any of your toast components. # Usage // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import ReactHotToast from 'src/@core/styles/libs/react-hot-toast'

<ReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</ReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>
# Override To override the styles, you need to follow the same steps that are explained above. Now, suppose you want to open the toasts at their default position, then: Make a new file in the src/layouts/styles folder (say src/layouts/styles/react-hot-toast/index.ts) Copy the code from the src/@core/styles/react-hot-toast/index.ts file and paste it into the src/layouts/styles/react-hot-toast/index.ts file Remove the following code: '& > div': {
  top: '75px !important',
  right: `${theme.spacing(6)} !important`
}
Import and render src/layouts/styles/react-hot-toast/index.ts file in src/pages/_app.tsx file // src/pages/_app.tsx

import { Toaster } from 'react-hot-toast'
import UserReactHotToast from 'src/layouts/styles/react-hot-toast'

<UserReactHotToast>
  <Toaster position={settings.toastPosition} toastOptions={{ className: 'react-hot-toast' }} />
</UserReactHotToast>
import toast from 'react-hot-toast'

<button onClick={() => toast('Blank Toast')}>Open Toast</button>

# getLayout TIP We recommend you to go through the Per page Layout Docs of NextJS  (opens new window) to understand how the layout works on any single page in the app. Once you understand the layout from NextJS, then you may go through our docs for a better understanding. # Overview If you want to change the default layout for a particular page, you can use the getLayout method with your component. # Blank Layout Here is an example of how to change the layout from default layout to blank layout for any page:  # Blank Layout with AppBar Here is an example of how to change the layout from default layout to blank layout with appBar for any page:  # Custom Layout Refer to the code below to create a blog layout:  Result:  # Change the default page layout Suppose, you want to change the default page layout for all the pages in your project, then follow the below steps: Make a layout as per your requirements in the src/layouts folder (let us assume that you named the file as UserDefaultLayout.tsx) Import the newly created file in the src/pages/_app.tsx file as: import UserDefaultLayout from 'src/layouts/UserDefaultLayout'
Change the getLayout variable from const getLayout = Component.getLayout ?? (page => <UserLayout contentHeightFixed={contentHeightFixed}>{page}</UserLayout>)
to const getLayout = Component.getLayout ?? (page => <UserDefaultLayout>{page}</UserDefaultLayout>)

# Getting Started TIP Get Started with the Starter kit version and copy components from full version We only provide documentation for custom components and customizations made to MUI's components. For MUI components' documentation please visit MUI's official docs  (opens new window). Heads Up! When using Javascript version, please consider respective file paths, we only show ts & tsx file paths for reference code in documentation. e.g. Following is the file path in TypeScript version: src/layouts/UserLayout.tsx and consider looking at following path in JavaScript version: src/layouts/UserLayout.js There can be two possibilities, you are planning to start a new project with our template or trying to add our template into your existing project. # Starting a new project with our template It is always suggested to get started with the minimal setup and we exactly provide that with our starter kit version. Once you unzip the template you will find TypeScript / JavaScript version folder and under that full-version and starter-kit folders. First step should be to verify all the dependencies and clean up all the packages that are not required for your project. # What's the point including all the dependencies with starter kit? Your question is totally valid and legit. To make the experience smoother, we have listed all the dependencies and provided freedom to remove dependencies which are not required in your project. Searching for packages that are required and to install them can be difficult and confusing for new users. Hence, we have included all the packages in the starter-kit. New user can just copy components from full version without worring about packages. # Integrating our template into your existing project Since this is a template and a starter project, it‚Äôs built as the starting point of your project. It cannot be simply installed and used with an existing project like a third party library. Although using our template with any existing project is still possible, it would require extra work to connect everything together. We strongly recommend you to either start your project with Vuexy, or move your project on top of it to have the best experience. # Follow Installation Guide Next, Follow the installation guide once you streamline all the dependencies and make sure you meet all the system requirements mentioned in the installation page to run the project and read all the notices carefully given on the installation page. # Demo Configs You want your local template to look like one of the 6 demos you saw online then please follow demo configs documentation which will help you achieve your goal. # FAQs If you face any difficulties with installation, or has any question on usage of this template like changing colors, fonts, branding etc., then treat yourself by visiting FAQs section. You are most likely to find your answer there. # Search Docs Our template has large documentation and sometime it can be daunting to find what you are looking for in the docs. Fastest way to find anything is to search doc using search input in the Navigation bar. You can write keywords and it will filter out results and come up with the best possible match.
# How to add i18n routing # Routing Synced With I18n Open the next.config.js file and add the i18 property with the languages you need i18n: {
  locales: ['en', 'fr', 'ar'],
  defaultLocale: 'en'
},
Create a useEffect in the src/pages/_app.tsx file to watch changes of i18n language and to preserve the language in case the page is reloaded: import { useEffect } from 'react'
import { useRouter } from 'next/router'
import { useTranslation } from 'react-i18next'

const App = () => {
  const router = useRouter()
  const { i18n } = useTranslation()
  const { locale } = router

  useEffect(() => {
    if (locale !== 'en') {
      i18n.changeLanguage(locale)
    }
  }, [locale])

  return (
    ...
  )
}

export default App
To switch a language, push the locale parameter with router.push:  Import locale from the useRouter hook and add the locale prop to every NextJS link that is used in your app: import Link from 'next/link'
import { useRouter } from 'next/router'

const Component = () => {
  const router = useRouter()
  const { locale } = router

  return <Link href='...' locale={locale}>text</Link>
}

export default Component
If you have getStaticPaths & getStaticProps in your component then you'll have to do the following otherwise you'll be redirected to 404 export const getStaticProps = ({ locale, locales }) => {
  return {
    props: {
      locale,
      locales,
    },
  }
}

export const getStaticPaths = ({ locales }) => {
  const paths = []

  for (const locale of locales) {
    paths.push({ params: { ... }, locale })
    paths.push({ params: { ... }, locale })
  }

  return {
    paths,
    fallback: true,
  }
}

# Getting Started TIP Get Started with the Starter kit version and copy components from full version We only provide documentation for custom components and customizations made to MUI's components. For MUI components' documentation please visit MUI's official docs  (opens new window). Heads Up! When using Javascript version, please consider respective file paths, we only show ts & tsx file paths for reference code in documentation. e.g. Following is the file path in TypeScript version: src/layouts/UserLayout.tsx and consider looking at following path in JavaScript version: src/layouts/UserLayout.js There can be two possibilities, you are planning to start a new project with our template or trying to add our template into your existing project. # Starting a new project with our template It is always suggested to get started with the minimal setup and we exactly provide that with our starter kit version. Once you unzip the template you will find TypeScript / JavaScript version folder and under that full-version and starter-kit folders. First step should be to verify all the dependencies and clean up all the packages that are not required for your project. # What's the point including all the dependencies with starter kit? Your question is totally valid and legit. To make the experience smoother, we have listed all the dependencies and provided freedom to remove dependencies which are not required in your project. Searching for packages that are required and to install them can be difficult and confusing for new users. Hence, we have included all the packages in the starter-kit. New user can just copy components from full version without worring about packages. # Integrating our template into your existing project Since this is a template and a starter project, it‚Äôs built as the starting point of your project. It cannot be simply installed and used with an existing project like a third party library. Although using our template with any existing project is still possible, it would require extra work to connect everything together. We strongly recommend you to either start your project with Vuexy, or move your project on top of it to have the best experience. # Follow Installation Guide Next, Follow the installation guide once you streamline all the dependencies and make sure you meet all the system requirements mentioned in the installation page to run the project and read all the notices carefully given on the installation page. # Demo Configs You want your local template to look like one of the 6 demos you saw online then please follow demo configs documentation which will help you achieve your goal. # FAQs If you face any difficulties with installation, or has any question on usage of this template like changing colors, fonts, branding etc., then treat yourself by visiting FAQs section. You are most likely to find your answer there. # Search Docs Our template has large documentation and sometime it can be daunting to find what you are looking for in the docs. Fastest way to find anything is to search doc using search input in the Navigation bar. You can write keywords and it will filter out results and come up with the best possible match.
# Checkbox # Overview We have made the custom checkbox components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Checkbox Docs  (opens new window) for a proper explanation of the Checkbox component. # Basic Custom Checkbox   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxBasicData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxBasicData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component meta ReactNode No Add content to the right side of the title. (To add meta in your checkbox, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxIconsData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the checkbox component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxIconsData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxImgData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxImgData is as follows: Property Type Required Description value string Yes Identify a particular checkbox img ReactNode Yes Image for the checkbox alt string No Alternate text for the image isSelected boolean No If true, checkbox will be selected at initial render
# Layout Components # Overview On this page, you'll get to know how the layout components are rendered so that it would be easy for you to override these layout components. # Vertical Layout Components Vertical Layout is formed with the following layout components. Let's understand each one of them: # 1. Navigation Menu (left sidebar) The navigation menu is created with the following components: Navigation Header which uses the VerticalNavHeader component  VerticalNavItems component is used to categorize whether an item is a section header, navigation group or navigation link Navigation Section Header which uses the VerticalNavSectionTitle component  Navigation Group which uses the VerticalNavGroup component  Navigation Link which uses the VerticalNavLink component  # 2. Navbar (or AppBar) AppBar is created with the following components: # Left side section Template Search which uses the Autocomplete component # Right side section Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 3. Footer Footer is created with the following components: Copyright on the left side Important links of the company on the right side # Horizontal Layout Components Horizontal Layout is formed with the following layout components. Let's understand each one of them: # 1. Navbar (or AppBar) AppBar is created with the following components: # Left side section Company Logo and/or Company Name # Right side section Template Search which uses the Autocomplete component Change language by using the LanguageDropdown component Light and Dark Mode Toggler which uses the ModeToggler component Notifications of the User which uses the NotificationDropdown component User Actions which uses the UserDropdown component # 2. Navigation Menu The navigation menu is created with the following components: HorizontalNavItems component is used to categorize whether an item is a navigation group or navigation link Navigation Group which uses the HorizontalNavGroup component  Navigation Link which uses the HorizontalNavLink component  # 3. Footer Footer is created with the following components: Copyright on left side Important links of the company on the right side # Blank Layout with AppBar Component Blank Layout with AppBar provides only appBar (at top of the page) which contains the Company logo and Company name only. # Scroll to top Component Fab button is created at the bottom-right side of a page to scroll to the top of the page. It is available only in Vertical and Horizontal layouts. It is not visible at top of the page. It is only visible when the page is scrolled more than 400px. 
# RTL # Change to RTL We provide Left to Right (LTR) by default but you can easily change it to Right to Left (RTL). To change the whole template to RTL, you need to go to the src/configs/themeConfig.ts file and change the direction property from ltr to rtl. # RTL Toggler You can also make a direction toggler which toggle between LTR and RTL directions. Look at the following code to make one:  # Get current direction You might need to render some code conditionally based on the current direction of the template. You can write the following code to do so: ¬†¬†¬†import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  if (settings.direction === 'rtl') {
    return (
      {/* Some code */}
    )
  } else {
    return (
      {/* Some other code */}
    )
  }
}

export default SomeComponent
If you need to style something conditionally based on the current direction of the template, do the following: ¬†¬†¬†import Box from '@mui/material/Box'
import { useSettings } from 'src/@core/hooks/useSettings'

const SomeComponent = () => {
  const { settings } = useSettings()

  return (
    <Box sx={{ backgroundColor: settings.direction === 'rtl' ? 'red' : 'blue' }}>
      ...
    </Box>
  )
}

export default SomeComponent
# Remove RTL from the template To remove the RTL from the whole template, follow these steps: Remove all the plugins related to RTL. View all the dependencies of RTL in this section Replace the following code in the src/layouts/components/Direction.tsx file: 
# How to use Nextjs Image Component without Height & Width ? There might be a time where you'll have to use an image without height or width. But, the Nextjs Image component
requires both height & width. In that case, you can do something like this: <Box sx={{ width: 35, height: 35 }}>
  <Img width='100%' height='100%' layout='responsive' objectFit='contain' src='/images/logos/facebook.png' />
</Box>

# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Icons # Overview We have used Material Design Icons from the Iconify library in the whole template. You may visit the site here  (opens new window) and check all the icons here  (opens new window). Users are free to use any icon library of their choice. WARNING We are using the offline icons with the help of Iconify bundle and we suggest you do the same. If you want to use very few icons from other libraries, then you may use online icons directly from the public API of Iconify. Heads Up! The src/iconify-bundle/tsconfig.json file is different from the tsconfig.json file and thus do not delete the src/iconify-bundle/tsconfig.json file from your project; otherwise, you will not be able to generate icon bundle from the yarn build:icons command. Heads Up! While using the Tabler icons, fill and stroke related props (like fill, fillOpacity, stroke, strokeWidth, strokeOpacity, etc.) will not work with the Icon component as the <svg> tag doesn't have those attributes. If anyone wants to add such styling, then they may add them using the style prop or use MUI's Box component and use the sx props with it. # Iconify Bundle When Iconify icon component renders an icon, if icon data is not available, the component attempts to load data for an icon from Iconify API. Even though loading icon data from API is very fast, it is not instant and it requires internet access. By providing icon data for most used icons, you guarantee that icon data is ready when a component needs it, rendering icons instantly. This also allows rendering icons when internet access is not available and you are no longer relying on third-party service. The following files are necessary to generate Iconify bundle: src/iconify-bundle/bundle-icons-react.d.ts (typescript version only) src/iconify-bundle/bundle-icons-react.js src/iconify-bundle/bundle-icons-react.ts (typescript version only) src/iconify-bundle/icons-bundle-react.js src/iconify-bundle/tsconfig.json package.json # How to Generate Bundle? You can generate the bundle with a wide variety of emojis, flags, brand logos, SVGs & icons and use them even when internet access is not available. To generate such icons, you just need to add your desired icon library, any specific icon(s), a custom JSON file created by you, custom SVG(s) created by you or any emoji(s). # Generate all icons from an icon library To add all the icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from an icon library To add some icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from different libraries To add some icons from different libraries provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from a custom JSON file To add some icons from a custom JSON file, you need to follow the file format according to this  (opens new window) and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom SVG files To add some icons from some custom SVG files, you need to create some SVG files in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom Emojis To add some icons from some custom emojis, you need to create some emojis in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Target & Import Once you have added all the icons that are necessary for your project, you need to set the file path in which the whole icon bundle gets generated. Search for the term const target = in the src/iconify-bundle/bundle-icons-react.ts or src/iconify-bundle/bundle-icons-react.js file and set a file path which is suitable for your project. Once the file path is set, you need to update that file path in the src/pages/_app.tsx or src/pages/_app.js file as well. Once the import statement is updated in the src/pages/_app.tsx or src/pages/_app.js file, you can use Iconify React Component anywhere in the template. We have set the value of target as: const target = 'src/iconify-bundle/icons-bundle-react.js'
and the import statement as: import 'src/iconify-bundle/icons-bundle-react'
# Run the command Once you have set the target and updated the import statement, then you need to run the following command in the root (where your package.json file exists):  # How is the bundle generated? # TypeScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.ts file is compiled to the src/iconify-bundle/bundle-icons-react.js file. Once the compilation is completed, the compiled file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.tsx file. # JavaScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.js file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.js file. # Usage # Props You may visit this docs  (opens new window) provided by Iconify to refer to all the props of the Iconify React Component. # How to use Iconify React Component? Import the Iconify React Component as given below: import Icon from 'src/@core/components/icon'
If you want the default font-size of the Iconify React Component as 16px, you need to import the following component: import { Icon } from '@iconify/react'
Here is an example: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='tabler:home' />
}

export default Component
In the example given above, tabler is Tabler Icons (icon library provided by Iconify) and home is an icon which is in the tabler icon library. # Use some different icon library Suppose you want to use the Font Awesome Solid icon library. Please follow these instructions to add the icons from the Font Awesome Solid icon library. Here is an example to use an icon from the Font Awesome Solid icon library: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='fa6-solid:bicycle' />
}

export default Component
In the example given above, fa6-solid is Font Awesome Solid icon library and bicycle is an icon which is in the fa6-solid icon library. # Style an icon using MUI component Here is an example to change the color of an icon using an MUI component: import Box from '@mui/material/Box'
import Icon from 'src/@core/components/icon'

const Component = () => {
  return (
    <Box sx={{ display: 'flex', color: theme => theme.palette.primary.main }}>
      <Icon icon='tabler:home' />
    </Box>
  )
}

export default Component
# Use icon from Iconify public API By default, Iconify icon components use Iconify public API. Iconify icon components also cache loaded icons in the browser cache and/or browser storage, so icon data needs to be loaded only once. You need internet access to load the icons from the Iconify public API for the first time. Otherwise, the icon will not be rendered on your page and a console error will come. To render the icons from the Iconify public API, you must not include those icons in the Iconify bundle.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Icons # Overview We have used Material Design Icons from the Iconify library in the whole template. You may visit the site here  (opens new window) and check all the icons here  (opens new window). Users are free to use any icon library of their choice. WARNING We are using the offline icons with the help of Iconify bundle and we suggest you do the same. If you want to use very few icons from other libraries, then you may use online icons directly from the public API of Iconify. Heads Up! The src/iconify-bundle/tsconfig.json file is different from the tsconfig.json file and thus do not delete the src/iconify-bundle/tsconfig.json file from your project; otherwise, you will not be able to generate icon bundle from the yarn build:icons command. Heads Up! While using the Tabler icons, fill and stroke related props (like fill, fillOpacity, stroke, strokeWidth, strokeOpacity, etc.) will not work with the Icon component as the <svg> tag doesn't have those attributes. If anyone wants to add such styling, then they may add them using the style prop or use MUI's Box component and use the sx props with it. # Iconify Bundle When Iconify icon component renders an icon, if icon data is not available, the component attempts to load data for an icon from Iconify API. Even though loading icon data from API is very fast, it is not instant and it requires internet access. By providing icon data for most used icons, you guarantee that icon data is ready when a component needs it, rendering icons instantly. This also allows rendering icons when internet access is not available and you are no longer relying on third-party service. The following files are necessary to generate Iconify bundle: src/iconify-bundle/bundle-icons-react.d.ts (typescript version only) src/iconify-bundle/bundle-icons-react.js src/iconify-bundle/bundle-icons-react.ts (typescript version only) src/iconify-bundle/icons-bundle-react.js src/iconify-bundle/tsconfig.json package.json # How to Generate Bundle? You can generate the bundle with a wide variety of emojis, flags, brand logos, SVGs & icons and use them even when internet access is not available. To generate such icons, you just need to add your desired icon library, any specific icon(s), a custom JSON file created by you, custom SVG(s) created by you or any emoji(s). # Generate all icons from an icon library To add all the icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from an icon library To add some icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from different libraries To add some icons from different libraries provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from a custom JSON file To add some icons from a custom JSON file, you need to follow the file format according to this  (opens new window) and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom SVG files To add some icons from some custom SVG files, you need to create some SVG files in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom Emojis To add some icons from some custom emojis, you need to create some emojis in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Target & Import Once you have added all the icons that are necessary for your project, you need to set the file path in which the whole icon bundle gets generated. Search for the term const target = in the src/iconify-bundle/bundle-icons-react.ts or src/iconify-bundle/bundle-icons-react.js file and set a file path which is suitable for your project. Once the file path is set, you need to update that file path in the src/pages/_app.tsx or src/pages/_app.js file as well. Once the import statement is updated in the src/pages/_app.tsx or src/pages/_app.js file, you can use Iconify React Component anywhere in the template. We have set the value of target as: const target = 'src/iconify-bundle/icons-bundle-react.js'
and the import statement as: import 'src/iconify-bundle/icons-bundle-react'
# Run the command Once you have set the target and updated the import statement, then you need to run the following command in the root (where your package.json file exists):  # How is the bundle generated? # TypeScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.ts file is compiled to the src/iconify-bundle/bundle-icons-react.js file. Once the compilation is completed, the compiled file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.tsx file. # JavaScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.js file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.js file. # Usage # Props You may visit this docs  (opens new window) provided by Iconify to refer to all the props of the Iconify React Component. # How to use Iconify React Component? Import the Iconify React Component as given below: import Icon from 'src/@core/components/icon'
If you want the default font-size of the Iconify React Component as 16px, you need to import the following component: import { Icon } from '@iconify/react'
Here is an example: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='tabler:home' />
}

export default Component
In the example given above, tabler is Tabler Icons (icon library provided by Iconify) and home is an icon which is in the tabler icon library. # Use some different icon library Suppose you want to use the Font Awesome Solid icon library. Please follow these instructions to add the icons from the Font Awesome Solid icon library. Here is an example to use an icon from the Font Awesome Solid icon library: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='fa6-solid:bicycle' />
}

export default Component
In the example given above, fa6-solid is Font Awesome Solid icon library and bicycle is an icon which is in the fa6-solid icon library. # Style an icon using MUI component Here is an example to change the color of an icon using an MUI component: import Box from '@mui/material/Box'
import Icon from 'src/@core/components/icon'

const Component = () => {
  return (
    <Box sx={{ display: 'flex', color: theme => theme.palette.primary.main }}>
      <Icon icon='tabler:home' />
    </Box>
  )
}

export default Component
# Use icon from Iconify public API By default, Iconify icon components use Iconify public API. Iconify icon components also cache loaded icons in the browser cache and/or browser storage, so icon data needs to be loaded only once. You need internet access to load the icons from the Iconify public API for the first time. Otherwise, the icon will not be rendered on your page and a console error will come. To render the icons from the Iconify public API, you must not include those icons in the Iconify bundle.
# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Icons # Overview We have used Material Design Icons from the Iconify library in the whole template. You may visit the site here  (opens new window) and check all the icons here  (opens new window). Users are free to use any icon library of their choice. WARNING We are using the offline icons with the help of Iconify bundle and we suggest you do the same. If you want to use very few icons from other libraries, then you may use online icons directly from the public API of Iconify. Heads Up! The src/iconify-bundle/tsconfig.json file is different from the tsconfig.json file and thus do not delete the src/iconify-bundle/tsconfig.json file from your project; otherwise, you will not be able to generate icon bundle from the yarn build:icons command. Heads Up! While using the Tabler icons, fill and stroke related props (like fill, fillOpacity, stroke, strokeWidth, strokeOpacity, etc.) will not work with the Icon component as the <svg> tag doesn't have those attributes. If anyone wants to add such styling, then they may add them using the style prop or use MUI's Box component and use the sx props with it. # Iconify Bundle When Iconify icon component renders an icon, if icon data is not available, the component attempts to load data for an icon from Iconify API. Even though loading icon data from API is very fast, it is not instant and it requires internet access. By providing icon data for most used icons, you guarantee that icon data is ready when a component needs it, rendering icons instantly. This also allows rendering icons when internet access is not available and you are no longer relying on third-party service. The following files are necessary to generate Iconify bundle: src/iconify-bundle/bundle-icons-react.d.ts (typescript version only) src/iconify-bundle/bundle-icons-react.js src/iconify-bundle/bundle-icons-react.ts (typescript version only) src/iconify-bundle/icons-bundle-react.js src/iconify-bundle/tsconfig.json package.json # How to Generate Bundle? You can generate the bundle with a wide variety of emojis, flags, brand logos, SVGs & icons and use them even when internet access is not available. To generate such icons, you just need to add your desired icon library, any specific icon(s), a custom JSON file created by you, custom SVG(s) created by you or any emoji(s). # Generate all icons from an icon library To add all the icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from an icon library To add some icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from different libraries To add some icons from different libraries provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from a custom JSON file To add some icons from a custom JSON file, you need to follow the file format according to this  (opens new window) and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom SVG files To add some icons from some custom SVG files, you need to create some SVG files in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom Emojis To add some icons from some custom emojis, you need to create some emojis in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Target & Import Once you have added all the icons that are necessary for your project, you need to set the file path in which the whole icon bundle gets generated. Search for the term const target = in the src/iconify-bundle/bundle-icons-react.ts or src/iconify-bundle/bundle-icons-react.js file and set a file path which is suitable for your project. Once the file path is set, you need to update that file path in the src/pages/_app.tsx or src/pages/_app.js file as well. Once the import statement is updated in the src/pages/_app.tsx or src/pages/_app.js file, you can use Iconify React Component anywhere in the template. We have set the value of target as: const target = 'src/iconify-bundle/icons-bundle-react.js'
and the import statement as: import 'src/iconify-bundle/icons-bundle-react'
# Run the command Once you have set the target and updated the import statement, then you need to run the following command in the root (where your package.json file exists):  # How is the bundle generated? # TypeScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.ts file is compiled to the src/iconify-bundle/bundle-icons-react.js file. Once the compilation is completed, the compiled file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.tsx file. # JavaScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.js file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.js file. # Usage # Props You may visit this docs  (opens new window) provided by Iconify to refer to all the props of the Iconify React Component. # How to use Iconify React Component? Import the Iconify React Component as given below: import Icon from 'src/@core/components/icon'
If you want the default font-size of the Iconify React Component as 16px, you need to import the following component: import { Icon } from '@iconify/react'
Here is an example: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='tabler:home' />
}

export default Component
In the example given above, tabler is Tabler Icons (icon library provided by Iconify) and home is an icon which is in the tabler icon library. # Use some different icon library Suppose you want to use the Font Awesome Solid icon library. Please follow these instructions to add the icons from the Font Awesome Solid icon library. Here is an example to use an icon from the Font Awesome Solid icon library: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='fa6-solid:bicycle' />
}

export default Component
In the example given above, fa6-solid is Font Awesome Solid icon library and bicycle is an icon which is in the fa6-solid icon library. # Style an icon using MUI component Here is an example to change the color of an icon using an MUI component: import Box from '@mui/material/Box'
import Icon from 'src/@core/components/icon'

const Component = () => {
  return (
    <Box sx={{ display: 'flex', color: theme => theme.palette.primary.main }}>
      <Icon icon='tabler:home' />
    </Box>
  )
}

export default Component
# Use icon from Iconify public API By default, Iconify icon components use Iconify public API. Iconify icon components also cache loaded icons in the browser cache and/or browser storage, so icon data needs to be loaded only once. You need internet access to load the icons from the Iconify public API for the first time. Otherwise, the icon will not be rendered on your page and a console error will come. To render the icons from the Iconify public API, you must not include those icons in the Iconify bundle.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Sever Side Navigation Menu # Overview On this page, you will understand how to use a server side navigation menu in Vertical layout as well as in Horizontal layout. # Vertical layout To use the server side navigation menu in the Vertical layout, follow these steps: You need to write all of your navigation section titles, navigation groups and navigation links in this structure either on your sever / API or in the src/@fake-db/server-side-menu/vertical.ts file Make an API call from your server in src/layouts/components/vertical/ServerSideNavItems.tsx file And then import src/layouts/components/vertical/ServerSideNavItems.tsx file in src/layouts/UserLayout.tsx file and pass it as shown below:  # Horizontal layout Important! As mentioned here, you need to add menu items for Vertical Navigation as well. Please follow these steps to add the Vertical Navigation and then follow the steps explained below. To use the server side navigation menu in the Horizontal layout, follow these steps: You need to write all of your navigation groups and navigation links in this structure either on your sever / API or in the src/@fake-db/server-side-menu/horizontal.ts file Make an API call from your server in src/layouts/components/horizontal/ServerSideNavItems.tsx file And then import src/layouts/components/horizontal/ServerSideNavItems.tsx file in src/layouts/UserLayout.tsx file and pass it as shown below: 
# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Icons # Overview We have used Material Design Icons from the Iconify library in the whole template. You may visit the site here  (opens new window) and check all the icons here  (opens new window). Users are free to use any icon library of their choice. WARNING We are using the offline icons with the help of Iconify bundle and we suggest you do the same. If you want to use very few icons from other libraries, then you may use online icons directly from the public API of Iconify. Heads Up! The src/iconify-bundle/tsconfig.json file is different from the tsconfig.json file and thus do not delete the src/iconify-bundle/tsconfig.json file from your project; otherwise, you will not be able to generate icon bundle from the yarn build:icons command. Heads Up! While using the Tabler icons, fill and stroke related props (like fill, fillOpacity, stroke, strokeWidth, strokeOpacity, etc.) will not work with the Icon component as the <svg> tag doesn't have those attributes. If anyone wants to add such styling, then they may add them using the style prop or use MUI's Box component and use the sx props with it. # Iconify Bundle When Iconify icon component renders an icon, if icon data is not available, the component attempts to load data for an icon from Iconify API. Even though loading icon data from API is very fast, it is not instant and it requires internet access. By providing icon data for most used icons, you guarantee that icon data is ready when a component needs it, rendering icons instantly. This also allows rendering icons when internet access is not available and you are no longer relying on third-party service. The following files are necessary to generate Iconify bundle: src/iconify-bundle/bundle-icons-react.d.ts (typescript version only) src/iconify-bundle/bundle-icons-react.js src/iconify-bundle/bundle-icons-react.ts (typescript version only) src/iconify-bundle/icons-bundle-react.js src/iconify-bundle/tsconfig.json package.json # How to Generate Bundle? You can generate the bundle with a wide variety of emojis, flags, brand logos, SVGs & icons and use them even when internet access is not available. To generate such icons, you just need to add your desired icon library, any specific icon(s), a custom JSON file created by you, custom SVG(s) created by you or any emoji(s). # Generate all icons from an icon library To add all the icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from an icon library To add some icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from different libraries To add some icons from different libraries provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from a custom JSON file To add some icons from a custom JSON file, you need to follow the file format according to this  (opens new window) and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom SVG files To add some icons from some custom SVG files, you need to create some SVG files in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom Emojis To add some icons from some custom emojis, you need to create some emojis in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Target & Import Once you have added all the icons that are necessary for your project, you need to set the file path in which the whole icon bundle gets generated. Search for the term const target = in the src/iconify-bundle/bundle-icons-react.ts or src/iconify-bundle/bundle-icons-react.js file and set a file path which is suitable for your project. Once the file path is set, you need to update that file path in the src/pages/_app.tsx or src/pages/_app.js file as well. Once the import statement is updated in the src/pages/_app.tsx or src/pages/_app.js file, you can use Iconify React Component anywhere in the template. We have set the value of target as: const target = 'src/iconify-bundle/icons-bundle-react.js'
and the import statement as: import 'src/iconify-bundle/icons-bundle-react'
# Run the command Once you have set the target and updated the import statement, then you need to run the following command in the root (where your package.json file exists):  # How is the bundle generated? # TypeScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.ts file is compiled to the src/iconify-bundle/bundle-icons-react.js file. Once the compilation is completed, the compiled file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.tsx file. # JavaScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.js file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.js file. # Usage # Props You may visit this docs  (opens new window) provided by Iconify to refer to all the props of the Iconify React Component. # How to use Iconify React Component? Import the Iconify React Component as given below: import Icon from 'src/@core/components/icon'
If you want the default font-size of the Iconify React Component as 16px, you need to import the following component: import { Icon } from '@iconify/react'
Here is an example: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='tabler:home' />
}

export default Component
In the example given above, tabler is Tabler Icons (icon library provided by Iconify) and home is an icon which is in the tabler icon library. # Use some different icon library Suppose you want to use the Font Awesome Solid icon library. Please follow these instructions to add the icons from the Font Awesome Solid icon library. Here is an example to use an icon from the Font Awesome Solid icon library: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='fa6-solid:bicycle' />
}

export default Component
In the example given above, fa6-solid is Font Awesome Solid icon library and bicycle is an icon which is in the fa6-solid icon library. # Style an icon using MUI component Here is an example to change the color of an icon using an MUI component: import Box from '@mui/material/Box'
import Icon from 'src/@core/components/icon'

const Component = () => {
  return (
    <Box sx={{ display: 'flex', color: theme => theme.palette.primary.main }}>
      <Icon icon='tabler:home' />
    </Box>
  )
}

export default Component
# Use icon from Iconify public API By default, Iconify icon components use Iconify public API. Iconify icon components also cache loaded icons in the browser cache and/or browser storage, so icon data needs to be loaded only once. You need internet access to load the icons from the Iconify public API for the first time. Otherwise, the icon will not be rendered on your page and a console error will come. To render the icons from the Iconify public API, you must not include those icons in the Iconify bundle.
# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Icons # Overview We have used Material Design Icons from the Iconify library in the whole template. You may visit the site here  (opens new window) and check all the icons here  (opens new window). Users are free to use any icon library of their choice. WARNING We are using the offline icons with the help of Iconify bundle and we suggest you do the same. If you want to use very few icons from other libraries, then you may use online icons directly from the public API of Iconify. Heads Up! The src/iconify-bundle/tsconfig.json file is different from the tsconfig.json file and thus do not delete the src/iconify-bundle/tsconfig.json file from your project; otherwise, you will not be able to generate icon bundle from the yarn build:icons command. Heads Up! While using the Tabler icons, fill and stroke related props (like fill, fillOpacity, stroke, strokeWidth, strokeOpacity, etc.) will not work with the Icon component as the <svg> tag doesn't have those attributes. If anyone wants to add such styling, then they may add them using the style prop or use MUI's Box component and use the sx props with it. # Iconify Bundle When Iconify icon component renders an icon, if icon data is not available, the component attempts to load data for an icon from Iconify API. Even though loading icon data from API is very fast, it is not instant and it requires internet access. By providing icon data for most used icons, you guarantee that icon data is ready when a component needs it, rendering icons instantly. This also allows rendering icons when internet access is not available and you are no longer relying on third-party service. The following files are necessary to generate Iconify bundle: src/iconify-bundle/bundle-icons-react.d.ts (typescript version only) src/iconify-bundle/bundle-icons-react.js src/iconify-bundle/bundle-icons-react.ts (typescript version only) src/iconify-bundle/icons-bundle-react.js src/iconify-bundle/tsconfig.json package.json # How to Generate Bundle? You can generate the bundle with a wide variety of emojis, flags, brand logos, SVGs & icons and use them even when internet access is not available. To generate such icons, you just need to add your desired icon library, any specific icon(s), a custom JSON file created by you, custom SVG(s) created by you or any emoji(s). # Generate all icons from an icon library To add all the icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from an icon library To add some icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from different libraries To add some icons from different libraries provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from a custom JSON file To add some icons from a custom JSON file, you need to follow the file format according to this  (opens new window) and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom SVG files To add some icons from some custom SVG files, you need to create some SVG files in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom Emojis To add some icons from some custom emojis, you need to create some emojis in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Target & Import Once you have added all the icons that are necessary for your project, you need to set the file path in which the whole icon bundle gets generated. Search for the term const target = in the src/iconify-bundle/bundle-icons-react.ts or src/iconify-bundle/bundle-icons-react.js file and set a file path which is suitable for your project. Once the file path is set, you need to update that file path in the src/pages/_app.tsx or src/pages/_app.js file as well. Once the import statement is updated in the src/pages/_app.tsx or src/pages/_app.js file, you can use Iconify React Component anywhere in the template. We have set the value of target as: const target = 'src/iconify-bundle/icons-bundle-react.js'
and the import statement as: import 'src/iconify-bundle/icons-bundle-react'
# Run the command Once you have set the target and updated the import statement, then you need to run the following command in the root (where your package.json file exists):  # How is the bundle generated? # TypeScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.ts file is compiled to the src/iconify-bundle/bundle-icons-react.js file. Once the compilation is completed, the compiled file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.tsx file. # JavaScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.js file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.js file. # Usage # Props You may visit this docs  (opens new window) provided by Iconify to refer to all the props of the Iconify React Component. # How to use Iconify React Component? Import the Iconify React Component as given below: import Icon from 'src/@core/components/icon'
If you want the default font-size of the Iconify React Component as 16px, you need to import the following component: import { Icon } from '@iconify/react'
Here is an example: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='tabler:home' />
}

export default Component
In the example given above, tabler is Tabler Icons (icon library provided by Iconify) and home is an icon which is in the tabler icon library. # Use some different icon library Suppose you want to use the Font Awesome Solid icon library. Please follow these instructions to add the icons from the Font Awesome Solid icon library. Here is an example to use an icon from the Font Awesome Solid icon library: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='fa6-solid:bicycle' />
}

export default Component
In the example given above, fa6-solid is Font Awesome Solid icon library and bicycle is an icon which is in the fa6-solid icon library. # Style an icon using MUI component Here is an example to change the color of an icon using an MUI component: import Box from '@mui/material/Box'
import Icon from 'src/@core/components/icon'

const Component = () => {
  return (
    <Box sx={{ display: 'flex', color: theme => theme.palette.primary.main }}>
      <Icon icon='tabler:home' />
    </Box>
  )
}

export default Component
# Use icon from Iconify public API By default, Iconify icon components use Iconify public API. Iconify icon components also cache loaded icons in the browser cache and/or browser storage, so icon data needs to be loaded only once. You need internet access to load the icons from the Iconify public API for the first time. Otherwise, the icon will not be rendered on your page and a console error will come. To render the icons from the Iconify public API, you must not include those icons in the Iconify bundle.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Navigation Menu Structure # Overview While creating the navigation menu, you need to know the structure of it. On this page, you will understand how to create a navigation section title (which is only in the vertical navigation menu), navigation group and navigation link. # Vertical Navigation Structure Following are the items that you can create for your vertical navigation: Navigation Section Header Navigation Group Navigation Link # 1. Navigation Section Header It is used to group some navigation groups and/or navigation links in some sections. This is only used in the vertical navigation menu. To create a navigation section, you need to add an object with the following structure: type NavSectionTitle = {
  action?: string
  subject?: string
  sectionTitle: string
}
Here is the example code: {
  sectionTitle: 'Apps & Pages'
}
Result:  # 2. Navigation Group It is used to group some navigation groups and/or navigation links that can be treated as an accordion or a collapse. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 3. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # Horizontal Navigation Structure Important! So, you have decided to use the Horizontal Layout and will create Horizontal Navigation based on the below docs. Please note that on smaller screens, our layout is converted to Vertical and you will also need to create Vertical Navigation. Please refer to the Vertical Navigation Structure guide as well. Following are the items that you can create for your horizontal navigation: Navigation Group Navigation Link # 1. Navigation Group It is used to group some navigation groups and/or navigation links that are opened in a tooltip. To create a navigation group, you need to add an object with the following structure: // For Static Navigation Menu
type NavGroup = {
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavGroup = {
  icon?: string
  title: string
  action?: string
  subject?: string
  badgeContent?: string
  children?: (NavGroup | NavLink)[]
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result:  # 2. Navigation Link To create a navigation link, you need to add an object with the following structure: // For Static Navigation Menu
type NavLink = {
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  icon?: string | string[] | ReactNode
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}

// For Server Side Navigation Menu
type NavLink = {
  icon?: string
  path?: string
  title: string
  action?: string
  subject?: string
  disabled?: boolean
  badgeContent?: string
  externalLink?: boolean
  openInNewTab?: boolean
  badgeColor?: 'default' | 'primary' | 'secondary' | 'success' | 'error' | 'warning' | 'info'
}
Here is the example code:  Result: 
# Icons # Overview We have used Material Design Icons from the Iconify library in the whole template. You may visit the site here  (opens new window) and check all the icons here  (opens new window). Users are free to use any icon library of their choice. WARNING We are using the offline icons with the help of Iconify bundle and we suggest you do the same. If you want to use very few icons from other libraries, then you may use online icons directly from the public API of Iconify. Heads Up! The src/iconify-bundle/tsconfig.json file is different from the tsconfig.json file and thus do not delete the src/iconify-bundle/tsconfig.json file from your project; otherwise, you will not be able to generate icon bundle from the yarn build:icons command. Heads Up! While using the Tabler icons, fill and stroke related props (like fill, fillOpacity, stroke, strokeWidth, strokeOpacity, etc.) will not work with the Icon component as the <svg> tag doesn't have those attributes. If anyone wants to add such styling, then they may add them using the style prop or use MUI's Box component and use the sx props with it. # Iconify Bundle When Iconify icon component renders an icon, if icon data is not available, the component attempts to load data for an icon from Iconify API. Even though loading icon data from API is very fast, it is not instant and it requires internet access. By providing icon data for most used icons, you guarantee that icon data is ready when a component needs it, rendering icons instantly. This also allows rendering icons when internet access is not available and you are no longer relying on third-party service. The following files are necessary to generate Iconify bundle: src/iconify-bundle/bundle-icons-react.d.ts (typescript version only) src/iconify-bundle/bundle-icons-react.js src/iconify-bundle/bundle-icons-react.ts (typescript version only) src/iconify-bundle/icons-bundle-react.js src/iconify-bundle/tsconfig.json package.json # How to Generate Bundle? You can generate the bundle with a wide variety of emojis, flags, brand logos, SVGs & icons and use them even when internet access is not available. To generate such icons, you just need to add your desired icon library, any specific icon(s), a custom JSON file created by you, custom SVG(s) created by you or any emoji(s). # Generate all icons from an icon library To add all the icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from an icon library To add some icons from an icon library provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from different libraries To add some icons from different libraries provided by Iconify, you just need to do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from a custom JSON file To add some icons from a custom JSON file, you need to follow the file format according to this  (opens new window) and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom SVG files To add some icons from some custom SVG files, you need to create some SVG files in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Generate some icons from some custom Emojis To add some icons from some custom emojis, you need to create some emojis in a single folder inside the src folder and do the following in the src/iconify-bundle/bundle-icons-react.ts file:  # Target & Import Once you have added all the icons that are necessary for your project, you need to set the file path in which the whole icon bundle gets generated. Search for the term const target = in the src/iconify-bundle/bundle-icons-react.ts or src/iconify-bundle/bundle-icons-react.js file and set a file path which is suitable for your project. Once the file path is set, you need to update that file path in the src/pages/_app.tsx or src/pages/_app.js file as well. Once the import statement is updated in the src/pages/_app.tsx or src/pages/_app.js file, you can use Iconify React Component anywhere in the template. We have set the value of target as: const target = 'src/iconify-bundle/icons-bundle-react.js'
and the import statement as: import 'src/iconify-bundle/icons-bundle-react'
# Run the command Once you have set the target and updated the import statement, then you need to run the following command in the root (where your package.json file exists):  # How is the bundle generated? # TypeScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.ts file is compiled to the src/iconify-bundle/bundle-icons-react.js file. Once the compilation is completed, the compiled file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.tsx file. # JavaScript The bundle is generated once you have added the icons, set the target, updated the import statement and run the command. When you run the command, the src/iconify-bundle/bundle-icons-react.js file gets all the icon data from Iconify. After retrieving the icon data, the icon data is wrapped in a callback to create a JavaScript file. The callback function used is addCollection() which is provided by the @iconify/react package. In our case, the final JavaScript file is created as the src/iconify-bundle/icons-bundle-react.js file. In this file, the icon data is collected and wrapped with the addCollection() callback function. So you don't have to handle anything from your side. You just have to import this file into the src/pages/_app.js file. # Usage # Props You may visit this docs  (opens new window) provided by Iconify to refer to all the props of the Iconify React Component. # How to use Iconify React Component? Import the Iconify React Component as given below: import Icon from 'src/@core/components/icon'
If you want the default font-size of the Iconify React Component as 16px, you need to import the following component: import { Icon } from '@iconify/react'
Here is an example: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='tabler:home' />
}

export default Component
In the example given above, tabler is Tabler Icons (icon library provided by Iconify) and home is an icon which is in the tabler icon library. # Use some different icon library Suppose you want to use the Font Awesome Solid icon library. Please follow these instructions to add the icons from the Font Awesome Solid icon library. Here is an example to use an icon from the Font Awesome Solid icon library: import Icon from 'src/@core/components/icon'

const Component = () => {
  return <Icon icon='fa6-solid:bicycle' />
}

export default Component
In the example given above, fa6-solid is Font Awesome Solid icon library and bicycle is an icon which is in the fa6-solid icon library. # Style an icon using MUI component Here is an example to change the color of an icon using an MUI component: import Box from '@mui/material/Box'
import Icon from 'src/@core/components/icon'

const Component = () => {
  return (
    <Box sx={{ display: 'flex', color: theme => theme.palette.primary.main }}>
      <Icon icon='tabler:home' />
    </Box>
  )
}

export default Component
# Use icon from Iconify public API By default, Iconify icon components use Iconify public API. Iconify icon components also cache loaded icons in the browser cache and/or browser storage, so icon data needs to be loaded only once. You need internet access to load the icons from the Iconify public API for the first time. Otherwise, the icon will not be rendered on your page and a console error will come. To render the icons from the Iconify public API, you must not include those icons in the Iconify bundle.
# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Authentication # Overview We only provide JWT authentication with the template for now. We might integrate other authentication services in future. # Auth Context We have created an Authentication context that returns all the necessary functions you might need to authenticate a user like login, logout, register etc. Please make sure to override context and make necessary changes according to your app requirements. We have created this context for demo purpose only. # Usage Example import { useAuth } from 'src/hooks/useAuth'

const Component = () => {
  const auth = useAuth()
  const { login, register, logout } = auth

  const handleErrCallback = err => {
    console.log(err)
  }

  const handleLogin = () => {
    login({ email, password, rememberMe }, err => handleErrCallback(err))
  }

  const handleRegister = () => {
    register({ { email, username, password } }, err => handleErrCallback(err))
  }

  return (
    <Form>
      ...
      <Button onClick={handleLogin}>Login</Button>
      <Button onClick={handleRegister}>Register</Button>
      <Button onClick={logout}>logout</Button>
    </Form>
  )
}

export default Component
# Overriding Auth We are using localStorage & fake-db to store tokens and authenticate the user.
In a real application, you might store the token & user data in a session or cookies. Follow these steps to override the auth context: Open src/context/AuthContext.tsx file Now update the authentication code according to your authentication logic That's it now you can use your modified context. # Auth Context Values Property Type Description user Object LoggedIn User Object setUser Function Function to update LoggedIn User isInitialized Boolean Returns if authentication is initialized or not setIsInitialized Function Function to update isInitialized state loading Boolean Returns if app is loading setLoading Function Function to update loading state login Function Function to login user. register Function Function to register user. logout Function Function to logout user. # Securing Pages We have created a wrapper that checks for the authentication status and redirects user if not logged in. There are two types of guards: AuthGuard GuestGuard Default value for both guards are as follows: AuthGuard: true GuestGuard: false User don't have to define AuthGuard or GuestGuard on all the pages as we have already defined default values as above. Now let's consider scenarios where we need to override AuthGuard & GuestGuard. # Guest Guard For public pages like Login, Registration, Forgot Password, etc., we need to set GuestGuard value to true, as we don't want already logged in user to visit those pages and only guest should be able to visit those pages. Setting GuestGuard to true in LoginPage component. Visit src/pages/login/index.tsx to see it in the action and find out where and how to configure / override guestGuard. LoginPage.guestGuard = true
Setting GuestGuard to true will redirect already logged in user to home page whenever they try to visit the public pages like Login. So make sure to only change / override guestGuard when you do not want logged in users to visit that page. # Auth Guard Now, Let's consider error pages or coming soon, under maintenance or common pages which is accessible by both guest and logged in users. User just need to set AuthGuard to false. Setting AuthGuard to false, in ComingSoon page component ComingSoon.authGuard = false
Setting AuthGuard to false will allow all the users to visit that page whether logged in or not. # onTokenExpiration We provide onTokenExpiration property in src/configs/auth. It decides what action should take place when issued token is expired. Value Description logout will logout and redirect the user to /login page. refreshToken will generate new token for the current user. Note Because we're storing data in localStorage when you change the onTokenExpiration you'll have to clear the localStorage and login again. # JWT Token We sign the user token in src/@fake-db/auth/jwt.js file. The jwtConfig object contains three things expirationTime, secret refreshTokenSecret. Value Description expirationTime User token expiration time secret JWT secret to sign accessToken refreshTokenSecret JWT secret to sign refreshToken As shown in the above section you can either logout the user or referToken on token expiration.
You can find the logic for that '/auth/me' onGet request in the same file. You can use jwt.verify function to check for token validity and create a function according to your needs. Here's how we have used jwt.verify: mock.onGet('/auth/me').reply(config => { 
  // Get token from header
  const token = config.headers.Authorization

  // Default response
  let response: ResponseType = [200, {}]

  // Checks if the token is valid or expired
  jwt.verify(token, jwtConfig.secret, (err, decoded) => {
    // If token is expired
    if (err) {
      // If onTokenExpiration === 'logout' then send 401 error
      if (defaultAuthConfig.onTokenExpiration === 'logout') {
        response = [401, { error: { error: 'Invalid User' } }]
      } else {
        // If onTokenExpiration === 'refreshToken' then generate the new token
        const oldTokenDecoded = jwt.decode(token, { complete: true })
        
        // Get user id from old token
        const { id: userId } = oldTokenDecoded.payload

        // Get user that matches id in token
        const user = users.find(u => u.id === userId)
        
        // Sign a new token
        const accessToken = jwt.sign({ id: userId }, jwtConfig.secret, { expiresIn: jwtConfig.expirationTime })

        // Set new token in localStorage
        window.localStorage.setItem(defaultAuthConfig.storageTokenKeyName, accessToken)

        const obj = { userData: { ...user, password: undefined } }

        // return 200 with user data
        response = [200, obj]
      }
    } else {
      // If token is valid do nothing      
      const userId = decoded.id

      // Get user that matches id in token
      const userData = JSON.parse(JSON.stringify(users.find((u: UserDataType) => u.id === userId)))

      delete userData.password

      // return 200 with user data
      response = [200, { userData }]
    }
  })

  // Send Response 
  return response
})

# How to remove Authentication Removing the authentication from the app is simple. Changes in scr/pages/_app.tsx file Remove all Auth related import statements import { ReactNode } from 'react'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import Spinner from 'src/@core/components/spinner'
import { AuthProvider } from 'src/context/AuthContext'
 Remove the Guard Component and its wrapper Remove the wrapper of the AuthProvider component Remove the authGuard & guestGuard variables Remove the GuardProps type  Changes in other files Remove src/@core/components/auth folder Search and remove Component.guestGuard & Component.authGuard methods from all the files (where Component is the name of the component) Remove authGuard?: boolean and guestGuard?: boolean from the next.d.ts file Remove the src/@fake-db/auth folder and the import './auth/jwt' import statement from the file src/@fake-db/index.ts Remove src/context/AuthContext.tsx & all types related to the Auth from the src/context/types.ts file and their import statements & their usage inside src folder Remove src/hooks/useAuth.tsx file and its import statements & their usage inside src folder If you want the user dropdown in the appBar, you need to override that component in src/@core/layouts/components/shared-components/UserDropdown.tsx file. If you do not require the user dropdown, then remove src/@core/layouts/components/shared-components/UserDropdown.tsx file, its import statements and its usage in src/layouts/components/vertical/AppBarContent.tsx  and src/layouts/components/horizontal/AppBarContent.tsx files You also need to remove Access Control (ACL) as it won't be of any use without authentication. Please read how to remove ACL guide. That's it. Now your app is auth free.
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Static Navigation Menu # Overview On this page, you will understand how to use a static navigation menu in Vertical layout as well as in Horizontal layout. # Vertical layout To use the static navigation menu in the Vertical layout, follow these steps: You need to write all of your navigation section titles, navigation groups and navigation links in this structure in the src/navigation/vertical/index.ts file And then import src/navigation/vertical/index.ts file in src/layouts/UserLayout.tsx file and pass it as shown below:  # Horizontal layout Important! As mentioned here, you need to add menu items for Vertical Navigation as well. Please follow these steps to add the Vertical Navigation and then follow the steps explained below. To use the static navigation menu in the Horizontal layout, follow these steps: You need to write all of your navigation groups and navigation links in this structure in the src/navigation/horizontal/index.ts file And then import src/navigation/horizontal/index.ts file in src/layouts/UserLayout.tsx file and pass it as shown below: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Theming # Overview Theming is the most important aspect of any template. You can easily customize theme of our template. You can change the colors, the typography, the spacing and much more. MUI offers a utility function: createTheme() that creates a theme which can be passed to the theme provider; otherwise the theme provider uses the default theme. The theme provider makes the theme available in the component tree, and can be used via the sx prop, or inside styled components using the MUI styled engine (styled). Important Make your changes in src/layouts/UserThemeOptions.ts file in order to override colors, typography, spacing or any other component styling. Do not make any changes related to theme inside of @core folder unless suggested by our support team. Consider reading MUI theming docs  (opens new window) to understand how it works and how to access and override theme. How to override Color Palette How to customize MUI component appearance How to override Typography How to override Shadows How to override Breakpoints How to override components styling # How to override Color Palette # How to Change Colors In order to change primary color, open src/layouts/UserThemeOptions.ts file and uncomment the palette object returned from that file. palette:{
  primary: {
    light: '#8479F2',
    main: '#7367F0',
    dark: '#655BD3',
    contrastText: '#FFF'
  },
  secondary: {
    ...
  },
  success: {
    ...
  },
  error: {
    ...
  },
  warning: {
    ...
  },
  info: {
    ...
  }
}
Colors given in the above palette object are current primary colors used in our template, update those colors according to your project requirements. Above example shows how to change primary colors. You can change any colors of the palette in the same way shown above. Please refer how to customize MUI palette documentation  (opens new window). Also refer our core palette from the file src/@core/theme/palette/index.ts in order to check custom colors, dark / light colors etc.. for better idea. # Colors Tool Eva color tool https://colors.eva.design/  (opens new window) We recommend picking colors with these values: light : 400 main : 500 dark : 600 contrastText: '#FFF'  # How to customize MUI component appearance You can easily customize the appearance of any component, but it is important to understand how to customize it right way which will save the time, resources and provide optimum performance. Please read MUI doc on how to customize component appearance  (opens new window) to get clear idea. # How to override Typography # How to change font We have used Public Sans fonts  (opens new window) in the whole template. Now suppose you want to implement Montserrat fonts  (opens new window). First open src/pages/_document.tsx file and change font's URL like following: <Head>
  ...
  <link
    rel='stylesheet'
    href='https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap'
  />
  ...
</Head>
Now, open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: typography: {
  fontFamily:
    '"Montserrat", sans-serif'
}
# Use multiple fonts typography: {
  fontFamily:
    '"Public Sans", sans-serif',
  h1: {
    fontFamily:
    '"Montserrat", sans-serif',
    fontWeight: 700,
    fontSize: '3.5rem',
    lineHeight: 1.375
  },
}
Reference: https://demos.pixinvent.com/vuexy-nextjs-admin-template/demo-1/ui/typography  (opens new window) MUI: https://mui.com/material-ui/customization/typography/  (opens new window) # How to override Shadows If you want to customize shadows, uncomment following from the src/layouts/UserThemeOptions.ts file and change shadows  according to your project requirement. Make sure to enable mode from the settings which are already commented at the starting of this file if you are using dark / light both the versions. If you are using either of them, just override shadows without any conditions. // Uncomment this if using light & dark both
const { mode } = settings
// conditional shadows for both dark / light
shadows: mode === 'light' ? [...] : [...]

// Only shadows if using only one from light / dark
shadows: [...]
# How to override Breakpoints If you want to customize breakpoints, uncomment following from the src/layouts/UserThemeOptions.ts file and change breakpoints size according to your project requirement. breakpoints: {
  values: {
    xs: 0,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
}
Reference: https://mui.com/material-ui/customization/breakpoints/  (opens new window) # How to override components styling The theme's components key allows you to customize a component without wrapping it in another component. You can change the styles, the default props, and more. Open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: components: {
  MuiButton: {
    defaultProps: {
      disableElevation: true
    },
    ...
  },
  ...
}
Reference: https://mui.com/material-ui/customization/theme-components/  (opens new window)
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Layout Overrides # Overview The src/layouts folder in the root of the src folder is for users to override layouts built in the src/@core folder. It is highly recommended to override layouts in the src/layouts folder instead of directly working in the src/@core folder. This will ease your updates to newer versions without facing any hassle of backing up your current code, else it will override your changes in the src/@core folder each time you take an update. Most of the layout components explained on this page are overridden in the src/layouts/UserLayout.tsx file. # Layout PropTypes Following is the PropTypes for Vertical and Horizontal Layouts only. export type LayoutProps = {
  hidden: boolean
  settings: Settings
  children: ReactNode
  scrollToTop?: (props?: any) => ReactNode
  saveSettings: (values: Settings) => void
  footerProps?: {
    sx?: SxProps<Theme>
    content?: (props?: any) => ReactNode
  }
  horizontalLayoutProps?: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
    }
    navMenu?: {
      sx?: SxProps<Theme>
      navItems?: HorizontalNavItemsType
      content?: (props?: any) => ReactNode
    }
  }
  verticalLayoutProps: {
    appBar?: {
      componentProps?: AppBarProps
      content?: (props?: any) => ReactNode
    }
    navMenu: {
      lockedIcon?: ReactNode
      unlockedIcon?: ReactNode
      navItems?: VerticalNavItemsType
      content?: (props?: any) => ReactNode
      branding?: (props?: any) => ReactNode
      afterContent?: (props?: any) => ReactNode
      beforeContent?: (props?: any) => ReactNode
      componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
    }
  }
}
# Vertical Layout You can override the following layout components: App Logo Menu collapse icons Menu content Add content before menu items Add content after menu items Hide menu based on screen size Navbar (or AppBar) Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  NOTE When you override the app logo and when the menu is collapsed, padding-left of the menu header will reduce to 0. To center align your logo, you need to manually add margin-left to your overridden logo. # 2. Menu collapse icons If you want to change the icons for collapsing the vertical menu, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    lockedIcon?: ReactNode
    unlockedIcon?: ReactNode
  }
}
Here is the code to change the icons for collapsing the vertical menu:  Result of lockedIcon:  Result of unlockedIcon:  # 3. Menu content If you want to change the menu content, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 4. Add content before menu items If you want to add something before the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    beforeContent?: (props?: any) => ReactNode
  }
}
Here is the code to add user info before the menu items:  Result:  # 5. Add content after menu items If you want to add something after the menu items, you need to use the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  navMenu: {
    afterContent?: (props?: any) => ReactNode
  }
}
Here is the code to add menu footer info after the menu items:  Result:  # 6. Hide menu based on screen size The hidden prop is used to hide the vertical menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the vertical menu. In the example below, the vertical menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 7. Navbar (or AppBar) Content The content in the appBar comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/vertical/AppBarContent.tsx file as per your requirements. The appBar component is then passed in the verticalLayoutProps prop with the Layout component and the type accepted by this prop is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the appBar:   Result:  # 8. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 9. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps and verticalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
Refer to the following example for adding your custom styles:  # Horizontal Layout Important! As mentioned here, you need to add all the necessary items for the Vertical Layout. Please follow these steps to add items for the Vertical Layout and then follow the steps explained below. You can override the following layout components: App Logo Menu content Hide menu based on screen size AppBar Content Footer content How to add custom styles # 1. App Logo If you want to change the app logo, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    branding?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    branding?: (props?: any) => ReactNode
  }
}
Here is the code to change the app logo:  Result:  # 2. Menu content If you want to change the menu content, you need to use the verticalLayoutProps and horizontalLayoutProps props with the Layout component and the type accepted by these props is: verticalLayoutProps: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  navMenu: {
    content?: (props?: any) => ReactNode
  }
}
Here is the code to change the menu content:  Result:  # 3. Hide menu based on screen size The hidden prop is used to hide the horizontal menu at a given screen size. The menu will only be accessible from the Hamburger menu icon which is known as the Vertical Overlay Menu. You can change the screen size from which you want to hide the horizontal menu. In the example below, the horizontal menu is visible above the lg breakpoint and on screen size below the lg breakpoint, it will change to the vertical overlay menu which can be accessed from the Hamburger menu icon. const hidden = useMediaQuery((theme: Theme) => theme.breakpoints.down('lg'))
You can also change its value using a specific screen size: const hidden = useMediaQuery('(max-width:1365px)')
# 4. AppBar Content The content in the appBar which is on the right side comes from the user side itself and thus, it would be very easy and convenient for you to change anything in the appBar. You just have to change the code in the src/layouts/components/horizontal/AppBarContent.tsx file. The appBar component is then passed in the horizontalLayoutProps prop with the Layout component. The appBar component for the Vertical Layout (which comes from the src/layouts/components/vertical/AppBarContent.tsx file) is passed in the verticalLayoutProps prop with the Layout component. The type accepted by these props is: verticalLayoutProps: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
horizontalLayoutProps?: {
  appBar?: {
    content?: (props?: any) => ReactNode
  }
}
Suppose you need the app logo, navigation menu as well as some actions in one line, then you need to follow the steps given below. Firstly, you need to hide the navigation menu section which is below the appBar from the src/configs/themeConfig.ts file:  Then you need to change the appBar accordingly:  Then you need to pass that component in the horizontalLayoutProps prop with the Layout component:  Result:  # 5. Footer content If you want to change the footer content, you need to use the footerProps prop with the Layout component and the type accepted by this prop is: footerProps?: {
  content?: (props?: any) => ReactNode
}
Here is the code to change the footer content:  Result:  # 6. How to add custom styles You can add your custom styles for the whole layout with the help of footerProps, verticalLayoutProps and horizontalLayoutProps props with the Layout component. The type for the same is: footerProps?: {
  sx?: SxProps<Theme>
}
verticalLayoutProps: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu: {
    componentProps?: Omit<SwipeableDrawerProps, 'open' | 'onOpen' | 'onClose'>
  }
}
horizontalLayoutProps?: {
  appBar?: {
    componentProps?: AppBarProps
  }
  navMenu?: {
    sx?: SxProps<Theme>
  }
}
Refer to the following example for adding your custom styles:  # Blank Layout If you want to change the Blank Layout, you need to follow these steps: Make a new file (let us say UserBlankLayout.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayout.tsx file and paste it into the src/layouts/UserBlankLayout.tsx file Edit the src/layouts/UserBlankLayout.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Blank Layout with AppBar If you want to change the navbar, you need to follow these steps: Make a new file (let us say UserBlankLayoutWithAppBar.tsx file name) in the src/layouts folder Copy the whole code from the src/@core/layouts/BlankLayoutWithAppBar.tsx file and paste it into the src/layouts/UserBlankLayoutWithAppBar.tsx file Edit the src/layouts/UserBlankLayoutWithAppBar.tsx file as per your requirements Now, to use this layout in any of your pages, you need to do this:  # Scroll to Top If you want to change the scroll to top component, you need to use the scrollToTop prop with the Layout component in the src/layouts/UserLayout.tsx file and the type accepted by this prop is: scrollToTop?: (props?: any) => ReactNode
Here is the code to change the scroll to top component:  Result:  # Customizer If you want to override the customizer or make a custom customizer, then follow these steps: Hide the customizer from the src/configs/themeConfig.ts file  Make a new file (let us say Customizer.tsx file name) in the src/layouts/components folder Copy the whole code from the src/@core/components/customizer/index.tsx file and paste it into the src/layouts/components/Customizer.tsx file Edit the src/layouts/components/Customizer.tsx file as per your requirements Render this customizer in the src/layouts/UserLayout.tsx file: 
# Theming # Overview Theming is the most important aspect of any template. You can easily customize theme of our template. You can change the colors, the typography, the spacing and much more. MUI offers a utility function: createTheme() that creates a theme which can be passed to the theme provider; otherwise the theme provider uses the default theme. The theme provider makes the theme available in the component tree, and can be used via the sx prop, or inside styled components using the MUI styled engine (styled). Important Make your changes in src/layouts/UserThemeOptions.ts file in order to override colors, typography, spacing or any other component styling. Do not make any changes related to theme inside of @core folder unless suggested by our support team. Consider reading MUI theming docs  (opens new window) to understand how it works and how to access and override theme. How to override Color Palette How to customize MUI component appearance How to override Typography How to override Shadows How to override Breakpoints How to override components styling # How to override Color Palette # How to Change Colors In order to change primary color, open src/layouts/UserThemeOptions.ts file and uncomment the palette object returned from that file. palette:{
  primary: {
    light: '#8479F2',
    main: '#7367F0',
    dark: '#655BD3',
    contrastText: '#FFF'
  },
  secondary: {
    ...
  },
  success: {
    ...
  },
  error: {
    ...
  },
  warning: {
    ...
  },
  info: {
    ...
  }
}
Colors given in the above palette object are current primary colors used in our template, update those colors according to your project requirements. Above example shows how to change primary colors. You can change any colors of the palette in the same way shown above. Please refer how to customize MUI palette documentation  (opens new window). Also refer our core palette from the file src/@core/theme/palette/index.ts in order to check custom colors, dark / light colors etc.. for better idea. # Colors Tool Eva color tool https://colors.eva.design/  (opens new window) We recommend picking colors with these values: light : 400 main : 500 dark : 600 contrastText: '#FFF'  # How to customize MUI component appearance You can easily customize the appearance of any component, but it is important to understand how to customize it right way which will save the time, resources and provide optimum performance. Please read MUI doc on how to customize component appearance  (opens new window) to get clear idea. # How to override Typography # How to change font We have used Public Sans fonts  (opens new window) in the whole template. Now suppose you want to implement Montserrat fonts  (opens new window). First open src/pages/_document.tsx file and change font's URL like following: <Head>
  ...
  <link
    rel='stylesheet'
    href='https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap'
  />
  ...
</Head>
Now, open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: typography: {
  fontFamily:
    '"Montserrat", sans-serif'
}
# Use multiple fonts typography: {
  fontFamily:
    '"Public Sans", sans-serif',
  h1: {
    fontFamily:
    '"Montserrat", sans-serif',
    fontWeight: 700,
    fontSize: '3.5rem',
    lineHeight: 1.375
  },
}
Reference: https://demos.pixinvent.com/vuexy-nextjs-admin-template/demo-1/ui/typography  (opens new window) MUI: https://mui.com/material-ui/customization/typography/  (opens new window) # How to override Shadows If you want to customize shadows, uncomment following from the src/layouts/UserThemeOptions.ts file and change shadows  according to your project requirement. Make sure to enable mode from the settings which are already commented at the starting of this file if you are using dark / light both the versions. If you are using either of them, just override shadows without any conditions. // Uncomment this if using light & dark both
const { mode } = settings
// conditional shadows for both dark / light
shadows: mode === 'light' ? [...] : [...]

// Only shadows if using only one from light / dark
shadows: [...]
# How to override Breakpoints If you want to customize breakpoints, uncomment following from the src/layouts/UserThemeOptions.ts file and change breakpoints size according to your project requirement. breakpoints: {
  values: {
    xs: 0,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
}
Reference: https://mui.com/material-ui/customization/breakpoints/  (opens new window) # How to override components styling The theme's components key allows you to customize a component without wrapping it in another component. You can change the styles, the default props, and more. Open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: components: {
  MuiButton: {
    defaultProps: {
      disableElevation: true
    },
    ...
  },
  ...
}
Reference: https://mui.com/material-ui/customization/theme-components/  (opens new window)
# Theming # Overview Theming is the most important aspect of any template. You can easily customize theme of our template. You can change the colors, the typography, the spacing and much more. MUI offers a utility function: createTheme() that creates a theme which can be passed to the theme provider; otherwise the theme provider uses the default theme. The theme provider makes the theme available in the component tree, and can be used via the sx prop, or inside styled components using the MUI styled engine (styled). Important Make your changes in src/layouts/UserThemeOptions.ts file in order to override colors, typography, spacing or any other component styling. Do not make any changes related to theme inside of @core folder unless suggested by our support team. Consider reading MUI theming docs  (opens new window) to understand how it works and how to access and override theme. How to override Color Palette How to customize MUI component appearance How to override Typography How to override Shadows How to override Breakpoints How to override components styling # How to override Color Palette # How to Change Colors In order to change primary color, open src/layouts/UserThemeOptions.ts file and uncomment the palette object returned from that file. palette:{
  primary: {
    light: '#8479F2',
    main: '#7367F0',
    dark: '#655BD3',
    contrastText: '#FFF'
  },
  secondary: {
    ...
  },
  success: {
    ...
  },
  error: {
    ...
  },
  warning: {
    ...
  },
  info: {
    ...
  }
}
Colors given in the above palette object are current primary colors used in our template, update those colors according to your project requirements. Above example shows how to change primary colors. You can change any colors of the palette in the same way shown above. Please refer how to customize MUI palette documentation  (opens new window). Also refer our core palette from the file src/@core/theme/palette/index.ts in order to check custom colors, dark / light colors etc.. for better idea. # Colors Tool Eva color tool https://colors.eva.design/  (opens new window) We recommend picking colors with these values: light : 400 main : 500 dark : 600 contrastText: '#FFF'  # How to customize MUI component appearance You can easily customize the appearance of any component, but it is important to understand how to customize it right way which will save the time, resources and provide optimum performance. Please read MUI doc on how to customize component appearance  (opens new window) to get clear idea. # How to override Typography # How to change font We have used Public Sans fonts  (opens new window) in the whole template. Now suppose you want to implement Montserrat fonts  (opens new window). First open src/pages/_document.tsx file and change font's URL like following: <Head>
  ...
  <link
    rel='stylesheet'
    href='https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap'
  />
  ...
</Head>
Now, open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: typography: {
  fontFamily:
    '"Montserrat", sans-serif'
}
# Use multiple fonts typography: {
  fontFamily:
    '"Public Sans", sans-serif',
  h1: {
    fontFamily:
    '"Montserrat", sans-serif',
    fontWeight: 700,
    fontSize: '3.5rem',
    lineHeight: 1.375
  },
}
Reference: https://demos.pixinvent.com/vuexy-nextjs-admin-template/demo-1/ui/typography  (opens new window) MUI: https://mui.com/material-ui/customization/typography/  (opens new window) # How to override Shadows If you want to customize shadows, uncomment following from the src/layouts/UserThemeOptions.ts file and change shadows  according to your project requirement. Make sure to enable mode from the settings which are already commented at the starting of this file if you are using dark / light both the versions. If you are using either of them, just override shadows without any conditions. // Uncomment this if using light & dark both
const { mode } = settings
// conditional shadows for both dark / light
shadows: mode === 'light' ? [...] : [...]

// Only shadows if using only one from light / dark
shadows: [...]
# How to override Breakpoints If you want to customize breakpoints, uncomment following from the src/layouts/UserThemeOptions.ts file and change breakpoints size according to your project requirement. breakpoints: {
  values: {
    xs: 0,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
}
Reference: https://mui.com/material-ui/customization/breakpoints/  (opens new window) # How to override components styling The theme's components key allows you to customize a component without wrapping it in another component. You can change the styles, the default props, and more. Open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: components: {
  MuiButton: {
    defaultProps: {
      disableElevation: true
    },
    ...
  },
  ...
}
Reference: https://mui.com/material-ui/customization/theme-components/  (opens new window)
# Redux Vuexy uses redux-toolkit  (opens new window) for state-management. # Overview Vuexy uses redux-toolkit with hooks to manage the state for the applications. # Usage You can find all of the slices in src/store folder and You should read the redux-toolkit  (opens new window) documentation to better understand the template. # Creating a slice Create a new file in src/store, and name it email.ts and import createSlice from @reduxjs/toolkit package to create the new slice. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {}
})

export default appEmailSlice.reducer
# Creating a reducer action Let's create an action handleSelectMail that pushes a mail into selectedMails state. import { createSlice } from '@reduxjs/toolkit'

const initialState = {
  selectedMails: []
}

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {
    handleSelectMail: (state, action) => {
      // You should get mail to select from the action payload. 
      
      const mails = state.selectedMails
      if (!mails.includes(action.payload)) {
        mails.push(action.payload)
      } else {
        mails.splice(mails.indexOf(action.payload), 1)
      }
      state.selectedMails = mails
    }
  }
})

export const { handleSelectMail } = emailSlice.actions

export default appEmailSlice.reducer
Important The state is a Proxy object, you cannot update it directly, and you have to update its keys instead. For example: state = { ...mailData } will break the state, but state.selectedMails = { ...mailData } works as expected. # Fetching Data Use createAsyncThunk to fetch data from an api. import axios from 'axios'
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'

const initialState = {
  mails: null
}

// ** Fetch Mails
export const fetchMails = createAsyncThunk('appEmail/fetchMails', async (params) => {
  const response = await axios.get('/apps/email/emails', {
    params
  })

  return { ...response.data, filter: params }
})

const emailSlice = createSlice({
  name: 'email',
  initialState,
  reducers: {},
  extraReducers: builder => {

    // ** update the state.mails when the fetchMails action is fulfilled.
    builder.addCase(fetchMails.fulfilled, (state, action) => {
      state.mails = action.payload.emails
    })      
  }
})

export default appEmailSlice.reducer
# Combine the new slice in the root reducer In the file src/store/index.ts use the reducer from your newly created slice. import { configureStore } from '@reduxjs/toolkit'

import email from 'src/store/apps/email'

export const store = configureStore({
  reducer: { email },
  middleware: getDefaultMiddleware =>
    getDefaultMiddleware({
      serializableCheck: false
    })    
})
# Using the store state Use useSelector hook to access the store state. ¬†¬†import { useSelector } from 'react-redux'

const Email = () => {
  const store = useSelector(state => state.email)

  return (
    <div>
      {store.mails ? store.mails.map(mail => <div>{mail.id}</div>) : null}
    </div>
  )
}

export default Email
# Dispatching an action Use useDispatch hook to dispatch an action. ¬†¬†¬†¬†import { useDispatch, useSelector } from 'react-redux'
import { handleSelectMail } from 'src/store/email.ts'

const Email = () => {
  const dispatch = useDispatch()
  const store = useSelector(state => state.email)

  const handleMailClick = mail => {
    dispatch(handleSelectMail(mail))
  }

  return (
    <div>
      {store.mails
        ? store.mails.map(mail => <div onClick={() => handleMailClick(mail)}>{mail.id}</div>)
        : null}
    </div>
  )
}

export default Email

# Theming # Overview Theming is the most important aspect of any template. You can easily customize theme of our template. You can change the colors, the typography, the spacing and much more. MUI offers a utility function: createTheme() that creates a theme which can be passed to the theme provider; otherwise the theme provider uses the default theme. The theme provider makes the theme available in the component tree, and can be used via the sx prop, or inside styled components using the MUI styled engine (styled). Important Make your changes in src/layouts/UserThemeOptions.ts file in order to override colors, typography, spacing or any other component styling. Do not make any changes related to theme inside of @core folder unless suggested by our support team. Consider reading MUI theming docs  (opens new window) to understand how it works and how to access and override theme. How to override Color Palette How to customize MUI component appearance How to override Typography How to override Shadows How to override Breakpoints How to override components styling # How to override Color Palette # How to Change Colors In order to change primary color, open src/layouts/UserThemeOptions.ts file and uncomment the palette object returned from that file. palette:{
  primary: {
    light: '#8479F2',
    main: '#7367F0',
    dark: '#655BD3',
    contrastText: '#FFF'
  },
  secondary: {
    ...
  },
  success: {
    ...
  },
  error: {
    ...
  },
  warning: {
    ...
  },
  info: {
    ...
  }
}
Colors given in the above palette object are current primary colors used in our template, update those colors according to your project requirements. Above example shows how to change primary colors. You can change any colors of the palette in the same way shown above. Please refer how to customize MUI palette documentation  (opens new window). Also refer our core palette from the file src/@core/theme/palette/index.ts in order to check custom colors, dark / light colors etc.. for better idea. # Colors Tool Eva color tool https://colors.eva.design/  (opens new window) We recommend picking colors with these values: light : 400 main : 500 dark : 600 contrastText: '#FFF'  # How to customize MUI component appearance You can easily customize the appearance of any component, but it is important to understand how to customize it right way which will save the time, resources and provide optimum performance. Please read MUI doc on how to customize component appearance  (opens new window) to get clear idea. # How to override Typography # How to change font We have used Public Sans fonts  (opens new window) in the whole template. Now suppose you want to implement Montserrat fonts  (opens new window). First open src/pages/_document.tsx file and change font's URL like following: <Head>
  ...
  <link
    rel='stylesheet'
    href='https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap'
  />
  ...
</Head>
Now, open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: typography: {
  fontFamily:
    '"Montserrat", sans-serif'
}
# Use multiple fonts typography: {
  fontFamily:
    '"Public Sans", sans-serif',
  h1: {
    fontFamily:
    '"Montserrat", sans-serif',
    fontWeight: 700,
    fontSize: '3.5rem',
    lineHeight: 1.375
  },
}
Reference: https://demos.pixinvent.com/vuexy-nextjs-admin-template/demo-1/ui/typography  (opens new window) MUI: https://mui.com/material-ui/customization/typography/  (opens new window) # How to override Shadows If you want to customize shadows, uncomment following from the src/layouts/UserThemeOptions.ts file and change shadows  according to your project requirement. Make sure to enable mode from the settings which are already commented at the starting of this file if you are using dark / light both the versions. If you are using either of them, just override shadows without any conditions. // Uncomment this if using light & dark both
const { mode } = settings
// conditional shadows for both dark / light
shadows: mode === 'light' ? [...] : [...]

// Only shadows if using only one from light / dark
shadows: [...]
# How to override Breakpoints If you want to customize breakpoints, uncomment following from the src/layouts/UserThemeOptions.ts file and change breakpoints size according to your project requirement. breakpoints: {
  values: {
    xs: 0,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
}
Reference: https://mui.com/material-ui/customization/breakpoints/  (opens new window) # How to override components styling The theme's components key allows you to customize a component without wrapping it in another component. You can change the styles, the default props, and more. Open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: components: {
  MuiButton: {
    defaultProps: {
      disableElevation: true
    },
    ...
  },
  ...
}
Reference: https://mui.com/material-ui/customization/theme-components/  (opens new window)
# Theming # Overview Theming is the most important aspect of any template. You can easily customize theme of our template. You can change the colors, the typography, the spacing and much more. MUI offers a utility function: createTheme() that creates a theme which can be passed to the theme provider; otherwise the theme provider uses the default theme. The theme provider makes the theme available in the component tree, and can be used via the sx prop, or inside styled components using the MUI styled engine (styled). Important Make your changes in src/layouts/UserThemeOptions.ts file in order to override colors, typography, spacing or any other component styling. Do not make any changes related to theme inside of @core folder unless suggested by our support team. Consider reading MUI theming docs  (opens new window) to understand how it works and how to access and override theme. How to override Color Palette How to customize MUI component appearance How to override Typography How to override Shadows How to override Breakpoints How to override components styling # How to override Color Palette # How to Change Colors In order to change primary color, open src/layouts/UserThemeOptions.ts file and uncomment the palette object returned from that file. palette:{
  primary: {
    light: '#8479F2',
    main: '#7367F0',
    dark: '#655BD3',
    contrastText: '#FFF'
  },
  secondary: {
    ...
  },
  success: {
    ...
  },
  error: {
    ...
  },
  warning: {
    ...
  },
  info: {
    ...
  }
}
Colors given in the above palette object are current primary colors used in our template, update those colors according to your project requirements. Above example shows how to change primary colors. You can change any colors of the palette in the same way shown above. Please refer how to customize MUI palette documentation  (opens new window). Also refer our core palette from the file src/@core/theme/palette/index.ts in order to check custom colors, dark / light colors etc.. for better idea. # Colors Tool Eva color tool https://colors.eva.design/  (opens new window) We recommend picking colors with these values: light : 400 main : 500 dark : 600 contrastText: '#FFF'  # How to customize MUI component appearance You can easily customize the appearance of any component, but it is important to understand how to customize it right way which will save the time, resources and provide optimum performance. Please read MUI doc on how to customize component appearance  (opens new window) to get clear idea. # How to override Typography # How to change font We have used Public Sans fonts  (opens new window) in the whole template. Now suppose you want to implement Montserrat fonts  (opens new window). First open src/pages/_document.tsx file and change font's URL like following: <Head>
  ...
  <link
    rel='stylesheet'
    href='https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap'
  />
  ...
</Head>
Now, open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: typography: {
  fontFamily:
    '"Montserrat", sans-serif'
}
# Use multiple fonts typography: {
  fontFamily:
    '"Public Sans", sans-serif',
  h1: {
    fontFamily:
    '"Montserrat", sans-serif',
    fontWeight: 700,
    fontSize: '3.5rem',
    lineHeight: 1.375
  },
}
Reference: https://demos.pixinvent.com/vuexy-nextjs-admin-template/demo-1/ui/typography  (opens new window) MUI: https://mui.com/material-ui/customization/typography/  (opens new window) # How to override Shadows If you want to customize shadows, uncomment following from the src/layouts/UserThemeOptions.ts file and change shadows  according to your project requirement. Make sure to enable mode from the settings which are already commented at the starting of this file if you are using dark / light both the versions. If you are using either of them, just override shadows without any conditions. // Uncomment this if using light & dark both
const { mode } = settings
// conditional shadows for both dark / light
shadows: mode === 'light' ? [...] : [...]

// Only shadows if using only one from light / dark
shadows: [...]
# How to override Breakpoints If you want to customize breakpoints, uncomment following from the src/layouts/UserThemeOptions.ts file and change breakpoints size according to your project requirement. breakpoints: {
  values: {
    xs: 0,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
}
Reference: https://mui.com/material-ui/customization/breakpoints/  (opens new window) # How to override components styling The theme's components key allows you to customize a component without wrapping it in another component. You can change the styles, the default props, and more. Open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: components: {
  MuiButton: {
    defaultProps: {
      disableElevation: true
    },
    ...
  },
  ...
}
Reference: https://mui.com/material-ui/customization/theme-components/  (opens new window)
# Theming # Overview Theming is the most important aspect of any template. You can easily customize theme of our template. You can change the colors, the typography, the spacing and much more. MUI offers a utility function: createTheme() that creates a theme which can be passed to the theme provider; otherwise the theme provider uses the default theme. The theme provider makes the theme available in the component tree, and can be used via the sx prop, or inside styled components using the MUI styled engine (styled). Important Make your changes in src/layouts/UserThemeOptions.ts file in order to override colors, typography, spacing or any other component styling. Do not make any changes related to theme inside of @core folder unless suggested by our support team. Consider reading MUI theming docs  (opens new window) to understand how it works and how to access and override theme. How to override Color Palette How to customize MUI component appearance How to override Typography How to override Shadows How to override Breakpoints How to override components styling # How to override Color Palette # How to Change Colors In order to change primary color, open src/layouts/UserThemeOptions.ts file and uncomment the palette object returned from that file. palette:{
  primary: {
    light: '#8479F2',
    main: '#7367F0',
    dark: '#655BD3',
    contrastText: '#FFF'
  },
  secondary: {
    ...
  },
  success: {
    ...
  },
  error: {
    ...
  },
  warning: {
    ...
  },
  info: {
    ...
  }
}
Colors given in the above palette object are current primary colors used in our template, update those colors according to your project requirements. Above example shows how to change primary colors. You can change any colors of the palette in the same way shown above. Please refer how to customize MUI palette documentation  (opens new window). Also refer our core palette from the file src/@core/theme/palette/index.ts in order to check custom colors, dark / light colors etc.. for better idea. # Colors Tool Eva color tool https://colors.eva.design/  (opens new window) We recommend picking colors with these values: light : 400 main : 500 dark : 600 contrastText: '#FFF'  # How to customize MUI component appearance You can easily customize the appearance of any component, but it is important to understand how to customize it right way which will save the time, resources and provide optimum performance. Please read MUI doc on how to customize component appearance  (opens new window) to get clear idea. # How to override Typography # How to change font We have used Public Sans fonts  (opens new window) in the whole template. Now suppose you want to implement Montserrat fonts  (opens new window). First open src/pages/_document.tsx file and change font's URL like following: <Head>
  ...
  <link
    rel='stylesheet'
    href='https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap'
  />
  ...
</Head>
Now, open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: typography: {
  fontFamily:
    '"Montserrat", sans-serif'
}
# Use multiple fonts typography: {
  fontFamily:
    '"Public Sans", sans-serif',
  h1: {
    fontFamily:
    '"Montserrat", sans-serif',
    fontWeight: 700,
    fontSize: '3.5rem',
    lineHeight: 1.375
  },
}
Reference: https://demos.pixinvent.com/vuexy-nextjs-admin-template/demo-1/ui/typography  (opens new window) MUI: https://mui.com/material-ui/customization/typography/  (opens new window) # How to override Shadows If you want to customize shadows, uncomment following from the src/layouts/UserThemeOptions.ts file and change shadows  according to your project requirement. Make sure to enable mode from the settings which are already commented at the starting of this file if you are using dark / light both the versions. If you are using either of them, just override shadows without any conditions. // Uncomment this if using light & dark both
const { mode } = settings
// conditional shadows for both dark / light
shadows: mode === 'light' ? [...] : [...]

// Only shadows if using only one from light / dark
shadows: [...]
# How to override Breakpoints If you want to customize breakpoints, uncomment following from the src/layouts/UserThemeOptions.ts file and change breakpoints size according to your project requirement. breakpoints: {
  values: {
    xs: 0,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
}
Reference: https://mui.com/material-ui/customization/breakpoints/  (opens new window) # How to override components styling The theme's components key allows you to customize a component without wrapping it in another component. You can change the styles, the default props, and more. Open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: components: {
  MuiButton: {
    defaultProps: {
      disableElevation: true
    },
    ...
  },
  ...
}
Reference: https://mui.com/material-ui/customization/theme-components/  (opens new window)
# Theming # Overview Theming is the most important aspect of any template. You can easily customize theme of our template. You can change the colors, the typography, the spacing and much more. MUI offers a utility function: createTheme() that creates a theme which can be passed to the theme provider; otherwise the theme provider uses the default theme. The theme provider makes the theme available in the component tree, and can be used via the sx prop, or inside styled components using the MUI styled engine (styled). Important Make your changes in src/layouts/UserThemeOptions.ts file in order to override colors, typography, spacing or any other component styling. Do not make any changes related to theme inside of @core folder unless suggested by our support team. Consider reading MUI theming docs  (opens new window) to understand how it works and how to access and override theme. How to override Color Palette How to customize MUI component appearance How to override Typography How to override Shadows How to override Breakpoints How to override components styling # How to override Color Palette # How to Change Colors In order to change primary color, open src/layouts/UserThemeOptions.ts file and uncomment the palette object returned from that file. palette:{
  primary: {
    light: '#8479F2',
    main: '#7367F0',
    dark: '#655BD3',
    contrastText: '#FFF'
  },
  secondary: {
    ...
  },
  success: {
    ...
  },
  error: {
    ...
  },
  warning: {
    ...
  },
  info: {
    ...
  }
}
Colors given in the above palette object are current primary colors used in our template, update those colors according to your project requirements. Above example shows how to change primary colors. You can change any colors of the palette in the same way shown above. Please refer how to customize MUI palette documentation  (opens new window). Also refer our core palette from the file src/@core/theme/palette/index.ts in order to check custom colors, dark / light colors etc.. for better idea. # Colors Tool Eva color tool https://colors.eva.design/  (opens new window) We recommend picking colors with these values: light : 400 main : 500 dark : 600 contrastText: '#FFF'  # How to customize MUI component appearance You can easily customize the appearance of any component, but it is important to understand how to customize it right way which will save the time, resources and provide optimum performance. Please read MUI doc on how to customize component appearance  (opens new window) to get clear idea. # How to override Typography # How to change font We have used Public Sans fonts  (opens new window) in the whole template. Now suppose you want to implement Montserrat fonts  (opens new window). First open src/pages/_document.tsx file and change font's URL like following: <Head>
  ...
  <link
    rel='stylesheet'
    href='https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap'
  />
  ...
</Head>
Now, open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: typography: {
  fontFamily:
    '"Montserrat", sans-serif'
}
# Use multiple fonts typography: {
  fontFamily:
    '"Public Sans", sans-serif',
  h1: {
    fontFamily:
    '"Montserrat", sans-serif',
    fontWeight: 700,
    fontSize: '3.5rem',
    lineHeight: 1.375
  },
}
Reference: https://demos.pixinvent.com/vuexy-nextjs-admin-template/demo-1/ui/typography  (opens new window) MUI: https://mui.com/material-ui/customization/typography/  (opens new window) # How to override Shadows If you want to customize shadows, uncomment following from the src/layouts/UserThemeOptions.ts file and change shadows  according to your project requirement. Make sure to enable mode from the settings which are already commented at the starting of this file if you are using dark / light both the versions. If you are using either of them, just override shadows without any conditions. // Uncomment this if using light & dark both
const { mode } = settings
// conditional shadows for both dark / light
shadows: mode === 'light' ? [...] : [...]

// Only shadows if using only one from light / dark
shadows: [...]
# How to override Breakpoints If you want to customize breakpoints, uncomment following from the src/layouts/UserThemeOptions.ts file and change breakpoints size according to your project requirement. breakpoints: {
  values: {
    xs: 0,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
}
Reference: https://mui.com/material-ui/customization/breakpoints/  (opens new window) # How to override components styling The theme's components key allows you to customize a component without wrapping it in another component. You can change the styles, the default props, and more. Open src/layouts/UserThemeOptions.ts file and uncomment typography object like following: components: {
  MuiButton: {
    defaultProps: {
      disableElevation: true
    },
    ...
  },
  ...
}
Reference: https://mui.com/material-ui/customization/theme-components/  (opens new window)
# NextAuth with CredentialsProvider Please find below a guide for authentication with NextAuth using only the CredentialsProvider  (opens new window). Additional providers may be added or removed as per your specific requirements. For your convenience, each functional aspect has been thoroughly commented and accompanied by valuable insights and relevant links that will assist you in customizing your authentication process to align with your specific needs. Please note that customization of NextAuth to meet specific requirements, such as modifying the session strategy, adjusting session expiration times, designating authentication pages, and customizing callback functions, are not considered part of the support. These elements will vary based on the specific implementation. # [...nextauth].ts file The implementation of the authentication logic should be performed within the src/pages/api/auth/[...nextauth].ts file. It is advisable to tailor this file to suit the specific requirements of your project. The necessary configurations and instructions for customizing can be located in the NextAuth official documentation  (opens new window).  In order to successfully customize the file, it is recommended to understand its contents and how it functions. Allow us to commence. Note All the options used in the above [...nextauth].ts file are outlined and explained below. Please refer to the official NextAuth documentation  (opens new window) for a comprehensive list of available options. # providers  We utilize the CredentialsProvider  (opens new window) which enables the handling of sign-in through diverse credentials, such as a username and password. Multiple authentication providers can be configured simultaneously. Please refer to this  (opens new window) example for the comprehension of implementing NextAuth with actual APIs via CredentialsProvider. The following options are available within CredentialsProvider: # name The name to display on the sign in form (e.g. 'Sign in with...') # type Type of provider, in this case credentials # credentials The credentials to sign-in with. As we are employing our own Sign-in page, we do not need to change username or password attributes manually in the credentials. # authorize Callback to execute once user is to be authorized. You need to provide your own logic here that takes the credentials submitted and returns either an object representing a user or value that is false/null if the credentials are invalid. For e.g. return { id: 1, name: 'J Smith', email: 'jsmith@example.com' }. You can also use the req object to obtain additional parameters (i.e., the request IP address). WARNING To match the user credentials, you must make a call to the login API to receive the user data in response. It is imperative to securely remove all sensitive information from the user data, either from the API response or before returning the user data to ensure confidentiality. Kindly consult the official NextAuth documentation  (opens new window) for more providers options. # secret  It is a random string used to hash tokens, sign/encrypt cookies and generate cryptographic keys. If the NEXTAUTH_SECRET is set as an environment variable, it is not necessary to define this option. A secret can be generated by visiting the documentation link provided below. Kindly consult the official NextAuth documentation  (opens new window) for more details on secret. # session  # strategy You are required to make a choice on how you wish to preserve the user session. The default option is jwt, which involves the storage of an encrypted JWT (JWE) within a session cookie. If you elect to use an adapter, the default setting will be changed to database instead. It is still possible to explicitly specify jwt and retain a JWT session. If the option database is chosen, the session cookie will only hold a sessionToken value, which will then be used to retrieve the session information from the database. # maxAge The duration of an idle session until it expires and becomes invalid. It accepts a number in seconds. Kindly consult the official NextAuth documentation  (opens new window) for more session options. # pages  Specify URLs to be used if you want to create custom sign in, sign out and error pages. Pages specified will override the corresponding built-in page. Kindly consult the official NextAuth documentation  (opens new window) for more pages options. # callbacks  Callbacks are asynchronous functions you can use to control what happens when an action is performed. Callbacks are extremely powerful, especially in scenarios involving JSON Web Tokens as they allow you to implement access controls without a database and to integrate with external databases or APIs. # jwt This callback is called whenever a JSON Web Token is created (i.e. at sign in) or updated (i.e whenever a session is accessed in the client). The returned value will be encrypted, and it is stored in a cookie. When utilizing the jwt strategy within the session option, the jwt() callback will be executed prior to the session() callback. The data returned by the authorize function in the providers option will be passed to the jwt() callback in the form of the token. To include custom parameters in the session() callback, they must be added to the token in the jwt() callback, which will then be transferred to the session() callback for further processing. Kindly consult the official NextAuth documentation  (opens new window) for more details on jwt() callback. # session The session callback is called whenever a session is checked. By default, only a subset of the token is returned for increased security. If you want to make something available you added to the token (like access_token and user.id from above) via the jwt() callback, you have to explicitly forward it here to make it available to the client. Kindly consult the official NextAuth documentation  (opens new window) for more details on session() callback. Kindly consult the official NextAuth documentation  (opens new window) for more callbacks options.  We hope that with the information provided, you have now acquired a comprehensive understanding of all the options available within the [...nextauth].ts or [...nextauth].js file. # Login API Please create your login API, where the authentication of the user's credentials will take place. Here is the example code of it for the src/pages/api/login/index.ts file:  # next-auth.d.ts file It may be necessary to include the next-auth.d.ts file in the root directory of your project to modify certain types specified by NextAuth. In this example, the role and fullName options have been added to the user's object. The following type declaration can be added to extend NextAuth's types: import 'next-auth/jwt'
import { DefaultSession } from 'next-auth'

declare module 'next-auth/jwt' {
  interface JWT {
    role: string
    fullName: string
  }
}

declare module 'next-auth' {
  interface Session {
    user: {
      role: string
      fullName: string
    } & DefaultSession['user']
  }

  interface User {
    role: string
    fullName: string
  }
}
You may customize this file to meet your specific requirements. # src/pages/login/index.tsx file During the migration process from JWT auth to NextAuth, the src/hooks/useAuth.tsx file has been removed, causing an error in the src/pages/login/index.tsx file. To rectify the issue, kindly update this file from: ¬†¬†¬†¬†¬†¬†¬†¬†import { useAuth } from 'src/hooks/useAuth'

const auth = useAuth()

const onSubmit = (data: FormData) => {
 const { email, password } = data
 auth.login({ email, password }, () => {
   setError('email', {
     type: 'manual',
     message: 'Email or Password is invalid'
   })
 })
}
to: ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†import { useRouter } from 'next/router'
import { signIn } from 'next-auth/react'

const router = useRouter()

const onSubmit = (data: FormData) => {
const { email, password } = data
 signIn('credentials', { email, password, redirect: false }).then(res => {
   if (res && res.ok) {
     const returnUrl = router.query.returnUrl
     const redirectURL = returnUrl && returnUrl !== '/' ? returnUrl : '/'

     router.replace(redirectURL as string)
   } else {
     setError('email', {
       type: 'manual',
       message: 'Email or Password is invalid'
     })
   }
 })
}
You may customize this file to meet your specific requirements.
# How to migrate from JWT Auth to NextAuth Prerequisite It is required to have sufficient knowledge of NextAuth.js  (opens new window) before reading this migration guide How to secure API routes? As the official guide from NextAuth for securing API routes  (opens new window) is sufficient, we have not made any separate doc showing the same. How to refresh a token? If in case you need to implement refresh token functionality in your app, please refer to this  (opens new window) guide from NextAuth. To remove JWT authentication and implement NextAuth, please follow these steps: Uninstall the jsonwebtoken & @types/jsonwebtoken packages and install the next-auth package using the following command:  Delete the src/@fake-db/auth/jwt.ts, src/config/auth.ts, src/context/AuthContext.tsx and src/hooks/useAuth.tsx files Remove the import './auth/jwt' import statement from the src/@fake-db/index.ts file Remove all the types related to the AuthContext and user data from the src/context/types.ts file. If you have not added any type in this file, you may delete this file If the src/context and src/hooks folders are empty, delete them Update the Access Control (ACL) guard as the src/hooks/useAuth.tsx file has been deleted. It is not recommended to make changes in the src/@core folder, so create a new file (say src/layouts/components/auth/UserAclGuard.tsx). Copy the code from src/@core/components/auth/AclGuard.tsx file, paste it into the new file, and make necessary modifications Change the code from: ¬†¬†¬†¬†import { useAuth } from 'src/hooks/useAuth'
const auth = useAuth()

// User is logged in, build ability for the user based on his role
if (auth.user && auth.user.role && !ability) {
 setAbility(buildAbilityFor(auth.user.role, aclAbilities.subject))
}
to: ¬†¬†¬†¬†import { useSession } from 'next-auth/react'
const session = useSession()

// User is logged in, build ability for the user based on his role
if (session.data && session.data.user && session.data.user.role && !ability) {
 setAbility(buildAbilityFor(session.data.user.role, aclAbilities.subject))
}
 Update the Authentication guard as the src/hooks/useAuth.tsx file has been deleted. It is not recommended to make changes in the src/@core folder, so create a new file (say src/layouts/components/auth/UserAuthGuard.tsx). Copy the code from src/@core/components/auth/AuthGuard.tsx file, paste it into the new file, and make necessary modifications Change the code from: ¬†¬†¬†¬†¬†import { useAuth } from 'src/hooks/useAuth'
const auth = useAuth()

useEffect(
  () => {
    ...

    if (auth.user === null && !window.localStorage.getItem('userData')) {
      if (router.asPath !== '/') {
        ...
      } else {
        ...
      }
    }
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [router.route]
)

if (auth.loading || auth.user === null) {
  return fallback
}
to: ¬†¬†¬†¬†¬†import { useSession } from 'next-auth/react'
const session = useSession()

useEffect(
  () => {
    ...

    if (session.status === 'unauthenticated') {
      if (router.asPath !== '/') {
        ...
      } else {
        ...
      }
    }
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [router.route, session.status]
)

if (session.status !== 'authenticated') {
  return fallback
}
 Update the Guest guard as the src/hooks/useAuth.tsx file has been deleted. It is not recommended to make changes in the src/@core folder, so create a new file (say src/layouts/components/auth/UserGuestGuard.tsx). Copy the code from src/@core/components/auth/GuestGuard.tsx file, paste it into the new file, and make necessary modifications Change the code from: ¬†¬†¬†¬†¬†¬†¬†¬†import { useAuth } from 'src/hooks/useAuth'
const auth = useAuth()

useEffect(() => {
  ...

  if (window.localStorage.getItem('userData')) {
    ...
  }
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [router.route])

if (auth.loading || (!auth.loading && auth.user !== null)) {
  return fallback
}

return <>{children}</>
to: ¬†¬†¬†¬†¬†¬†¬†¬†¬†import { useSession } from 'next-auth/react'
const session = useSession()

useEffect(() => {
  ...

  if (session.status === 'authenticated' && !router.query.returnUrl) {
    ...
  }
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [router.route, session.status])

if (session.status === 'unauthenticated') {
  return <>{children}</>
} else {
  return fallback
}
 Update the user dropdown as the src/hooks/useAuth.tsx file has been deleted. It is not recommended to make changes in the src/@core folder, so create a new file (say src/layouts/components/UserDropdown.tsx). Copy the code from src/@core/layouts/components/shared-components/UserDropdown.tsx file, paste it into the new file, and make necessary modifications Change the code from: ¬†¬†¬†import { useAuth } from 'src/hooks/useAuth'
const { logout } = useAuth()

const handleLogout = () => {
  logout()
  handleDropdownClose()
}
to: ¬†¬†¬†¬†import { signOut } from 'next-auth/react'

const handleLogout = () => {
  signOut({ callbackUrl: '/', redirect: false }).then(() => {
    router.asPath = '/'
  })
  handleDropdownClose()
}
 Update the import statement in src/layouts/components/vertical/AppBarContent.{tsx|js} and/or src/layouts/components/horizontal/AppBarContent.{tsx|js} file(s) after creating the new file and making modifications in the previous step from: import UserDropdown from 'src/@core/layouts/components/shared-components/UserDropdown'
to: import UserDropdown from 'src/layouts/components/UserDropdown'
 As the src/hooks/useAuth.tsx file has been deleted, update the code in the src/pages/login/index.tsx file according to the NextAuth's provider. We have demonstrated CredentialsProvider and you can find the related code in this guide Update the src/pages/_app.tsx file as the new guards have been created and the AuthContext has been removed from: ¬†¬†¬†¬†¬†¬†import AclGuard from 'src/@core/components/auth/AclGuard'
import AuthGuard from 'src/@core/components/auth/AuthGuard'
import GuestGuard from 'src/@core/components/auth/GuestGuard'
import { AuthProvider } from 'src/context/AuthContext'

<AuthProvider>
  {...}
</AuthProvider>
to: ¬†¬†¬†¬†¬†¬†import AclGuard from 'src/layouts/components/auth/UserAclGuard'
import AuthGuard from 'src/layouts/components/auth/UserAuthGuard'
import GuestGuard from 'src/layouts/components/auth/UserGuestGuard'
import { SessionProvider } from 'next-auth/react'

<SessionProvider session={pageProps.session}>
  {...}
</SessionProvider>
 Update the src/pages/index.tsx file as the src/hooks/useAuth.tsx file has been deleted from: ¬†¬†¬†¬†import { useAuth } from 'src/hooks/useAuth'
const auth = useAuth()

if (auth.user && auth.user.role) {
  const homeRoute = getHomeRoute(auth.user.role)
  ...
}
to: ¬†¬†¬†¬†import { useSession } from 'next-auth/react'
const session = useSession()

if (session.status === 'authenticated') {
  const homeRoute = getHomeRoute(session.data.user?.role)
  ...
}
 Change the .env file from: NEXT_PUBLIC_JWT_SECRET= YOUR_SECRET_GOES_HERE
NEXT_PUBLIC_JWT_EXPIRATION= YOUR_EXPIRATION_DURATION_GOES_HERE
NEXT_PUBLIC_JWT_REFRESH_TOKEN_SECRET= YOUR_REFRESH_TOKEN_SECRET_GOES_HERE
to: API_URL=http://localhost:3000
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET= YOUR_SECRET_GOES_HERE
You can refer to this  (opens new window) guide for generating your own secret. For typescript-version users, add the following in the tsconfig.json file: ¬†¬†¬†"compilerOptions": {
  "paths": {
    "next-auth": [
      "./node_modules/next-auth"
    ],
    ...
  }
},
You may require the addition of the next-auth.d.ts file to your project's root directory to modify certain types specified by NextAuth. A tutorial on how to alter these types is available through the link provided in the next step. If the next-auth.d.ts file must be added, the following entry must be included in the tsconfig.json file: ¬†"include": [
  "next-auth.d.ts",
  ...
],
 Create the src/pages/api/auth/[...nextauth].ts file. Please refer to this article on how to implement authentication using CredentialsProvider  (opens new window). You may customize this file according to your requirements If you get any type errors after doing the above steps, you need to refresh/reopen your editor. This is it.
# Option Menu # Overview Use this component to add an IconButton  (opens new window) which opens a menu/dropdown  (opens new window). You can use it anywhere in your project. # Usage import Typography from '@mui/material/Typography'
import Icon from 'src/@core/components/icon'
import OptionsMenu from 'src/@core/components/option-menu'

const SomeComponent = () => {
  return (
    <OptionsMenu
      icon={<Icon icon='tabler:chevron-down' />}
      iconButtonProps={{ size: 'small', sx: { color: 'text.secondary' } }}
      options={[
        {
          icon: <Icon icon='tabler:send' />,
          text: <Typography>Send</Typography>,
          menuItemProps: {
            sx: {
              '&:hover > *': { color: 'primary.main' },
              '& svg': { mr: 2, color: 'text.secondary' }
            }
          }
        },
        { text: 'Styled Item', menuItemProps: { sx: { color: 'error.main' } } },
        {
          divider: true,
          dividerProps: {
            sx: {
              mt: theme => `${theme.spacing(2)} !important`,
              mb: theme => `${theme.spacing(2)} !important`
            }
          }
        },
        { text: 'Item with Object' },
        { text: 'Selected Menu', menuItemProps: { selected: true } },
        'Item with String',
        { text: 'Disabled Menu', menuItemProps: { disabled: true } }
      ]}
    />
  )
}

export default SomeComponent
Result:  # Props Props Type Required Description options OptionType[] Yes Add all the menu items icon ReactNode No Change the icon in the MUI's IconButton component menuProps MenuProps No Add props of the MUI's Menu component leftAlignMenu boolean No If true, menu will align to left side iconButtonProps IconButtonProps No Add props of the MUI's IconButton component iconProps SvgIconProps No Add props of the icon component # The type of OptionType is either: string OR Props Type Required Description divider boolean Yes To add a separator in the menu dividerProps DividerProps No Add props of the MUI's Divider component OR Props Type Required Description text ReactNode Yes The text inside a menu item icon ReactNode No To add an icon in a menu item menuItemProps MenuItemProps No Add props of the MUI's MenuItem component
# React Draft Wysiwyg # Overview You may visit React Draft Wysiwyg Docs  (opens new window) for a proper explanation of how to use it. We have created a wrapper that dynamically returns the editor component from the react-draft-wysiwyg package so that you don't have to do it manually all the time you use it. # Usage You can create your editor as it is in the React Draft Wysiwyg Docs  (opens new window) but make sure that you do not import the react-draft-wysiwyg package but instead add import ReactDraftWysiwyg from 'src/@core/components/react-draft-wysiwyg' import statement. Let us take a look: import ReactDraftWysiwyg from 'src/@core/components/react-draft-wysiwyg'

const Editor = () => <ReactDraftWysiwyg />

export default Editor

# Avatar # Overview Please visit MUI Avatar Docs  (opens new window) for a proper explanation of the Avatar component. Avatar component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI avatar props. # Avatar Colors Use the color prop so you don't have to use the sx prop and write the styles inside it. Use the MUI colors primary | secondary | success | error | warning | info to create colored avatars. Here is the example of how to use the colors mentioned above: import Icon from 'src/@core/components/icon'
import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar color='primary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='secondary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='success'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='error'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='warning'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='info'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
Result:  # Avatar Skins There are three skins avatar skins filled | light | light-static. Please Note: The difference between light & light-static can only be seen in the Dark layout. Here is the example of how to use the skins mentioned above: import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar skin='filled'>N</CustomAvatar> // OR <CustomAvatar>N</CustomAvatar>
<CustomAvatar skin='light' color='error'>OP</CustomAvatar>
<CustomAvatar skin='light-static' color='error'>AB</CustomAvatar>
Result:  # Props Prop Type Default Required Description skin filled, light, light-static filled No Skin of the avatar color primary, secondary, success, error, warning, info primary No Background color of the avatar
# Badge # Overview Please visit MUI Badge Docs  (opens new window) for a proper explanation of the Badge component. Badge component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI badge props. # Badge Skins There is only one badge skin light. Here is an example of how to use the skin: import Avatar from '@mui/material/Avatar'
import CustomBadge from 'src/@core/components/mui/badge'

<CustomBadge skin='light' color='primary' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='secondary' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='success' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='error' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='warning' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='info' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
Result:  # Props Prop Type Required Description skin light No Skin of the Badge
# Avatar # Overview Please visit MUI Avatar Docs  (opens new window) for a proper explanation of the Avatar component. Avatar component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI avatar props. # Avatar Colors Use the color prop so you don't have to use the sx prop and write the styles inside it. Use the MUI colors primary | secondary | success | error | warning | info to create colored avatars. Here is the example of how to use the colors mentioned above: import Icon from 'src/@core/components/icon'
import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar color='primary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='secondary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='success'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='error'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='warning'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='info'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
Result:  # Avatar Skins There are three skins avatar skins filled | light | light-static. Please Note: The difference between light & light-static can only be seen in the Dark layout. Here is the example of how to use the skins mentioned above: import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar skin='filled'>N</CustomAvatar> // OR <CustomAvatar>N</CustomAvatar>
<CustomAvatar skin='light' color='error'>OP</CustomAvatar>
<CustomAvatar skin='light-static' color='error'>AB</CustomAvatar>
Result:  # Props Prop Type Default Required Description skin filled, light, light-static filled No Skin of the avatar color primary, secondary, success, error, warning, info primary No Background color of the avatar
# Sever Side Navigation Menu # Overview On this page, you will understand how to use a server side navigation menu in Vertical layout as well as in Horizontal layout. # Vertical layout To use the server side navigation menu in the Vertical layout, follow these steps: You need to write all of your navigation section titles, navigation groups and navigation links in this structure either on your sever / API or in the src/@fake-db/server-side-menu/vertical.ts file Make an API call from your server in src/layouts/components/vertical/ServerSideNavItems.tsx file And then import src/layouts/components/vertical/ServerSideNavItems.tsx file in src/layouts/UserLayout.tsx file and pass it as shown below:  # Horizontal layout Important! As mentioned here, you need to add menu items for Vertical Navigation as well. Please follow these steps to add the Vertical Navigation and then follow the steps explained below. To use the server side navigation menu in the Horizontal layout, follow these steps: You need to write all of your navigation groups and navigation links in this structure either on your sever / API or in the src/@fake-db/server-side-menu/horizontal.ts file Make an API call from your server in src/layouts/components/horizontal/ServerSideNavItems.tsx file And then import src/layouts/components/horizontal/ServerSideNavItems.tsx file in src/layouts/UserLayout.tsx file and pass it as shown below: 
# Repeater # Overview We have created a Repeater component to duplicate a component. # Usage ¬†¬†¬†¬†import { useState } from 'react'
import Button from '@mui/material/Button'
import Typography from '@mui/material/Typography'
import Repeater from 'src/@core/components/repeater'

const Component = () => {
  const [count, setCount] = useState(1)

  return (
    <>
      <Button onClick={() => setCount(count + 1)}>Add 1</Button>
      <Repeater count={count}>
        {i => <Typography key={i}>{`Count = ${i + 1}`}</Typography>}
      </Repeater>
    </>
  )
}

export default Component
# Props Prop Type Required Description count number Yes Number of times that the component should be repeated tag React.ComponentType No Component Tag children (i: number): ReactNode Yes Your content that you want to repeat
# Sever Side Navigation Menu # Overview On this page, you will understand how to use a server side navigation menu in Vertical layout as well as in Horizontal layout. # Vertical layout To use the server side navigation menu in the Vertical layout, follow these steps: You need to write all of your navigation section titles, navigation groups and navigation links in this structure either on your sever / API or in the src/@fake-db/server-side-menu/vertical.ts file Make an API call from your server in src/layouts/components/vertical/ServerSideNavItems.tsx file And then import src/layouts/components/vertical/ServerSideNavItems.tsx file in src/layouts/UserLayout.tsx file and pass it as shown below:  # Horizontal layout Important! As mentioned here, you need to add menu items for Vertical Navigation as well. Please follow these steps to add the Vertical Navigation and then follow the steps explained below. To use the server side navigation menu in the Horizontal layout, follow these steps: You need to write all of your navigation groups and navigation links in this structure either on your sever / API or in the src/@fake-db/server-side-menu/horizontal.ts file Make an API call from your server in src/layouts/components/horizontal/ServerSideNavItems.tsx file And then import src/layouts/components/horizontal/ServerSideNavItems.tsx file in src/layouts/UserLayout.tsx file and pass it as shown below: 
# Static Navigation Menu # Overview On this page, you will understand how to use a static navigation menu in Vertical layout as well as in Horizontal layout. # Vertical layout To use the static navigation menu in the Vertical layout, follow these steps: You need to write all of your navigation section titles, navigation groups and navigation links in this structure in the src/navigation/vertical/index.ts file And then import src/navigation/vertical/index.ts file in src/layouts/UserLayout.tsx file and pass it as shown below:  # Horizontal layout Important! As mentioned here, you need to add menu items for Vertical Navigation as well. Please follow these steps to add the Vertical Navigation and then follow the steps explained below. To use the static navigation menu in the Horizontal layout, follow these steps: You need to write all of your navigation groups and navigation links in this structure in the src/navigation/horizontal/index.ts file And then import src/navigation/horizontal/index.ts file in src/layouts/UserLayout.tsx file and pass it as shown below: 
# Avatar # Overview Please visit MUI Avatar Docs  (opens new window) for a proper explanation of the Avatar component. Avatar component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI avatar props. # Avatar Colors Use the color prop so you don't have to use the sx prop and write the styles inside it. Use the MUI colors primary | secondary | success | error | warning | info to create colored avatars. Here is the example of how to use the colors mentioned above: import Icon from 'src/@core/components/icon'
import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar color='primary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='secondary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='success'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='error'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='warning'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='info'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
Result:  # Avatar Skins There are three skins avatar skins filled | light | light-static. Please Note: The difference between light & light-static can only be seen in the Dark layout. Here is the example of how to use the skins mentioned above: import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar skin='filled'>N</CustomAvatar> // OR <CustomAvatar>N</CustomAvatar>
<CustomAvatar skin='light' color='error'>OP</CustomAvatar>
<CustomAvatar skin='light-static' color='error'>AB</CustomAvatar>
Result:  # Props Prop Type Default Required Description skin filled, light, light-static filled No Skin of the avatar color primary, secondary, success, error, warning, info primary No Background color of the avatar
# Apexcharts # Overview You may visit React Apexcharts Docs  (opens new window) for a proper explanation of how to use it. We have created an Apexcharts wrapper that dynamically returns the apexcharts component from the react-apexcharts package so that you don't have to do it manually all the time you use it. # Usage You can create your chart as it is in the React Apexcharts Docs  (opens new window) but make sure that you do not import the react-apexcharts package but instead add import ReactApexcharts from 'src/@core/components/react-apexcharts' import statement. Let us take an example of a line chart: 
# Static Navigation Menu # Overview On this page, you will understand how to use a static navigation menu in Vertical layout as well as in Horizontal layout. # Vertical layout To use the static navigation menu in the Vertical layout, follow these steps: You need to write all of your navigation section titles, navigation groups and navigation links in this structure in the src/navigation/vertical/index.ts file And then import src/navigation/vertical/index.ts file in src/layouts/UserLayout.tsx file and pass it as shown below:  # Horizontal layout Important! As mentioned here, you need to add menu items for Vertical Navigation as well. Please follow these steps to add the Vertical Navigation and then follow the steps explained below. To use the static navigation menu in the Horizontal layout, follow these steps: You need to write all of your navigation groups and navigation links in this structure in the src/navigation/horizontal/index.ts file And then import src/navigation/horizontal/index.ts file in src/layouts/UserLayout.tsx file and pass it as shown below: 
# Sever Side Navigation Menu # Overview On this page, you will understand how to use a server side navigation menu in Vertical layout as well as in Horizontal layout. # Vertical layout To use the server side navigation menu in the Vertical layout, follow these steps: You need to write all of your navigation section titles, navigation groups and navigation links in this structure either on your sever / API or in the src/@fake-db/server-side-menu/vertical.ts file Make an API call from your server in src/layouts/components/vertical/ServerSideNavItems.tsx file And then import src/layouts/components/vertical/ServerSideNavItems.tsx file in src/layouts/UserLayout.tsx file and pass it as shown below:  # Horizontal layout Important! As mentioned here, you need to add menu items for Vertical Navigation as well. Please follow these steps to add the Vertical Navigation and then follow the steps explained below. To use the server side navigation menu in the Horizontal layout, follow these steps: You need to write all of your navigation groups and navigation links in this structure either on your sever / API or in the src/@fake-db/server-side-menu/horizontal.ts file Make an API call from your server in src/layouts/components/horizontal/ServerSideNavItems.tsx file And then import src/layouts/components/horizontal/ServerSideNavItems.tsx file in src/layouts/UserLayout.tsx file and pass it as shown below: 
# Checkbox # Overview We have made the custom checkbox components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Checkbox Docs  (opens new window) for a proper explanation of the Checkbox component. # Basic Custom Checkbox   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxBasicData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxBasicData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component meta ReactNode No Add content to the right side of the title. (To add meta in your checkbox, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxIconsData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the checkbox component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxIconsData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxImgData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxImgData is as follows: Property Type Required Description value string Yes Identify a particular checkbox img ReactNode Yes Image for the checkbox alt string No Alternate text for the image isSelected boolean No If true, checkbox will be selected at initial render
# Radio # Overview We have made the custom radio components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Radio Docs  (opens new window) for a proper explanation of the Radio component. # Basic Custom Radio   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioBasicData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioBasicData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component meta ReactNode No Add content to the right side of the title. (To add meta in your radio, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render # Custom Radio with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioIconsData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the radio component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioIconsData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render. (If multiple radios are selected, then it is up to the user how to handle them) # Custom Radio with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioImgData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioImgData is as follows: Property Type Required Description value string Yes Identify a particular radio img ReactNode Yes Image for the radio alt string No Alternate text for the image isSelected boolean No If true, the radio will be selected at the initial render
# Timeline Dot # Overview Please visit MUI Timeline Docs  (opens new window) for a proper explanation of the TimelineDot component. TimelineDot component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI TimelineDot props. # Timeline Dot Skins There is only one skin type of timeline dot: light. Here is an example of how to use the skin: import Icon from 'src/@core/components/icon'
import CustomTimelineDot from 'src/@core/components/mui/timeline-dot'

<CustomTimelineDot skin='light' color='error'>
  <Icon icon='tabler:plane-tilt' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='primary'>
  <Icon icon='tabler:clock-hour-4' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='warning'>
  <Icon icon='tabler:shopping-cart' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='success'>
  <Icon icon='tabler:edit' fontSize={20} />
</CustomTimelineDot>
Result:  # Props Prop Type Required Description skin light No Skin of the timeline dot
# Avatar # Overview Please visit MUI Avatar Docs  (opens new window) for a proper explanation of the Avatar component. Avatar component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI avatar props. # Avatar Colors Use the color prop so you don't have to use the sx prop and write the styles inside it. Use the MUI colors primary | secondary | success | error | warning | info to create colored avatars. Here is the example of how to use the colors mentioned above: import Icon from 'src/@core/components/icon'
import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar color='primary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='secondary'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='success'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='error'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='warning'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
<CustomAvatar color='info'>
  <Icon icon='tabler:bell' />
</CustomAvatar>
Result:  # Avatar Skins There are three skins avatar skins filled | light | light-static. Please Note: The difference between light & light-static can only be seen in the Dark layout. Here is the example of how to use the skins mentioned above: import CustomAvatar from 'src/@core/components/mui/avatar'

<CustomAvatar skin='filled'>N</CustomAvatar> // OR <CustomAvatar>N</CustomAvatar>
<CustomAvatar skin='light' color='error'>OP</CustomAvatar>
<CustomAvatar skin='light-static' color='error'>AB</CustomAvatar>
Result:  # Props Prop Type Default Required Description skin filled, light, light-static filled No Skin of the avatar color primary, secondary, success, error, warning, info primary No Background color of the avatar
# Chip # Overview Please visit MUI Chip Docs  (opens new window) for a proper explanation of the Chip component. Chip component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI chip props. # Chip Skins There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip label='Primary' skin='light' color='primary' />
<CustomChip label='Secondary' skin='light' color='secondary' />
<CustomChip label='Success' skin='light' color='success' />
<CustomChip label='Error' skin='light' color='error' />
<CustomChip label='Warning' skin='light' color='warning' />
<CustomChip label='Info' skin='light' color='info' />
Result:  # Chip Rounded There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip rounded label='Primary' skin='light' color='primary' />
<CustomChip rounded label='Secondary' skin='light' color='secondary' />
<CustomChip rounded label='Success' skin='light' color='success' />
<CustomChip rounded label='Error' skin='light' color='error' />
<CustomChip rounded label='Warning' skin='light' color='warning' />
<CustomChip rounded label='Info' skin='light' color='info' />
Result:  # Props Prop Type Required Description skin light No Skin of the chip rounded boolean No Shape of the chip
# Static Navigation Menu # Overview On this page, you will understand how to use a static navigation menu in Vertical layout as well as in Horizontal layout. # Vertical layout To use the static navigation menu in the Vertical layout, follow these steps: You need to write all of your navigation section titles, navigation groups and navigation links in this structure in the src/navigation/vertical/index.ts file And then import src/navigation/vertical/index.ts file in src/layouts/UserLayout.tsx file and pass it as shown below:  # Horizontal layout Important! As mentioned here, you need to add menu items for Vertical Navigation as well. Please follow these steps to add the Vertical Navigation and then follow the steps explained below. To use the static navigation menu in the Horizontal layout, follow these steps: You need to write all of your navigation groups and navigation links in this structure in the src/navigation/horizontal/index.ts file And then import src/navigation/horizontal/index.ts file in src/layouts/UserLayout.tsx file and pass it as shown below: 
# Checkbox # Overview We have made the custom checkbox components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Checkbox Docs  (opens new window) for a proper explanation of the Checkbox component. # Basic Custom Checkbox   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxBasicData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxBasicData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component meta ReactNode No Add content to the right side of the title. (To add meta in your checkbox, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxIconsData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the checkbox component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxIconsData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxImgData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxImgData is as follows: Property Type Required Description value string Yes Identify a particular checkbox img ReactNode Yes Image for the checkbox alt string No Alternate text for the image isSelected boolean No If true, checkbox will be selected at initial render
# Sidebar # Overview We have created a sidebar component with position absolute in case you need to show a sidebar inside a container. You can see this component used in Email and Chat apps. # Usage ¬†¬†import { useEffect } from 'react'
import Sidebar from 'src/@core/components/sidebar'

const Component = () => {
  const [show, setShow] = useState(false)

  return (
    <>
      <Sidebar show={show}>{children}</Sidebar>
      {/* Your some content */}
    </>
  )
}

export default Component
# Props Prop Type Required Description show true, false Yes If true, sidebar is visible hideBackdrop true, false No If true, sidebar backdrop is hidden direction left, right No If left, open sidebar from the left side onOpen function No Callback function on open of sidebar onClose function No Callback function on close of sidebar backDropClick function No Callback function on click of sidebar backdrop
# Checkbox # Overview We have made the custom checkbox components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Checkbox Docs  (opens new window) for a proper explanation of the Checkbox component. # Basic Custom Checkbox   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxBasicData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxBasicData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component meta ReactNode No Add content to the right side of the title. (To add meta in your checkbox, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxIconsData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the checkbox component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxIconsData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxImgData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxImgData is as follows: Property Type Required Description value string Yes Identify a particular checkbox img ReactNode Yes Image for the checkbox alt string No Alternate text for the image isSelected boolean No If true, checkbox will be selected at initial render
# Card Please visit MUI Card Docs  (opens new window) for a proper explanation of the Card component. # How to use Text Button inside Card Actions If you are using a text button inside the CardActions component, you need to add the .card-action-dense class along with the CardActions component; otherwise, it will break the alignment. Without the .card-action-dense class  With the .card-action-dense class  Here is the example of how to use the class mentioned above: ¬†<Card>
  <CardContent>...</CardContent>
  <CardActions className='card-action-dense'>
    <Button variant='text'>Button</Button>
  </CardActions>
</Card>

# Checkbox # Overview We have made the custom checkbox components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Checkbox Docs  (opens new window) for a proper explanation of the Checkbox component. # Basic Custom Checkbox   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxBasicData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxBasicData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component meta ReactNode No Add content to the right side of the title. (To add meta in your checkbox, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxIconsData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the checkbox component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxIconsData is as follows: Property Type Required Description value string Yes Identify a particular checkbox title ReactNode No Title for the checkbox component content ReactNode No Add content below the title isSelected boolean No If true, checkbox will be selected at initial render # Custom Checkbox with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the checkbox selected string[] Yes Array of selected checkboxes data CustomCheckboxImgData Yes Object to create checkbox handleChange (value: string) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected checkboxes # The type of CustomCheckboxImgData is as follows: Property Type Required Description value string Yes Identify a particular checkbox img ReactNode Yes Image for the checkbox alt string No Alternate text for the image isSelected boolean No If true, checkbox will be selected at initial render
# Page Header # Overview We have created a component to easily add a page title and subtitle to any of your pages. By using this, all of your page headers will be uniform. Heads Up! You need to render this component as a direct child of MUI's <Grid container> component. # Usage ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†import Grid from '@mui/material/Grid'
import Link from '@mui/material/Link'
import Typography from '@mui/material/Typography'
import PageHeader from 'src/@core/components/page-header'

const Component = () => {
  return (
    <Grid container spacing={6}>
      <PageHeader
        title={
          <Typography variant='h5'>
            <Link href='https://github.com/facebook/react' target='_blank'>React</Link>
          </Typography>
        }
        subtitle={
          <Typography variant='body2'>
            A declarative, efficient, and flexible JavaScript library for building user interfaces.
          </Typography>
        }
      />
    </Grid>
  )
}

export default Component
# Props Prop Type Required Description title ReactNode Yes Title of the page goes here subtitle ReactNode No Subtitle of the page goes here
# Card Statistics # Overview We have create different version of card components to make it easier for you to show your statistics neatly. # Card Statistics Horizontal import Icon from 'src/@core/components/icon'
import CardStatisticsHorizontal from 'src/@core/components/card-statistics/card-stats-horizontal'

const Component = () => (
  <CardStatisticsHorizontal
    stats='26%'
    icon='tabler:cpu'
    title='CPU Usage'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Horizontal With Details import Icon from 'src/@core/components/icon'
import CardStatsHorizontalWithDetails from 'src/@core/components/card-statistics/card-stats-horizontal-with-details'

const Component = () => (
  <CardStatsHorizontalWithDetails
    stats='19,860'
    trendDiff='-14'
    trend='negative'
    title='Active Users'
    avatarColor='success'
    icon='tabler:user-check'
    subtitle='Last week analytics'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card subtitle string Yes Subtitle of the card trendDiff string Yes To show the difference in numbers sx SxProps<Theme> No Add custom style using this prop trend positive, negative No To show the change in numbers than previous numbers iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Square import Icon from 'src/@core/components/icon'
import CardStatsSquare from 'src/@core/components/card-statistics/card-stats-square'

const Component = () => (
  <CardStatsSquare
    stats='97.8k'
    title='Orders'
    avatarColor='error'
    icon='tabler:briefcase'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Vertical import Icon from 'src/@core/components/icon'
import CardStatisticsVertical from 'src/@core/components/card-statistics/card-stats-vertical'

const Component = () => (
  <CardStatisticsVertical
    stats='24.67k'
    chipText='+25.7%'
    title='Total Sales'
    chipColor='success'
    subtitle='Last week'
    avatarColor='success'
    avatarIcon='tabler:credit-card'
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card chipText string Yes Text inside the badge/chip subtitle string Yes Subtitle of the card avatarIcon ReactNode Yes Icon inside the avatar sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar iconSize number, string No Size of the icon chipColor default, primary, secondary, success, error, warning, info No Color of the badge/chip # Card Statistics With Area Chart import Icon from 'src/@core/components/icon'
import CardStatisticsWithAreaChart from 'src/@core/components/card-statistics/card-stats-with-area-chart'

const Component = () => (
  <CardStatisticsWithAreaChart
    stats='97.5k'
    chartColor='warning'
    avatarColor='warning'
    title='Orders Received'
    avatarIcon='tabler:package'
    chartSeries=[{ data: [30, 84, 11, 76, 0, 49, 9] }]
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card avatarIcon ReactNode Yes Icon inside the avatar chartSeries ApexOptions['series'] Yes Series for the chart sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar chartColor primary, secondary, success, error, warning, info No Color of the chart avatarColor primary, secondary, success, error, warning, info No Color of the avatar avatarIconSize number, string No Size of the icon
# NextAuth with CredentialsProvider Please find below a guide for authentication with NextAuth using only the CredentialsProvider  (opens new window). Additional providers may be added or removed as per your specific requirements. For your convenience, each functional aspect has been thoroughly commented and accompanied by valuable insights and relevant links that will assist you in customizing your authentication process to align with your specific needs. Please note that customization of NextAuth to meet specific requirements, such as modifying the session strategy, adjusting session expiration times, designating authentication pages, and customizing callback functions, are not considered part of the support. These elements will vary based on the specific implementation. # [...nextauth].ts file The implementation of the authentication logic should be performed within the src/pages/api/auth/[...nextauth].ts file. It is advisable to tailor this file to suit the specific requirements of your project. The necessary configurations and instructions for customizing can be located in the NextAuth official documentation  (opens new window).  In order to successfully customize the file, it is recommended to understand its contents and how it functions. Allow us to commence. Note All the options used in the above [...nextauth].ts file are outlined and explained below. Please refer to the official NextAuth documentation  (opens new window) for a comprehensive list of available options. # providers  We utilize the CredentialsProvider  (opens new window) which enables the handling of sign-in through diverse credentials, such as a username and password. Multiple authentication providers can be configured simultaneously. Please refer to this  (opens new window) example for the comprehension of implementing NextAuth with actual APIs via CredentialsProvider. The following options are available within CredentialsProvider: # name The name to display on the sign in form (e.g. 'Sign in with...') # type Type of provider, in this case credentials # credentials The credentials to sign-in with. As we are employing our own Sign-in page, we do not need to change username or password attributes manually in the credentials. # authorize Callback to execute once user is to be authorized. You need to provide your own logic here that takes the credentials submitted and returns either an object representing a user or value that is false/null if the credentials are invalid. For e.g. return { id: 1, name: 'J Smith', email: 'jsmith@example.com' }. You can also use the req object to obtain additional parameters (i.e., the request IP address). WARNING To match the user credentials, you must make a call to the login API to receive the user data in response. It is imperative to securely remove all sensitive information from the user data, either from the API response or before returning the user data to ensure confidentiality. Kindly consult the official NextAuth documentation  (opens new window) for more providers options. # secret  It is a random string used to hash tokens, sign/encrypt cookies and generate cryptographic keys. If the NEXTAUTH_SECRET is set as an environment variable, it is not necessary to define this option. A secret can be generated by visiting the documentation link provided below. Kindly consult the official NextAuth documentation  (opens new window) for more details on secret. # session  # strategy You are required to make a choice on how you wish to preserve the user session. The default option is jwt, which involves the storage of an encrypted JWT (JWE) within a session cookie. If you elect to use an adapter, the default setting will be changed to database instead. It is still possible to explicitly specify jwt and retain a JWT session. If the option database is chosen, the session cookie will only hold a sessionToken value, which will then be used to retrieve the session information from the database. # maxAge The duration of an idle session until it expires and becomes invalid. It accepts a number in seconds. Kindly consult the official NextAuth documentation  (opens new window) for more session options. # pages  Specify URLs to be used if you want to create custom sign in, sign out and error pages. Pages specified will override the corresponding built-in page. Kindly consult the official NextAuth documentation  (opens new window) for more pages options. # callbacks  Callbacks are asynchronous functions you can use to control what happens when an action is performed. Callbacks are extremely powerful, especially in scenarios involving JSON Web Tokens as they allow you to implement access controls without a database and to integrate with external databases or APIs. # jwt This callback is called whenever a JSON Web Token is created (i.e. at sign in) or updated (i.e whenever a session is accessed in the client). The returned value will be encrypted, and it is stored in a cookie. When utilizing the jwt strategy within the session option, the jwt() callback will be executed prior to the session() callback. The data returned by the authorize function in the providers option will be passed to the jwt() callback in the form of the token. To include custom parameters in the session() callback, they must be added to the token in the jwt() callback, which will then be transferred to the session() callback for further processing. Kindly consult the official NextAuth documentation  (opens new window) for more details on jwt() callback. # session The session callback is called whenever a session is checked. By default, only a subset of the token is returned for increased security. If you want to make something available you added to the token (like access_token and user.id from above) via the jwt() callback, you have to explicitly forward it here to make it available to the client. Kindly consult the official NextAuth documentation  (opens new window) for more details on session() callback. Kindly consult the official NextAuth documentation  (opens new window) for more callbacks options.  We hope that with the information provided, you have now acquired a comprehensive understanding of all the options available within the [...nextauth].ts or [...nextauth].js file. # Login API Please create your login API, where the authentication of the user's credentials will take place. Here is the example code of it for the src/pages/api/login/index.ts file:  # next-auth.d.ts file It may be necessary to include the next-auth.d.ts file in the root directory of your project to modify certain types specified by NextAuth. In this example, the role and fullName options have been added to the user's object. The following type declaration can be added to extend NextAuth's types: import 'next-auth/jwt'
import { DefaultSession } from 'next-auth'

declare module 'next-auth/jwt' {
  interface JWT {
    role: string
    fullName: string
  }
}

declare module 'next-auth' {
  interface Session {
    user: {
      role: string
      fullName: string
    } & DefaultSession['user']
  }

  interface User {
    role: string
    fullName: string
  }
}
You may customize this file to meet your specific requirements. # src/pages/login/index.tsx file During the migration process from JWT auth to NextAuth, the src/hooks/useAuth.tsx file has been removed, causing an error in the src/pages/login/index.tsx file. To rectify the issue, kindly update this file from: ¬†¬†¬†¬†¬†¬†¬†¬†import { useAuth } from 'src/hooks/useAuth'

const auth = useAuth()

const onSubmit = (data: FormData) => {
 const { email, password } = data
 auth.login({ email, password }, () => {
   setError('email', {
     type: 'manual',
     message: 'Email or Password is invalid'
   })
 })
}
to: ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†import { useRouter } from 'next/router'
import { signIn } from 'next-auth/react'

const router = useRouter()

const onSubmit = (data: FormData) => {
const { email, password } = data
 signIn('credentials', { email, password, redirect: false }).then(res => {
   if (res && res.ok) {
     const returnUrl = router.query.returnUrl
     const redirectURL = returnUrl && returnUrl !== '/' ? returnUrl : '/'

     router.replace(redirectURL as string)
   } else {
     setError('email', {
       type: 'manual',
       message: 'Email or Password is invalid'
     })
   }
 })
}
You may customize this file to meet your specific requirements.
# Option Menu # Overview Use this component to add an IconButton  (opens new window) which opens a menu/dropdown  (opens new window). You can use it anywhere in your project. # Usage import Typography from '@mui/material/Typography'
import Icon from 'src/@core/components/icon'
import OptionsMenu from 'src/@core/components/option-menu'

const SomeComponent = () => {
  return (
    <OptionsMenu
      icon={<Icon icon='tabler:chevron-down' />}
      iconButtonProps={{ size: 'small', sx: { color: 'text.secondary' } }}
      options={[
        {
          icon: <Icon icon='tabler:send' />,
          text: <Typography>Send</Typography>,
          menuItemProps: {
            sx: {
              '&:hover > *': { color: 'primary.main' },
              '& svg': { mr: 2, color: 'text.secondary' }
            }
          }
        },
        { text: 'Styled Item', menuItemProps: { sx: { color: 'error.main' } } },
        {
          divider: true,
          dividerProps: {
            sx: {
              mt: theme => `${theme.spacing(2)} !important`,
              mb: theme => `${theme.spacing(2)} !important`
            }
          }
        },
        { text: 'Item with Object' },
        { text: 'Selected Menu', menuItemProps: { selected: true } },
        'Item with String',
        { text: 'Disabled Menu', menuItemProps: { disabled: true } }
      ]}
    />
  )
}

export default SomeComponent
Result:  # Props Props Type Required Description options OptionType[] Yes Add all the menu items icon ReactNode No Change the icon in the MUI's IconButton component menuProps MenuProps No Add props of the MUI's Menu component leftAlignMenu boolean No If true, menu will align to left side iconButtonProps IconButtonProps No Add props of the MUI's IconButton component iconProps SvgIconProps No Add props of the icon component # The type of OptionType is either: string OR Props Type Required Description divider boolean Yes To add a separator in the menu dividerProps DividerProps No Add props of the MUI's Divider component OR Props Type Required Description text ReactNode Yes The text inside a menu item icon ReactNode No To add an icon in a menu item menuItemProps MenuItemProps No Add props of the MUI's MenuItem component
# Option Menu # Overview Use this component to add an IconButton  (opens new window) which opens a menu/dropdown  (opens new window). You can use it anywhere in your project. # Usage import Typography from '@mui/material/Typography'
import Icon from 'src/@core/components/icon'
import OptionsMenu from 'src/@core/components/option-menu'

const SomeComponent = () => {
  return (
    <OptionsMenu
      icon={<Icon icon='tabler:chevron-down' />}
      iconButtonProps={{ size: 'small', sx: { color: 'text.secondary' } }}
      options={[
        {
          icon: <Icon icon='tabler:send' />,
          text: <Typography>Send</Typography>,
          menuItemProps: {
            sx: {
              '&:hover > *': { color: 'primary.main' },
              '& svg': { mr: 2, color: 'text.secondary' }
            }
          }
        },
        { text: 'Styled Item', menuItemProps: { sx: { color: 'error.main' } } },
        {
          divider: true,
          dividerProps: {
            sx: {
              mt: theme => `${theme.spacing(2)} !important`,
              mb: theme => `${theme.spacing(2)} !important`
            }
          }
        },
        { text: 'Item with Object' },
        { text: 'Selected Menu', menuItemProps: { selected: true } },
        'Item with String',
        { text: 'Disabled Menu', menuItemProps: { disabled: true } }
      ]}
    />
  )
}

export default SomeComponent
Result:  # Props Props Type Required Description options OptionType[] Yes Add all the menu items icon ReactNode No Change the icon in the MUI's IconButton component menuProps MenuProps No Add props of the MUI's Menu component leftAlignMenu boolean No If true, menu will align to left side iconButtonProps IconButtonProps No Add props of the MUI's IconButton component iconProps SvgIconProps No Add props of the icon component # The type of OptionType is either: string OR Props Type Required Description divider boolean Yes To add a separator in the menu dividerProps DividerProps No Add props of the MUI's Divider component OR Props Type Required Description text ReactNode Yes The text inside a menu item icon ReactNode No To add an icon in a menu item menuItemProps MenuItemProps No Add props of the MUI's MenuItem component
# Chip # Overview Please visit MUI Chip Docs  (opens new window) for a proper explanation of the Chip component. Chip component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI chip props. # Chip Skins There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip label='Primary' skin='light' color='primary' />
<CustomChip label='Secondary' skin='light' color='secondary' />
<CustomChip label='Success' skin='light' color='success' />
<CustomChip label='Error' skin='light' color='error' />
<CustomChip label='Warning' skin='light' color='warning' />
<CustomChip label='Info' skin='light' color='info' />
Result:  # Chip Rounded There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip rounded label='Primary' skin='light' color='primary' />
<CustomChip rounded label='Secondary' skin='light' color='secondary' />
<CustomChip rounded label='Success' skin='light' color='success' />
<CustomChip rounded label='Error' skin='light' color='error' />
<CustomChip rounded label='Warning' skin='light' color='warning' />
<CustomChip rounded label='Info' skin='light' color='info' />
Result:  # Props Prop Type Required Description skin light No Skin of the chip rounded boolean No Shape of the chip
# Chip # Overview Please visit MUI Chip Docs  (opens new window) for a proper explanation of the Chip component. Chip component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI chip props. # Chip Skins There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip label='Primary' skin='light' color='primary' />
<CustomChip label='Secondary' skin='light' color='secondary' />
<CustomChip label='Success' skin='light' color='success' />
<CustomChip label='Error' skin='light' color='error' />
<CustomChip label='Warning' skin='light' color='warning' />
<CustomChip label='Info' skin='light' color='info' />
Result:  # Chip Rounded There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip rounded label='Primary' skin='light' color='primary' />
<CustomChip rounded label='Secondary' skin='light' color='secondary' />
<CustomChip rounded label='Success' skin='light' color='success' />
<CustomChip rounded label='Error' skin='light' color='error' />
<CustomChip rounded label='Warning' skin='light' color='warning' />
<CustomChip rounded label='Info' skin='light' color='info' />
Result:  # Props Prop Type Required Description skin light No Skin of the chip rounded boolean No Shape of the chip
# Badge # Overview Please visit MUI Badge Docs  (opens new window) for a proper explanation of the Badge component. Badge component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI badge props. # Badge Skins There is only one badge skin light. Here is an example of how to use the skin: import Avatar from '@mui/material/Avatar'
import CustomBadge from 'src/@core/components/mui/badge'

<CustomBadge skin='light' color='primary' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='secondary' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='success' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='error' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='warning' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='info' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
Result:  # Props Prop Type Required Description skin light No Skin of the Badge
# Option Menu # Overview Use this component to add an IconButton  (opens new window) which opens a menu/dropdown  (opens new window). You can use it anywhere in your project. # Usage import Typography from '@mui/material/Typography'
import Icon from 'src/@core/components/icon'
import OptionsMenu from 'src/@core/components/option-menu'

const SomeComponent = () => {
  return (
    <OptionsMenu
      icon={<Icon icon='tabler:chevron-down' />}
      iconButtonProps={{ size: 'small', sx: { color: 'text.secondary' } }}
      options={[
        {
          icon: <Icon icon='tabler:send' />,
          text: <Typography>Send</Typography>,
          menuItemProps: {
            sx: {
              '&:hover > *': { color: 'primary.main' },
              '& svg': { mr: 2, color: 'text.secondary' }
            }
          }
        },
        { text: 'Styled Item', menuItemProps: { sx: { color: 'error.main' } } },
        {
          divider: true,
          dividerProps: {
            sx: {
              mt: theme => `${theme.spacing(2)} !important`,
              mb: theme => `${theme.spacing(2)} !important`
            }
          }
        },
        { text: 'Item with Object' },
        { text: 'Selected Menu', menuItemProps: { selected: true } },
        'Item with String',
        { text: 'Disabled Menu', menuItemProps: { disabled: true } }
      ]}
    />
  )
}

export default SomeComponent
Result:  # Props Props Type Required Description options OptionType[] Yes Add all the menu items icon ReactNode No Change the icon in the MUI's IconButton component menuProps MenuProps No Add props of the MUI's Menu component leftAlignMenu boolean No If true, menu will align to left side iconButtonProps IconButtonProps No Add props of the MUI's IconButton component iconProps SvgIconProps No Add props of the icon component # The type of OptionType is either: string OR Props Type Required Description divider boolean Yes To add a separator in the menu dividerProps DividerProps No Add props of the MUI's Divider component OR Props Type Required Description text ReactNode Yes The text inside a menu item icon ReactNode No To add an icon in a menu item menuItemProps MenuItemProps No Add props of the MUI's MenuItem component
# Repeater # Overview We have created a Repeater component to duplicate a component. # Usage ¬†¬†¬†¬†import { useState } from 'react'
import Button from '@mui/material/Button'
import Typography from '@mui/material/Typography'
import Repeater from 'src/@core/components/repeater'

const Component = () => {
  const [count, setCount] = useState(1)

  return (
    <>
      <Button onClick={() => setCount(count + 1)}>Add 1</Button>
      <Repeater count={count}>
        {i => <Typography key={i}>{`Count = ${i + 1}`}</Typography>}
      </Repeater>
    </>
  )
}

export default Component
# Props Prop Type Required Description count number Yes Number of times that the component should be repeated tag React.ComponentType No Component Tag children (i: number): ReactNode Yes Your content that you want to repeat
# Radio # Overview We have made the custom radio components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Radio Docs  (opens new window) for a proper explanation of the Radio component. # Basic Custom Radio   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioBasicData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioBasicData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component meta ReactNode No Add content to the right side of the title. (To add meta in your radio, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render # Custom Radio with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioIconsData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the radio component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioIconsData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render. (If multiple radios are selected, then it is up to the user how to handle them) # Custom Radio with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioImgData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioImgData is as follows: Property Type Required Description value string Yes Identify a particular radio img ReactNode Yes Image for the radio alt string No Alternate text for the image isSelected boolean No If true, the radio will be selected at the initial render
# Radio # Overview We have made the custom radio components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Radio Docs  (opens new window) for a proper explanation of the Radio component. # Basic Custom Radio   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioBasicData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioBasicData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component meta ReactNode No Add content to the right side of the title. (To add meta in your radio, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render # Custom Radio with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioIconsData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the radio component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioIconsData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render. (If multiple radios are selected, then it is up to the user how to handle them) # Custom Radio with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioImgData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioImgData is as follows: Property Type Required Description value string Yes Identify a particular radio img ReactNode Yes Image for the radio alt string No Alternate text for the image isSelected boolean No If true, the radio will be selected at the initial render
# Chip # Overview Please visit MUI Chip Docs  (opens new window) for a proper explanation of the Chip component. Chip component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI chip props. # Chip Skins There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip label='Primary' skin='light' color='primary' />
<CustomChip label='Secondary' skin='light' color='secondary' />
<CustomChip label='Success' skin='light' color='success' />
<CustomChip label='Error' skin='light' color='error' />
<CustomChip label='Warning' skin='light' color='warning' />
<CustomChip label='Info' skin='light' color='info' />
Result:  # Chip Rounded There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip rounded label='Primary' skin='light' color='primary' />
<CustomChip rounded label='Secondary' skin='light' color='secondary' />
<CustomChip rounded label='Success' skin='light' color='success' />
<CustomChip rounded label='Error' skin='light' color='error' />
<CustomChip rounded label='Warning' skin='light' color='warning' />
<CustomChip rounded label='Info' skin='light' color='info' />
Result:  # Props Prop Type Required Description skin light No Skin of the chip rounded boolean No Shape of the chip
# Radio # Overview We have made the custom radio components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Radio Docs  (opens new window) for a proper explanation of the Radio component. # Basic Custom Radio   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioBasicData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioBasicData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component meta ReactNode No Add content to the right side of the title. (To add meta in your radio, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render # Custom Radio with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioIconsData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the radio component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioIconsData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render. (If multiple radios are selected, then it is up to the user how to handle them) # Custom Radio with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioImgData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioImgData is as follows: Property Type Required Description value string Yes Identify a particular radio img ReactNode Yes Image for the radio alt string No Alternate text for the image isSelected boolean No If true, the radio will be selected at the initial render
# Badge # Overview Please visit MUI Badge Docs  (opens new window) for a proper explanation of the Badge component. Badge component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI badge props. # Badge Skins There is only one badge skin light. Here is an example of how to use the skin: import Avatar from '@mui/material/Avatar'
import CustomBadge from 'src/@core/components/mui/badge'

<CustomBadge skin='light' color='primary' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='secondary' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='success' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='error' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='warning' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='info' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
Result:  # Props Prop Type Required Description skin light No Skin of the Badge
# Timeline Dot # Overview Please visit MUI Timeline Docs  (opens new window) for a proper explanation of the TimelineDot component. TimelineDot component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI TimelineDot props. # Timeline Dot Skins There is only one skin type of timeline dot: light. Here is an example of how to use the skin: import Icon from 'src/@core/components/icon'
import CustomTimelineDot from 'src/@core/components/mui/timeline-dot'

<CustomTimelineDot skin='light' color='error'>
  <Icon icon='tabler:plane-tilt' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='primary'>
  <Icon icon='tabler:clock-hour-4' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='warning'>
  <Icon icon='tabler:shopping-cart' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='success'>
  <Icon icon='tabler:edit' fontSize={20} />
</CustomTimelineDot>
Result:  # Props Prop Type Required Description skin light No Skin of the timeline dot
# Chip # Overview Please visit MUI Chip Docs  (opens new window) for a proper explanation of the Chip component. Chip component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI chip props. # Chip Skins There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip label='Primary' skin='light' color='primary' />
<CustomChip label='Secondary' skin='light' color='secondary' />
<CustomChip label='Success' skin='light' color='success' />
<CustomChip label='Error' skin='light' color='error' />
<CustomChip label='Warning' skin='light' color='warning' />
<CustomChip label='Info' skin='light' color='info' />
Result:  # Chip Rounded There is only one chip skin light. Here is an example of how to use the skin: import CustomChip from 'src/@core/components/mui/chip'

<CustomChip rounded label='Primary' skin='light' color='primary' />
<CustomChip rounded label='Secondary' skin='light' color='secondary' />
<CustomChip rounded label='Success' skin='light' color='success' />
<CustomChip rounded label='Error' skin='light' color='error' />
<CustomChip rounded label='Warning' skin='light' color='warning' />
<CustomChip rounded label='Info' skin='light' color='info' />
Result:  # Props Prop Type Required Description skin light No Skin of the chip rounded boolean No Shape of the chip
# Radio # Overview We have made the custom radio components for you to make it easy for you and you don't have to waste your precious time. Please visit MUI Radio Docs  (opens new window) for a proper explanation of the Radio component. # Basic Custom Radio   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioBasicData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioBasicData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component meta ReactNode No Add content to the right side of the title. (To add meta in your radio, you need to add the title property as well) content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render # Custom Radio with Icons   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioIconsData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component icon string No Icon for the radio component iconProps Omit<IconProps, 'icon'> No Add props of Iconify's Icon component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioIconsData is as follows: Property Type Required Description value string Yes Identify a particular radio title ReactNode No Title for the radio component content ReactNode No Add content below the title isSelected boolean No If true, the radio will be selected at the initial render. (If multiple radios are selected, then it is up to the user how to handle them) # Custom Radio with Images   Usage:  # Props Prop Type Required Description name string Yes Name attribute of the radio selected string Yes Selected radio data CustomRadioImgData Yes Object to create radio handleChange (prop: string | ChangeEvent<HTMLInputElement>) => void Yes Run a function when an option is changed gridProps GridProps Yes Add props of the MUI's Grid component color primary, secondary, error, warning, info, success No Color of the selected radios # The type of CustomRadioImgData is as follows: Property Type Required Description value string Yes Identify a particular radio img ReactNode Yes Image for the radio alt string No Alternate text for the image isSelected boolean No If true, the radio will be selected at the initial render
# Timeline Dot # Overview Please visit MUI Timeline Docs  (opens new window) for a proper explanation of the TimelineDot component. TimelineDot component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI TimelineDot props. # Timeline Dot Skins There is only one skin type of timeline dot: light. Here is an example of how to use the skin: import Icon from 'src/@core/components/icon'
import CustomTimelineDot from 'src/@core/components/mui/timeline-dot'

<CustomTimelineDot skin='light' color='error'>
  <Icon icon='tabler:plane-tilt' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='primary'>
  <Icon icon='tabler:clock-hour-4' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='warning'>
  <Icon icon='tabler:shopping-cart' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='success'>
  <Icon icon='tabler:edit' fontSize={20} />
</CustomTimelineDot>
Result:  # Props Prop Type Required Description skin light No Skin of the timeline dot
# Repeater # Overview We have created a Repeater component to duplicate a component. # Usage ¬†¬†¬†¬†import { useState } from 'react'
import Button from '@mui/material/Button'
import Typography from '@mui/material/Typography'
import Repeater from 'src/@core/components/repeater'

const Component = () => {
  const [count, setCount] = useState(1)

  return (
    <>
      <Button onClick={() => setCount(count + 1)}>Add 1</Button>
      <Repeater count={count}>
        {i => <Typography key={i}>{`Count = ${i + 1}`}</Typography>}
      </Repeater>
    </>
  )
}

export default Component
# Props Prop Type Required Description count number Yes Number of times that the component should be repeated tag React.ComponentType No Component Tag children (i: number): ReactNode Yes Your content that you want to repeat
# Repeater # Overview We have created a Repeater component to duplicate a component. # Usage ¬†¬†¬†¬†import { useState } from 'react'
import Button from '@mui/material/Button'
import Typography from '@mui/material/Typography'
import Repeater from 'src/@core/components/repeater'

const Component = () => {
  const [count, setCount] = useState(1)

  return (
    <>
      <Button onClick={() => setCount(count + 1)}>Add 1</Button>
      <Repeater count={count}>
        {i => <Typography key={i}>{`Count = ${i + 1}`}</Typography>}
      </Repeater>
    </>
  )
}

export default Component
# Props Prop Type Required Description count number Yes Number of times that the component should be repeated tag React.ComponentType No Component Tag children (i: number): ReactNode Yes Your content that you want to repeat
# Timeline Dot # Overview Please visit MUI Timeline Docs  (opens new window) for a proper explanation of the TimelineDot component. TimelineDot component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI TimelineDot props. # Timeline Dot Skins There is only one skin type of timeline dot: light. Here is an example of how to use the skin: import Icon from 'src/@core/components/icon'
import CustomTimelineDot from 'src/@core/components/mui/timeline-dot'

<CustomTimelineDot skin='light' color='error'>
  <Icon icon='tabler:plane-tilt' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='primary'>
  <Icon icon='tabler:clock-hour-4' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='warning'>
  <Icon icon='tabler:shopping-cart' fontSize={20} />
</CustomTimelineDot>
<CustomTimelineDot skin='light' color='success'>
  <Icon icon='tabler:edit' fontSize={20} />
</CustomTimelineDot>
Result:  # Props Prop Type Required Description skin light No Skin of the timeline dot
# Badge # Overview Please visit MUI Badge Docs  (opens new window) for a proper explanation of the Badge component. Badge component is slightly modified to make it more beautiful and useable. Let's have a glance. Note We have only mentioned the extended props here but you can still use the default MUI badge props. # Badge Skins There is only one badge skin light. Here is an example of how to use the skin: import Avatar from '@mui/material/Avatar'
import CustomBadge from 'src/@core/components/mui/badge'

<CustomBadge skin='light' color='primary' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='secondary' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='success' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='error' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='warning' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
<CustomBadge skin='light' color='info' badgeContent={4}>
  <Avatar src='/images/avatars/3.png' alt='User Avatar' />
</CustomBadge>
Result:  # Props Prop Type Required Description skin light No Skin of the Badge
# Sidebar # Overview We have created a sidebar component with position absolute in case you need to show a sidebar inside a container. You can see this component used in Email and Chat apps. # Usage ¬†¬†import { useEffect } from 'react'
import Sidebar from 'src/@core/components/sidebar'

const Component = () => {
  const [show, setShow] = useState(false)

  return (
    <>
      <Sidebar show={show}>{children}</Sidebar>
      {/* Your some content */}
    </>
  )
}

export default Component
# Props Prop Type Required Description show true, false Yes If true, sidebar is visible hideBackdrop true, false No If true, sidebar backdrop is hidden direction left, right No If left, open sidebar from the left side onOpen function No Callback function on open of sidebar onClose function No Callback function on close of sidebar backDropClick function No Callback function on click of sidebar backdrop
# Sidebar # Overview We have created a sidebar component with position absolute in case you need to show a sidebar inside a container. You can see this component used in Email and Chat apps. # Usage ¬†¬†import { useEffect } from 'react'
import Sidebar from 'src/@core/components/sidebar'

const Component = () => {
  const [show, setShow] = useState(false)

  return (
    <>
      <Sidebar show={show}>{children}</Sidebar>
      {/* Your some content */}
    </>
  )
}

export default Component
# Props Prop Type Required Description show true, false Yes If true, sidebar is visible hideBackdrop true, false No If true, sidebar backdrop is hidden direction left, right No If left, open sidebar from the left side onOpen function No Callback function on open of sidebar onClose function No Callback function on close of sidebar backDropClick function No Callback function on click of sidebar backdrop
# Sidebar # Overview We have created a sidebar component with position absolute in case you need to show a sidebar inside a container. You can see this component used in Email and Chat apps. # Usage ¬†¬†import { useEffect } from 'react'
import Sidebar from 'src/@core/components/sidebar'

const Component = () => {
  const [show, setShow] = useState(false)

  return (
    <>
      <Sidebar show={show}>{children}</Sidebar>
      {/* Your some content */}
    </>
  )
}

export default Component
# Props Prop Type Required Description show true, false Yes If true, sidebar is visible hideBackdrop true, false No If true, sidebar backdrop is hidden direction left, right No If left, open sidebar from the left side onOpen function No Callback function on open of sidebar onClose function No Callback function on close of sidebar backDropClick function No Callback function on click of sidebar backdrop
# Page Header # Overview We have created a component to easily add a page title and subtitle to any of your pages. By using this, all of your page headers will be uniform. Heads Up! You need to render this component as a direct child of MUI's <Grid container> component. # Usage ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†import Grid from '@mui/material/Grid'
import Link from '@mui/material/Link'
import Typography from '@mui/material/Typography'
import PageHeader from 'src/@core/components/page-header'

const Component = () => {
  return (
    <Grid container spacing={6}>
      <PageHeader
        title={
          <Typography variant='h5'>
            <Link href='https://github.com/facebook/react' target='_blank'>React</Link>
          </Typography>
        }
        subtitle={
          <Typography variant='body2'>
            A declarative, efficient, and flexible JavaScript library for building user interfaces.
          </Typography>
        }
      />
    </Grid>
  )
}

export default Component
# Props Prop Type Required Description title ReactNode Yes Title of the page goes here subtitle ReactNode No Subtitle of the page goes here
# Page Header # Overview We have created a component to easily add a page title and subtitle to any of your pages. By using this, all of your page headers will be uniform. Heads Up! You need to render this component as a direct child of MUI's <Grid container> component. # Usage ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†import Grid from '@mui/material/Grid'
import Link from '@mui/material/Link'
import Typography from '@mui/material/Typography'
import PageHeader from 'src/@core/components/page-header'

const Component = () => {
  return (
    <Grid container spacing={6}>
      <PageHeader
        title={
          <Typography variant='h5'>
            <Link href='https://github.com/facebook/react' target='_blank'>React</Link>
          </Typography>
        }
        subtitle={
          <Typography variant='body2'>
            A declarative, efficient, and flexible JavaScript library for building user interfaces.
          </Typography>
        }
      />
    </Grid>
  )
}

export default Component
# Props Prop Type Required Description title ReactNode Yes Title of the page goes here subtitle ReactNode No Subtitle of the page goes here
# Page Header # Overview We have created a component to easily add a page title and subtitle to any of your pages. By using this, all of your page headers will be uniform. Heads Up! You need to render this component as a direct child of MUI's <Grid container> component. # Usage ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†import Grid from '@mui/material/Grid'
import Link from '@mui/material/Link'
import Typography from '@mui/material/Typography'
import PageHeader from 'src/@core/components/page-header'

const Component = () => {
  return (
    <Grid container spacing={6}>
      <PageHeader
        title={
          <Typography variant='h5'>
            <Link href='https://github.com/facebook/react' target='_blank'>React</Link>
          </Typography>
        }
        subtitle={
          <Typography variant='body2'>
            A declarative, efficient, and flexible JavaScript library for building user interfaces.
          </Typography>
        }
      />
    </Grid>
  )
}

export default Component
# Props Prop Type Required Description title ReactNode Yes Title of the page goes here subtitle ReactNode No Subtitle of the page goes here
# Card Statistics # Overview We have create different version of card components to make it easier for you to show your statistics neatly. # Card Statistics Horizontal import Icon from 'src/@core/components/icon'
import CardStatisticsHorizontal from 'src/@core/components/card-statistics/card-stats-horizontal'

const Component = () => (
  <CardStatisticsHorizontal
    stats='26%'
    icon='tabler:cpu'
    title='CPU Usage'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Horizontal With Details import Icon from 'src/@core/components/icon'
import CardStatsHorizontalWithDetails from 'src/@core/components/card-statistics/card-stats-horizontal-with-details'

const Component = () => (
  <CardStatsHorizontalWithDetails
    stats='19,860'
    trendDiff='-14'
    trend='negative'
    title='Active Users'
    avatarColor='success'
    icon='tabler:user-check'
    subtitle='Last week analytics'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card subtitle string Yes Subtitle of the card trendDiff string Yes To show the difference in numbers sx SxProps<Theme> No Add custom style using this prop trend positive, negative No To show the change in numbers than previous numbers iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Square import Icon from 'src/@core/components/icon'
import CardStatsSquare from 'src/@core/components/card-statistics/card-stats-square'

const Component = () => (
  <CardStatsSquare
    stats='97.8k'
    title='Orders'
    avatarColor='error'
    icon='tabler:briefcase'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Vertical import Icon from 'src/@core/components/icon'
import CardStatisticsVertical from 'src/@core/components/card-statistics/card-stats-vertical'

const Component = () => (
  <CardStatisticsVertical
    stats='24.67k'
    chipText='+25.7%'
    title='Total Sales'
    chipColor='success'
    subtitle='Last week'
    avatarColor='success'
    avatarIcon='tabler:credit-card'
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card chipText string Yes Text inside the badge/chip subtitle string Yes Subtitle of the card avatarIcon ReactNode Yes Icon inside the avatar sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar iconSize number, string No Size of the icon chipColor default, primary, secondary, success, error, warning, info No Color of the badge/chip # Card Statistics With Area Chart import Icon from 'src/@core/components/icon'
import CardStatisticsWithAreaChart from 'src/@core/components/card-statistics/card-stats-with-area-chart'

const Component = () => (
  <CardStatisticsWithAreaChart
    stats='97.5k'
    chartColor='warning'
    avatarColor='warning'
    title='Orders Received'
    avatarIcon='tabler:package'
    chartSeries=[{ data: [30, 84, 11, 76, 0, 49, 9] }]
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card avatarIcon ReactNode Yes Icon inside the avatar chartSeries ApexOptions['series'] Yes Series for the chart sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar chartColor primary, secondary, success, error, warning, info No Color of the chart avatarColor primary, secondary, success, error, warning, info No Color of the avatar avatarIconSize number, string No Size of the icon
# Card Statistics # Overview We have create different version of card components to make it easier for you to show your statistics neatly. # Card Statistics Horizontal import Icon from 'src/@core/components/icon'
import CardStatisticsHorizontal from 'src/@core/components/card-statistics/card-stats-horizontal'

const Component = () => (
  <CardStatisticsHorizontal
    stats='26%'
    icon='tabler:cpu'
    title='CPU Usage'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Horizontal With Details import Icon from 'src/@core/components/icon'
import CardStatsHorizontalWithDetails from 'src/@core/components/card-statistics/card-stats-horizontal-with-details'

const Component = () => (
  <CardStatsHorizontalWithDetails
    stats='19,860'
    trendDiff='-14'
    trend='negative'
    title='Active Users'
    avatarColor='success'
    icon='tabler:user-check'
    subtitle='Last week analytics'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card subtitle string Yes Subtitle of the card trendDiff string Yes To show the difference in numbers sx SxProps<Theme> No Add custom style using this prop trend positive, negative No To show the change in numbers than previous numbers iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Square import Icon from 'src/@core/components/icon'
import CardStatsSquare from 'src/@core/components/card-statistics/card-stats-square'

const Component = () => (
  <CardStatsSquare
    stats='97.8k'
    title='Orders'
    avatarColor='error'
    icon='tabler:briefcase'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Vertical import Icon from 'src/@core/components/icon'
import CardStatisticsVertical from 'src/@core/components/card-statistics/card-stats-vertical'

const Component = () => (
  <CardStatisticsVertical
    stats='24.67k'
    chipText='+25.7%'
    title='Total Sales'
    chipColor='success'
    subtitle='Last week'
    avatarColor='success'
    avatarIcon='tabler:credit-card'
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card chipText string Yes Text inside the badge/chip subtitle string Yes Subtitle of the card avatarIcon ReactNode Yes Icon inside the avatar sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar iconSize number, string No Size of the icon chipColor default, primary, secondary, success, error, warning, info No Color of the badge/chip # Card Statistics With Area Chart import Icon from 'src/@core/components/icon'
import CardStatisticsWithAreaChart from 'src/@core/components/card-statistics/card-stats-with-area-chart'

const Component = () => (
  <CardStatisticsWithAreaChart
    stats='97.5k'
    chartColor='warning'
    avatarColor='warning'
    title='Orders Received'
    avatarIcon='tabler:package'
    chartSeries=[{ data: [30, 84, 11, 76, 0, 49, 9] }]
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card avatarIcon ReactNode Yes Icon inside the avatar chartSeries ApexOptions['series'] Yes Series for the chart sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar chartColor primary, secondary, success, error, warning, info No Color of the chart avatarColor primary, secondary, success, error, warning, info No Color of the avatar avatarIconSize number, string No Size of the icon
# Card Statistics # Overview We have create different version of card components to make it easier for you to show your statistics neatly. # Card Statistics Horizontal import Icon from 'src/@core/components/icon'
import CardStatisticsHorizontal from 'src/@core/components/card-statistics/card-stats-horizontal'

const Component = () => (
  <CardStatisticsHorizontal
    stats='26%'
    icon='tabler:cpu'
    title='CPU Usage'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Horizontal With Details import Icon from 'src/@core/components/icon'
import CardStatsHorizontalWithDetails from 'src/@core/components/card-statistics/card-stats-horizontal-with-details'

const Component = () => (
  <CardStatsHorizontalWithDetails
    stats='19,860'
    trendDiff='-14'
    trend='negative'
    title='Active Users'
    avatarColor='success'
    icon='tabler:user-check'
    subtitle='Last week analytics'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card subtitle string Yes Subtitle of the card trendDiff string Yes To show the difference in numbers sx SxProps<Theme> No Add custom style using this prop trend positive, negative No To show the change in numbers than previous numbers iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Square import Icon from 'src/@core/components/icon'
import CardStatsSquare from 'src/@core/components/card-statistics/card-stats-square'

const Component = () => (
  <CardStatsSquare
    stats='97.8k'
    title='Orders'
    avatarColor='error'
    icon='tabler:briefcase'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Vertical import Icon from 'src/@core/components/icon'
import CardStatisticsVertical from 'src/@core/components/card-statistics/card-stats-vertical'

const Component = () => (
  <CardStatisticsVertical
    stats='24.67k'
    chipText='+25.7%'
    title='Total Sales'
    chipColor='success'
    subtitle='Last week'
    avatarColor='success'
    avatarIcon='tabler:credit-card'
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card chipText string Yes Text inside the badge/chip subtitle string Yes Subtitle of the card avatarIcon ReactNode Yes Icon inside the avatar sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar iconSize number, string No Size of the icon chipColor default, primary, secondary, success, error, warning, info No Color of the badge/chip # Card Statistics With Area Chart import Icon from 'src/@core/components/icon'
import CardStatisticsWithAreaChart from 'src/@core/components/card-statistics/card-stats-with-area-chart'

const Component = () => (
  <CardStatisticsWithAreaChart
    stats='97.5k'
    chartColor='warning'
    avatarColor='warning'
    title='Orders Received'
    avatarIcon='tabler:package'
    chartSeries=[{ data: [30, 84, 11, 76, 0, 49, 9] }]
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card avatarIcon ReactNode Yes Icon inside the avatar chartSeries ApexOptions['series'] Yes Series for the chart sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar chartColor primary, secondary, success, error, warning, info No Color of the chart avatarColor primary, secondary, success, error, warning, info No Color of the avatar avatarIconSize number, string No Size of the icon
# Card Statistics # Overview We have create different version of card components to make it easier for you to show your statistics neatly. # Card Statistics Horizontal import Icon from 'src/@core/components/icon'
import CardStatisticsHorizontal from 'src/@core/components/card-statistics/card-stats-horizontal'

const Component = () => (
  <CardStatisticsHorizontal
    stats='26%'
    icon='tabler:cpu'
    title='CPU Usage'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Horizontal With Details import Icon from 'src/@core/components/icon'
import CardStatsHorizontalWithDetails from 'src/@core/components/card-statistics/card-stats-horizontal-with-details'

const Component = () => (
  <CardStatsHorizontalWithDetails
    stats='19,860'
    trendDiff='-14'
    trend='negative'
    title='Active Users'
    avatarColor='success'
    icon='tabler:user-check'
    subtitle='Last week analytics'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card subtitle string Yes Subtitle of the card trendDiff string Yes To show the difference in numbers sx SxProps<Theme> No Add custom style using this prop trend positive, negative No To show the change in numbers than previous numbers iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Square import Icon from 'src/@core/components/icon'
import CardStatsSquare from 'src/@core/components/card-statistics/card-stats-square'

const Component = () => (
  <CardStatsSquare
    stats='97.8k'
    title='Orders'
    avatarColor='error'
    icon='tabler:briefcase'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Vertical import Icon from 'src/@core/components/icon'
import CardStatisticsVertical from 'src/@core/components/card-statistics/card-stats-vertical'

const Component = () => (
  <CardStatisticsVertical
    stats='24.67k'
    chipText='+25.7%'
    title='Total Sales'
    chipColor='success'
    subtitle='Last week'
    avatarColor='success'
    avatarIcon='tabler:credit-card'
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card chipText string Yes Text inside the badge/chip subtitle string Yes Subtitle of the card avatarIcon ReactNode Yes Icon inside the avatar sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar iconSize number, string No Size of the icon chipColor default, primary, secondary, success, error, warning, info No Color of the badge/chip # Card Statistics With Area Chart import Icon from 'src/@core/components/icon'
import CardStatisticsWithAreaChart from 'src/@core/components/card-statistics/card-stats-with-area-chart'

const Component = () => (
  <CardStatisticsWithAreaChart
    stats='97.5k'
    chartColor='warning'
    avatarColor='warning'
    title='Orders Received'
    avatarIcon='tabler:package'
    chartSeries=[{ data: [30, 84, 11, 76, 0, 49, 9] }]
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card avatarIcon ReactNode Yes Icon inside the avatar chartSeries ApexOptions['series'] Yes Series for the chart sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar chartColor primary, secondary, success, error, warning, info No Color of the chart avatarColor primary, secondary, success, error, warning, info No Color of the avatar avatarIconSize number, string No Size of the icon
# Card Statistics # Overview We have create different version of card components to make it easier for you to show your statistics neatly. # Card Statistics Horizontal import Icon from 'src/@core/components/icon'
import CardStatisticsHorizontal from 'src/@core/components/card-statistics/card-stats-horizontal'

const Component = () => (
  <CardStatisticsHorizontal
    stats='26%'
    icon='tabler:cpu'
    title='CPU Usage'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Horizontal With Details import Icon from 'src/@core/components/icon'
import CardStatsHorizontalWithDetails from 'src/@core/components/card-statistics/card-stats-horizontal-with-details'

const Component = () => (
  <CardStatsHorizontalWithDetails
    stats='19,860'
    trendDiff='-14'
    trend='negative'
    title='Active Users'
    avatarColor='success'
    icon='tabler:user-check'
    subtitle='Last week analytics'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card subtitle string Yes Subtitle of the card trendDiff string Yes To show the difference in numbers sx SxProps<Theme> No Add custom style using this prop trend positive, negative No To show the change in numbers than previous numbers iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Square import Icon from 'src/@core/components/icon'
import CardStatsSquare from 'src/@core/components/card-statistics/card-stats-square'

const Component = () => (
  <CardStatsSquare
    stats='97.8k'
    title='Orders'
    avatarColor='error'
    icon='tabler:briefcase'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Vertical import Icon from 'src/@core/components/icon'
import CardStatisticsVertical from 'src/@core/components/card-statistics/card-stats-vertical'

const Component = () => (
  <CardStatisticsVertical
    stats='24.67k'
    chipText='+25.7%'
    title='Total Sales'
    chipColor='success'
    subtitle='Last week'
    avatarColor='success'
    avatarIcon='tabler:credit-card'
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card chipText string Yes Text inside the badge/chip subtitle string Yes Subtitle of the card avatarIcon ReactNode Yes Icon inside the avatar sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar iconSize number, string No Size of the icon chipColor default, primary, secondary, success, error, warning, info No Color of the badge/chip # Card Statistics With Area Chart import Icon from 'src/@core/components/icon'
import CardStatisticsWithAreaChart from 'src/@core/components/card-statistics/card-stats-with-area-chart'

const Component = () => (
  <CardStatisticsWithAreaChart
    stats='97.5k'
    chartColor='warning'
    avatarColor='warning'
    title='Orders Received'
    avatarIcon='tabler:package'
    chartSeries=[{ data: [30, 84, 11, 76, 0, 49, 9] }]
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card avatarIcon ReactNode Yes Icon inside the avatar chartSeries ApexOptions['series'] Yes Series for the chart sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar chartColor primary, secondary, success, error, warning, info No Color of the chart avatarColor primary, secondary, success, error, warning, info No Color of the avatar avatarIconSize number, string No Size of the icon
# Card Statistics # Overview We have create different version of card components to make it easier for you to show your statistics neatly. # Card Statistics Horizontal import Icon from 'src/@core/components/icon'
import CardStatisticsHorizontal from 'src/@core/components/card-statistics/card-stats-horizontal'

const Component = () => (
  <CardStatisticsHorizontal
    stats='26%'
    icon='tabler:cpu'
    title='CPU Usage'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Horizontal With Details import Icon from 'src/@core/components/icon'
import CardStatsHorizontalWithDetails from 'src/@core/components/card-statistics/card-stats-horizontal-with-details'

const Component = () => (
  <CardStatsHorizontalWithDetails
    stats='19,860'
    trendDiff='-14'
    trend='negative'
    title='Active Users'
    avatarColor='success'
    icon='tabler:user-check'
    subtitle='Last week analytics'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card subtitle string Yes Subtitle of the card trendDiff string Yes To show the difference in numbers sx SxProps<Theme> No Add custom style using this prop trend positive, negative No To show the change in numbers than previous numbers iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Square import Icon from 'src/@core/components/icon'
import CardStatsSquare from 'src/@core/components/card-statistics/card-stats-square'

const Component = () => (
  <CardStatsSquare
    stats='97.8k'
    title='Orders'
    avatarColor='error'
    icon='tabler:briefcase'
  />
)

export default Component
Result:  # Props Prop Type Required Description icon ReactNode Yes Icon inside the avatar stats string Yes The statistic number on the card title string Yes Title of the card sx SxProps<Theme> No Add custom style using this prop iconSize number, string No Size of the icon avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar # Card Statistics Vertical import Icon from 'src/@core/components/icon'
import CardStatisticsVertical from 'src/@core/components/card-statistics/card-stats-vertical'

const Component = () => (
  <CardStatisticsVertical
    stats='24.67k'
    chipText='+25.7%'
    title='Total Sales'
    chipColor='success'
    subtitle='Last week'
    avatarColor='success'
    avatarIcon='tabler:credit-card'
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card chipText string Yes Text inside the badge/chip subtitle string Yes Subtitle of the card avatarIcon ReactNode Yes Icon inside the avatar sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar avatarColor primary, secondary, success, error, warning, info No Color of the avatar iconSize number, string No Size of the icon chipColor default, primary, secondary, success, error, warning, info No Color of the badge/chip # Card Statistics With Area Chart import Icon from 'src/@core/components/icon'
import CardStatisticsWithAreaChart from 'src/@core/components/card-statistics/card-stats-with-area-chart'

const Component = () => (
  <CardStatisticsWithAreaChart
    stats='97.5k'
    chartColor='warning'
    avatarColor='warning'
    title='Orders Received'
    avatarIcon='tabler:package'
    chartSeries=[{ data: [30, 84, 11, 76, 0, 49, 9] }]
  />
)

export default Component
Result:  # Props Prop Type Required Description stats string Yes The statistic number on the card title string Yes Title of the card avatarIcon ReactNode Yes Icon inside the avatar chartSeries ApexOptions['series'] Yes Series for the chart sx SxProps<Theme> No Add custom style using this prop avatarSize number No Size of the avatar chartColor primary, secondary, success, error, warning, info No Color of the chart avatarColor primary, secondary, success, error, warning, info No Color of the avatar avatarIconSize number, string No Size of the icon